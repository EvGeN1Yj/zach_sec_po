# Ответы на вопросы к зачёту
## Раздел 8: Операционная безопасность и защита инфраструктуры

### 176. Как настроить демилитаризованную зону (DMZ)?

**Ответ:** Настройка **DMZ (Demilitarized Zone)** — изолированной сетевой зоны между внутренней сетью и интернетом для размещения публично доступных сервисов.

**Архитектура DMZ:**

```
Интернет
  ↓
[Firewall внешний]
  ↓
[DMZ] ← Публичные сервисы (веб-сервер, DNS, email)
  ↓
[Firewall внутренний]
  ↓
[Внутренняя сеть] ← Приватные сервисы
```

**Настройка с использованием iptables (Linux):**

```bash
# Внешний firewall
# Разрешить входящие соединения к DMZ
iptables -A FORWARD -i eth0 -o eth1 -d 10.0.1.0/24 -j ACCEPT
# Разрешить ответы из DMZ
iptables -A FORWARD -i eth1 -o eth0 -s 10.0.1.0/24 -j ACCEPT

# Внутренний firewall
# Разрешить исходящие из внутренней сети
iptables -A FORWARD -i eth2 -o eth1 -s 192.168.1.0/24 -d 10.0.1.0/24 -j ACCEPT
# Разрешить ответы в внутреннюю сеть
iptables -A FORWARD -i eth1 -o eth2 -s 10.0.1.0/24 -d 192.168.1.0/24 -j ACCEPT
# Запретить прямой доступ из DMZ во внутреннюю сеть
iptables -A FORWARD -i eth1 -o eth2 -s 10.0.1.0/24 -d 192.168.1.0/24 -j DROP
```

**Настройка с использованием pfSense:**

1. **Создание VLAN для DMZ:**
   - Интерфейсы → VLANs → Add
   - VLAN Tag: 100
   - Description: DMZ

2. **Настройка правил firewall:**
```bash
# WAN → DMZ (только необходимые порты)
Rule: Allow HTTP/HTTPS to DMZ Web Server
Source: Any
Destination: DMZ Web Server (10.0.1.10)
Port: 80, 443
Action: Allow

# DMZ → WAN (только исходящие ответы)
Rule: Allow DMZ to WAN responses
Source: DMZ
Destination: Any
Port: Any
Action: Allow

# LAN → DMZ (для администрации)
Rule: Allow Admin to DMZ
Source: Admin Network (192.168.1.0/24)
Destination: DMZ
Port: 22 (SSH)
Action: Allow

# DMZ → LAN (запрещено)
Rule: Block DMZ to LAN
Source: DMZ
Destination: LAN
Action: Block
```

**Настройка в облаке (AWS):**

```yaml
# CloudFormation example
Resources:
  PublicSubnet:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      CidrBlock: 10.0.1.0/24
      AvailabilityZone: us-east-1a
  
  DMZSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: DMZ Security Group
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0
      SecurityGroupEgress:
        - IpProtocol: -1
          CidrIp: 0.0.0.0/0
```

**Принципы настройки DMZ:**

1. **Минимальные права:**
   - Только необходимые порты открыты
   - Запрещён прямой доступ из DMZ во внутреннюю сеть

2. **Изоляция:**
   - Отдельная подсеть для DMZ
   - Раздельные firewall правила

3. **Мониторинг:**
   - Логирование всего трафика DMZ
   - Алерты на подозрительную активность

4. **Резервирование:**
   - Дублирование критичных сервисов
   - Load balancing

---

### 177. Как настроить контроль доступа к базе данных?

**Ответ:** Настройка контроля доступа к базе данных включает несколько уровней:

**1. Аутентификация (Authentication):**

**PostgreSQL:**
```conf
# pg_hba.conf
# Локальные соединения
local   all             all                                     md5
# Сетевое соединение с паролем
host    all             all             127.0.0.1/32            md5
# Сетевое соединение через SSL
hostssl all             all             10.0.0.0/8              md5
```

**MySQL:**
```sql
-- Создание пользователя
CREATE USER 'app_user'@'10.0.1.%' IDENTIFIED BY 'strong_password';

-- Настройка политики паролей
SET GLOBAL validate_password.policy = STRONG;
SET GLOBAL validate_password.length = 12;
```

**2. Авторизация (Authorization):**

**PostgreSQL:**
```sql
-- Создание роли
CREATE ROLE readonly_role;

-- Предоставление прав на чтение
GRANT SELECT ON ALL TABLES IN SCHEMA public TO readonly_role;
GRANT SELECT ON ALL SEQUENCES IN SCHEMA public TO readonly_role;

-- Назначение роли пользователю
GRANT readonly_role TO app_user;

-- Принцип наименьших привилегий
REVOKE ALL ON DATABASE mydb FROM PUBLIC;
```

**MySQL:**
```sql
-- Предоставление минимальных прав
GRANT SELECT, INSERT ON mydb.users TO 'app_user'@'10.0.1.%';
GRANT SELECT ON mydb.products TO 'app_user'@'10.0.1.%';

-- Отзыв прав
REVOKE ALL PRIVILEGES ON *.* FROM 'app_user'@'10.0.1.%';
```

**3. Шифрование соединений:**

**PostgreSQL:**
```conf
# postgresql.conf
ssl = on
ssl_cert_file = '/etc/ssl/certs/server.crt'
ssl_key_file = '/etc/ssl/private/server.key'
```

**4. Сетевая изоляция:**

```bash
# Firewall правила
# Разрешить доступ только с application серверов
iptables -A INPUT -p tcp --dport 5432 -s 10.0.1.10 -j ACCEPT
iptables -A INPUT -p tcp --dport 5432 -j DROP
```

**5. Аудит доступа:**

**PostgreSQL:**
```conf
# postgresql.conf
log_connections = on
log_disconnections = on
log_statement = 'all'
log_line_prefix = '%t [%p]: [%l-1] user=%u,db=%d,app=%a,client=%h '
```

**6. Row-Level Security (RLS):**

```sql
-- Включение RLS
ALTER TABLE users ENABLE ROW LEVEL SECURITY;

-- Политика доступа
CREATE POLICY user_isolation ON users
    FOR ALL
    TO app_user
    USING (tenant_id = current_setting('app.tenant_id')::int);
```

**7. Connection Pooling с ограничениями:**

```yaml
# PgBouncer config
[databases]
mydb = host=localhost port=5432 dbname=mydb

[pgbouncer]
pool_mode = transaction
max_client_conn = 100
default_pool_size = 20
reserve_pool_size = 5
```

**8. Использование секретов:**

```yaml
# Kubernetes Secret
apiVersion: v1
kind: Secret
metadata:
  name: db-credentials
type: Opaque
data:
  username: YXBwX3VzZXI=  # base64 encoded
  password: c3Ryb25nX3Bhc3N3b3Jk
```

```python
# Использование секретов в приложении
import os
from cryptography.fernet import Fernet

db_user = os.getenv('DB_USER')
db_password = decrypt_secret(os.getenv('DB_PASSWORD_ENCRYPTED'))
```

**Рекомендации:**
- Принцип наименьших привилегий
- Регулярная ротация паролей
- Шифрование соединений (TLS)
- Аудит всех действий
- Ограничение сетевого доступа

---

### 178. Как настроить и проверить работу Web Application Firewall (WAF)?

**Ответ:** Настройка и проверка **WAF (Web Application Firewall)**:

**1. Настройка ModSecurity (Apache/Nginx):**

```apache
# Apache mod_security.conf
<IfModule mod_security2.c>
    SecRuleEngine On
    SecRequestBodyAccess On
    SecResponseBodyAccess On
    
    # База правил OWASP Core Rule Set
    Include /etc/modsecurity/crs-setup.conf
    Include /etc/modsecurity/rules/*.conf
    
    # Логирование
    SecAuditEngine RelevantOnly
    SecAuditLog /var/log/modsecurity/audit.log
</IfModule>
```

**2. Настройка AWS WAF:**

```yaml
# CloudFormation
Resources:
  WebACL:
    Type: AWS::WAFv2::WebACL
    Properties:
      Name: ProductionWebACL
      Scope: REGIONAL
      DefaultAction:
        Allow: {}
      Rules:
        - Name: AWSManagedRulesCommonRuleSet
          Priority: 1
          OverrideAction:
            None: {}
          Statement:
            ManagedRuleGroupStatement:
              VendorName: AWS
              Name: AWSManagedRulesCommonRuleSet
        - Name: RateLimitRule
          Priority: 2
          Action:
            Block: {}
          Statement:
            RateBasedStatement:
              Limit: 2000
              AggregateKeyType: IP
```

**3. Настройка Cloudflare WAF:**

```javascript
// Cloudflare Workers для кастомных правил
addEventListener('fetch', event => {
  event.respondWith(handleRequest(event.request))
})

async function handleRequest(request) {
  // Проверка User-Agent
  const userAgent = request.headers.get('User-Agent')
  if (isMaliciousUserAgent(userAgent)) {
    return new Response('Forbidden', { status: 403 })
  }
  
  // Rate limiting
  const ip = request.headers.get('CF-Connecting-IP')
  if (await isRateLimited(ip)) {
    return new Response('Rate limited', { status: 429 })
  }
  
  return fetch(request)
}
```

**4. Проверка работы WAF:**

**Тест на SQL Injection:**
```bash
curl -X GET "https://example.com/search?q=1' OR '1'='1" \
  -H "User-Agent: Mozilla/5.0"
# Ожидаемый результат: 403 Forbidden или блокировка
```

**Тест на XSS:**
```bash
curl -X POST "https://example.com/comment" \
  -d "comment=<script>alert('XSS')</script>"
# Ожидаемый результат: Блокировка
```

**Тест на Path Traversal:**
```bash
curl "https://example.com/file?path=../../../etc/passwd"
# Ожидаемый результат: Блокировка
```

**Тест на Rate Limiting:**
```bash
# Множественные запросы
for i in {1..1000}; do
  curl "https://example.com/api/endpoint" &
done
# Ожидаемый результат: Блокировка после превышения лимита
```

**5. Мониторинг WAF:**

```python
import boto3
from datetime import datetime, timedelta

def check_waf_metrics():
    cloudwatch = boto3.client('cloudwatch')
    
    # Метрики блокировок
    response = cloudwatch.get_metric_statistics(
        Namespace='AWS/WAFV2',
        MetricName='BlockedRequests',
        Dimensions=[
            {'Name': 'WebACL', 'Value': 'ProductionWebACL'},
            {'Name': 'Rule', 'Value': 'AWSManagedRulesCommonRuleSet'}
        ],
        StartTime=datetime.utcnow() - timedelta(hours=1),
        EndTime=datetime.utcnow(),
        Period=300,
        Statistics=['Sum']
    )
    
    blocked_count = sum(point['Sum'] for point in response['Datapoints'])
    print(f"Blocked requests: {blocked_count}")
```

**6. Логирование и анализ:**

```bash
# Просмотр логов ModSecurity
tail -f /var/log/modsecurity/audit.log | grep "ModSecurity: Access denied"

# Анализ блокировок
grep "403" /var/log/nginx/access.log | \
  awk '{print $7}' | sort | uniq -c | sort -rn | head -10
```

**7. Настройка алертов:**

```yaml
# Alertmanager config для Prometheus
groups:
  - name: waf_alerts
    rules:
      - alert: HighWAFBlockRate
        expr: rate(waf_blocked_requests[5m]) > 10
        for: 5m
        annotations:
          summary: "High rate of WAF blocks detected"
```

**Критерии успешной настройки:**
- Блокировка известных атак (SQL Injection, XSS)
- Минимум false positives
- Мониторинг и алерты работают
- Логирование всех событий

---

### 179. Как настроить резервное копирование и восстановление (backup & restore)?

**Ответ:** Настройка резервного копирования и восстановления:

**1. Резервное копирование базы данных:**

**PostgreSQL:**
```bash
#!/bin/bash
# backup.sh
BACKUP_DIR="/backups/postgresql"
DATE=$(date +%Y%m%d_%H%M%S)
DB_NAME="mydb"

# Создание backup
pg_dump -h localhost -U backup_user -F c -b -v -f "$BACKUP_DIR/${DB_NAME}_${DATE}.backup" $DB_NAME

# Сжатие
gzip "$BACKUP_DIR/${DB_NAME}_${DATE}.backup"

# Удаление старых backup (старше 30 дней)
find $BACKUP_DIR -name "*.backup.gz" -mtime +30 -delete

# Загрузка в облако
aws s3 cp "$BACKUP_DIR/${DB_NAME}_${DATE}.backup.gz" \
  s3://backup-bucket/postgresql/
```

**Cron job:**
```cron
# Ежедневное резервное копирование в 2:00
0 2 * * * /usr/local/bin/backup.sh >> /var/log/backup.log 2>&1
```

**2. Восстановление:**

```bash
# Восстановление из backup
gunzip mydb_20240115_020000.backup.gz
pg_restore -h localhost -U postgres -d mydb_new -v mydb_20240115_020000.backup

# Восстановление из SQL dump
psql -h localhost -U postgres -d mydb < backup.sql
```

**3. Инкрементальное резервное копирование:**

**PostgreSQL WAL Archiving:**
```conf
# postgresql.conf
wal_level = replica
archive_mode = on
archive_command = 'test ! -f /backups/wal/%f && cp %p /backups/wal/%f'
```

**4. Резервное копирование файлов:**

```bash
#!/bin/bash
# files_backup.sh
SOURCE_DIR="/var/www"
BACKUP_DIR="/backups/files"
DATE=$(date +%Y%m%d_%H%M%S)

# Создание архива
tar -czf "$BACKUP_DIR/files_${DATE}.tar.gz" $SOURCE_DIR

# Проверка целостности
if tar -tzf "$BACKUP_DIR/files_${DATE}.tar.gz" > /dev/null; then
    echo "Backup verified successfully"
else
    echo "Backup verification failed!"
    exit 1
fi
```

**5. Автоматическое резервное копирование с уведомлениями:**

```python
import subprocess
import smtplib
from email.mime.text import MIMEText
from datetime import datetime

def backup_and_notify():
    try:
        # Выполнение backup
        result = subprocess.run(['/usr/local/bin/backup.sh'], 
                              capture_output=True, text=True)
        
        if result.returncode == 0:
            send_email("Backup successful", "Backup completed successfully")
        else:
            send_email("Backup failed", result.stderr)
    except Exception as e:
        send_email("Backup error", str(e))

def send_email(subject, body):
    msg = MIMEText(body)
    msg['Subject'] = subject
    msg['From'] = 'backup@example.com'
    msg['To'] = 'admin@example.com'
    
    smtp = smtplib.SMTP('smtp.example.com')
    smtp.send_message(msg)
    smtp.quit()
```

**6. Тестирование восстановления:**

```bash
#!/bin/bash
# test_restore.sh
# Тестирование восстановления на тестовом сервере

# 1. Восстановление базы данных
pg_restore -h test-db -U postgres -d testdb latest.backup

# 2. Проверка целостности
psql -h test-db -U postgres -d testdb -c "SELECT COUNT(*) FROM users;"

# 3. Проверка приложения
curl -f http://test-app.example.com/health || exit 1

echo "Restore test successful"
```

**7. Резервное копирование в облако:**

```python
import boto3
from botocore.client import Config

def backup_to_s3(local_file, s3_bucket, s3_key):
    s3 = boto3.client('s3', 
                     config=Config(signature_version='s3v4'))
    
    # Загрузка с multipart для больших файлов
    s3.upload_file(local_file, s3_bucket, s3_key,
                  ExtraArgs={'ServerSideEncryption': 'AES256'})
    
    # Включение versioning
    s3.put_bucket_versioning(
        Bucket=s3_bucket,
        VersioningConfiguration={'Status': 'Enabled'}
    )
```

**Правила 3-2-1:**
- **3** копии данных
- **2** разных типа носителей
- **1** копия вне площадки

---

### 180. Как настроить проверку цепочки сертификатов TLS?

**Ответ:** Настройка проверки цепочки сертификатов TLS:

**1. Настройка веб-сервера (Nginx):**

```nginx
server {
    listen 443 ssl http2;
    server_name example.com;
    
    # Сертификаты
    ssl_certificate /etc/ssl/certs/example.com.crt;
    ssl_certificate_key /etc/ssl/private/example.com.key;
    
    # Проверка цепочки (по умолчанию включена)
    ssl_verify_client on;  # Для client certificates
    
    # Настройки SSL
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;
    ssl_prefer_server_ciphers on;
    
    # Проверка цепочки сертификатов
    ssl_trusted_certificate /etc/ssl/certs/ca-bundle.crt;
    ssl_verify_depth 3;
}
```

**2. Проверка сертификата на клиенте (Python):**

```python
import ssl
import socket
import certifi

def verify_certificate(hostname, port=443):
    context = ssl.create_default_context(cafile=certifi.where())
    
    with socket.create_connection((hostname, port)) as sock:
        with context.wrap_socket(sock, server_hostname=hostname) as ssock:
            cert = ssock.getpeercert()
            
            # Проверка цепочки
            chain = ssock.getpeercert_chain()
            
            # Валидация сертификата
            try:
                ssl.match_hostname(cert, hostname)
                print(f"Certificate verified for {hostname}")
                return True
            except ssl.CertificateError as e:
                print(f"Certificate verification failed: {e}")
                return False
```

**3. Проверка с помощью OpenSSL:**

```bash
# Проверка цепочки сертификатов
openssl s_client -connect example.com:443 -showcerts -verify_return_error

# Проверка с указанием CA bundle
openssl s_client -connect example.com:443 \
  -CAfile /etc/ssl/certs/ca-bundle.crt \
  -verify_return_error

# Проверка валидности сертификата
openssl verify -CAfile /etc/ssl/certs/ca-bundle.crt \
  /etc/ssl/certs/example.com.crt
```

**4. Автоматическая проверка сертификатов:**

```python
import ssl
import socket
from datetime import datetime

def check_certificate_expiry(hostname, port=443):
    context = ssl.create_default_context()
    
    with socket.create_connection((hostname, port)) as sock:
        with context.wrap_socket(sock, server_hostname=hostname) as ssock:
            cert = ssock.getpeercert()
            
            # Проверка срока действия
            not_after = datetime.strptime(cert['notAfter'], 
                                         '%b %d %H:%M:%S %Y %Z')
            days_until_expiry = (not_after - datetime.now()).days
            
            if days_until_expiry < 30:
                send_alert(f"Certificate for {hostname} expires in {days_until_expiry} days")
            
            return days_until_expiry
```

**5. Мониторинг сертификатов:**

```python
import requests
from datetime import datetime

def monitor_certificates():
    hosts = ['example.com', 'api.example.com']
    
    for host in hosts:
        try:
            response = requests.get(f'https://{host}', verify=True, timeout=5)
            cert = response.connection.sock.getpeercert()
            
            # Проверка срока действия
            not_after = datetime.strptime(cert['notAfter'],
                                         '%b %d %H:%M:%S %Y %Z')
            days_left = (not_after - datetime.now()).days
            
            if days_left < 30:
                alert(f"Certificate for {host} expires in {days_left} days")
                
        except requests.exceptions.SSLError as e:
            alert(f"SSL error for {host}: {e}")
```

**6. Настройка автоматического обновления (Let's Encrypt):**

```bash
# Certbot для автоматического обновления
certbot --nginx -d example.com --non-interactive --agree-tos \
  --email admin@example.com

# Автоматическое обновление через cron
0 0 1 * * certbot renew --quiet --post-hook "systemctl reload nginx"
```

**7. Проверка цепочки в Kubernetes:**

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: tls-secret
type: kubernetes.io/tls
data:
  tls.crt: <base64 encoded cert chain>
  tls.key: <base64 encoded key>

---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: secure-ingress
spec:
  tls:
    - hosts:
        - example.com
      secretName: tls-secret
  rules:
    - host: example.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: web-service
                port:
                  number: 80
```

**Критерии правильной настройки:**
- Полная цепочка сертификатов представлена
- Корневой CA в trusted store
- Проверка отзыва сертификатов (OCSP/CRL)
- Мониторинг срока действия

---

### 181. Как настроить регистрацию событий доступа (access logging)?

**Ответ:** Настройка регистрации событий доступа (access logging):

**1. Nginx access logging:**

```nginx
http {
    # Формат логов
    log_format detailed '$remote_addr - $remote_user [$time_local] '
                       '"$request" $status $body_bytes_sent '
                       '"$http_referer" "$http_user_agent" '
                       '$request_time $upstream_response_time';
    
    # Логирование доступа
    access_log /var/log/nginx/access.log detailed;
    
    # Отдельное логирование для security событий
    map $status $log_security {
        ~^[45]  1;  # 4xx, 5xx - логируем как security events
        default 0;
    }
    
    access_log /var/log/nginx/security.log detailed if=$log_security;
}
```

**2. Apache access logging:**

```apache
# httpd.conf
LogFormat "%h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-Agent}i\" %D" combined

# Логирование доступа
CustomLog /var/log/apache2/access.log combined

# Логирование ошибок
ErrorLog /var/log/apache2/error.log
LogLevel warn
```

**3. Логирование в приложении (Python Flask):**

```python
import logging
from flask import Flask, request
from logging.handlers import RotatingFileHandler

app = Flask(__name__)

# Настройка логирования
handler = RotatingFileHandler(
    'access.log',
    maxBytes=10000000,
    backupCount=5
)
handler.setFormatter(logging.Formatter(
    '%(asctime)s %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]'
))
app.logger.addHandler(handler)
app.logger.setLevel(logging.INFO)

@app.before_request
def log_request():
    app.logger.info(
        f"{request.remote_addr} - {request.method} {request.path} - "
        f"User: {request.remote_user or 'anonymous'}"
    )

@app.after_request
def log_response(response):
    app.logger.info(
        f"Response: {response.status_code} - "
        f"Size: {response.content_length} bytes"
    )
    return response
```

**4. Централизованное логирование (syslog):**

```python
import logging
import logging.handlers

# Настройка syslog handler
syslog_handler = logging.handlers.SysLogHandler(address='/dev/log')
syslog_handler.setFormatter(logging.Formatter(
    '%(name)s: %(levelname)s %(message)s'
))

logger = logging.getLogger('app')
logger.addHandler(syslog_handler)
logger.setLevel(logging.INFO)
```

**5. Логирование в базу данных:**

```python
import logging
import sqlite3
from datetime import datetime

class DatabaseHandler(logging.Handler):
    def __init__(self, db_path):
        super().__init__()
        self.db_path = db_path
        self._init_db()
    
    def _init_db(self):
        conn = sqlite3.connect(self.db_path)
        conn.execute('''
            CREATE TABLE IF NOT EXISTS access_logs (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp TEXT,
                remote_addr TEXT,
                method TEXT,
                path TEXT,
                status_code INTEGER,
                user_agent TEXT
            )
        ''')
        conn.commit()
        conn.close()
    
    def emit(self, record):
        conn = sqlite3.connect(self.db_path)
        conn.execute('''
            INSERT INTO access_logs 
            (timestamp, remote_addr, method, path, status_code, user_agent)
            VALUES (?, ?, ?, ?, ?, ?)
        ''', (
            datetime.now().isoformat(),
            record.remote_addr,
            record.method,
            record.path,
            record.status_code,
            record.user_agent
        ))
        conn.commit()
        conn.close()
```

**6. Структурированное логирование (JSON):**

```python
import json
import logging

class JSONFormatter(logging.Formatter):
    def format(self, record):
        log_entry = {
            'timestamp': datetime.now().isoformat(),
            'level': record.levelname,
            'message': record.getMessage(),
            'module': record.module,
            'function': record.funcName,
            'line': record.lineno
        }
        return json.dumps(log_entry)

handler = logging.StreamHandler()
handler.setFormatter(JSONFormatter())
logger = logging.getLogger('app')
logger.addHandler(handler)
```

**7. Логирование безопасности:**

```python
class SecurityLogger:
    def log_authentication(self, username, success, ip_address):
        event = {
            'event_type': 'authentication',
            'username': username,
            'success': success,
            'ip_address': ip_address,
            'timestamp': datetime.now().isoformat()
        }
        self._log_security_event(event)
    
    def log_access_denied(self, resource, user, reason):
        event = {
            'event_type': 'access_denied',
            'resource': resource,
            'user': user,
            'reason': reason,
            'timestamp': datetime.now().isoformat()
        }
        self._log_security_event(event)
```

**8. Ротация логов:**

```bash
# logrotate configuration
/var/log/nginx/access.log {
    daily
    rotate 30
    compress
    delaycompress
    missingok
    notifempty
    create 0640 www-data adm
    sharedscripts
    postrotate
        systemctl reload nginx > /dev/null 2>&1 || true
    endscript
}
```

**Требования к логированию:**
- Все события доступа должны логироваться
- Логи должны быть защищены от изменения
- Хранение логов согласно требованиям (GDPR, ФЗ-152)
- Централизованный сбор логов
- Мониторинг и алерты

---

### 182. Как провести учения по реагированию на инциденты?

**Ответ:** Проведение учений по реагированию на инциденты (IR Drills):

**1. Планирование учений:**

```markdown
# План учений IR
## Цели:
- Проверка процедур реагирования
- Обучение команды
- Выявление недостатков

## Сценарии:
1. SQL Injection атака
2. Ransomware инцидент
3. DDoS атака
4. Утечка данных
5. Компрометация учётных записей
```

**2. Сценарий учений:**

```python
class IncidentDrill:
    def __init__(self, scenario):
        self.scenario = scenario
        self.timeline = []
        self.participants = []
    
    def simulate_incident(self):
        # Симуляция инцидента
        incident = self.create_fake_incident()
        
        # Уведомление команды
        self.notify_team(incident)
        
        # Отслеживание действий команды
        self.monitor_response()
        
        # Оценка эффективности
        self.evaluate_response()
    
    def create_fake_incident(self):
        return {
            'type': 'sql_injection',
            'severity': 'high',
            'detected_at': datetime.now(),
            'affected_systems': ['web-server-01'],
            'indicators': ['Suspicious SQL queries in logs']
        }
```

**3. Проведение учений:**

**Этапы:**
1. **Подготовка:** Информирование участников, подготовка сценария
2. **Симуляция:** Создание инцидента, уведомление команды
3. **Реагирование:** Команда выполняет процедуры IR
4. **Наблюдение:** Отслеживание действий и времени
5. **Анализ:** Разбор действий, выявление недостатков

**4. Оценка результатов:**

```python
class DrillEvaluation:
    def evaluate(self, drill):
        metrics = {
            'time_to_detect': self.calculate_detection_time(drill),
            'time_to_contain': self.calculate_containment_time(drill),
            'time_to_resolve': self.calculate_resolution_time(drill),
            'communication_quality': self.evaluate_communication(drill),
            'procedure_compliance': self.check_procedures(drill)
        }
        
        return {
            'score': self.calculate_score(metrics),
            'recommendations': self.generate_recommendations(metrics)
        }
```

**5. После учений:**

- **Разбор:** Обсуждение действий команды
- **Отчёт:** Документирование результатов
- **Улучшения:** Обновление процедур IR
- **Повтор:** Планирование следующих учений

**Рекомендации:**
- Регулярность: минимум раз в квартал
- Реалистичность сценариев
- Постепенное усложнение
- Включение всех членов IR команды

---

### 183. Как проверить соответствие системы базовым нормам безопасности?

**Ответ:** Проверка соответствия базовым нормам безопасности:

**1. Базовые проверки (CIS Benchmarks):**

```bash
#!/bin/bash
# security_audit.sh

# Проверка обновлений безопасности
echo "Checking for security updates..."
apt list --upgradable | grep -i security

# Проверка открытых портов
echo "Checking open ports..."
netstat -tuln | grep LISTEN

# Проверка настроек firewall
echo "Checking firewall rules..."
iptables -L -n -v

# Проверка парольной политики
echo "Checking password policy..."
grep -E "^PASS_MAX_DAYS|^PASS_MIN_DAYS|^PASS_MIN_LEN" /etc/login.defs

# Проверка неактивных учётных записей
echo "Checking inactive accounts..."
lastlog | grep "**Never logged in**"
```

**2. Автоматизированная проверка (Lynis):**

```bash
# Установка Lynis
apt-get install lynis

# Запуск аудита
lynis audit system

# Проверка конкретных категорий
lynis audit system --tests-category "authentication"
```

**3. Проверка соответствия стандартам:**

```python
import subprocess
import json

class SecurityComplianceCheck:
    def check_cis_benchmark(self):
        checks = {
            'password_policy': self.check_password_policy(),
            'user_permissions': self.check_user_permissions(),
            'network_config': self.check_network_config(),
            'logging': self.check_logging(),
            'encryption': self.check_encryption()
        }
        
        return {
            'compliant': all(checks.values()),
            'details': checks
        }
    
    def check_password_policy(self):
        # Проверка минимальной длины пароля
        result = subprocess.run(
            ['grep', 'PASS_MIN_LEN', '/etc/login.defs'],
            capture_output=True, text=True
        )
        min_len = int(result.stdout.split()[1])
        return min_len >= 12
```

**4. Использование OpenSCAP:**

```bash
# Сканирование с использованием SCAP
oscap xccdf eval --profile xccdf_org.ssgproject.content_profile_common \
  --results scan-results.xml \
  /usr/share/xml/scap/ssg/content/ssg-ubuntu2004-xccdf.xml

# Генерация отчёта
oscap xccdf generate report scan-results.xml > report.html
```

**5. Проверка конфигурации приложений:**

```python
def check_app_security_config():
    checks = {
        'https_enabled': check_https(),
        'security_headers': check_security_headers(),
        'authentication': check_authentication(),
        'authorization': check_authorization(),
        'input_validation': check_input_validation()
    }
    return checks

def check_https():
    response = requests.get('https://example.com', verify=True)
    return response.status_code == 200 and response.url.startswith('https')
```

**6. Генерация отчёта о соответствии:**

```python
def generate_compliance_report():
    report = {
        'timestamp': datetime.now().isoformat(),
        'system': get_system_info(),
        'checks': {
            'cis_benchmark': check_cis_benchmark(),
            'owasp_top10': check_owasp_compliance(),
            'pci_dss': check_pci_dss(),
            'gdpr': check_gdpr_compliance()
        },
        'recommendations': generate_recommendations()
    }
    
    return json.dumps(report, indent=2)
```

---

### 184. Как настроить автоматическое обновление системы безопасности?

**Ответ:** Настройка автоматического обновления системы безопасности:

**1. Ubuntu/Debian (unattended-upgrades):**

```bash
# Установка
apt-get install unattended-upgrades apt-listchanges

# Настройка
cat > /etc/apt/apt.conf.d/50unattended-upgrades <<EOF
Unattended-Upgrade::Allowed-Origins {
    "${distro_id}:${distro_codename}-security";
    "${distro_id}ESMApps:${distro_codename}-apps-security";
    "${distro_id}ESM:${distro_codename}-infra-security";
};
Unattended-Upgrade::AutoFixInterruptedDpkg "true";
Unattended-Upgrade::MinimalSteps "true";
Unattended-Upgrade::Remove-Unused-Kernel-Packages "true";
Unattended-Upgrade::Remove-Unused-Dependencies "true";
Unattended-Upgrade::Automatic-Reboot "false";
Unattended-Upgrade::Automatic-Reboot-Time "02:00";
EOF

# Включение автоматических обновлений
echo 'APT::Periodic::Update-Package-Lists "1";' > /etc/apt/apt.conf.d/20auto-upgrades
echo 'APT::Periodic::Unattended-Upgrade "1";' >> /etc/apt/apt.conf.d/20auto-upgrades
```

**2. Red Hat/CentOS (yum-cron):**

```bash
# Установка
yum install yum-cron

# Настройка
cat > /etc/yum/yum-cron.conf <<EOF
[commands]
update_cmd = security
download_updates = yes
apply_updates = yes
random_sleep = 360

[emitters]
emit_via = email

[email]
email_from = root@example.com
email_to = admin@example.com
email_host = smtp.example.com
EOF

# Включение службы
systemctl enable yum-cron
systemctl start yum-cron
```

**3. Автоматическое обновление через cron:**

```bash
#!/bin/bash
# auto_update.sh

# Обновление системы
apt-get update
apt-get upgrade -y --only-upgrade security

# Перезагрузка при необходимости
if [ -f /var/run/reboot-required ]; then
    echo "Reboot required" | mail -s "System reboot needed" admin@example.com
    # Автоматическая перезагрузка (опционально)
    # shutdown -r +30 "Reboot for security updates"
fi

# Cron job (ежедневно в 2:00)
# 0 2 * * * /usr/local/bin/auto_update.sh >> /var/log/auto_update.log 2>&1
```

**4. Автоматическое обновление в Kubernetes:**

```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: security-updater
spec:
  selector:
    matchLabels:
      name: security-updater
  template:
    metadata:
      labels:
        name: security-updater
    spec:
      containers:
      - name: updater
        image: alpine:latest
        command:
        - /bin/sh
        - -c
        - |
          apk update
          apk upgrade
        securityContext:
          privileged: true
      hostNetwork: true
      hostPID: true
```

**5. Мониторинг обновлений:**

```python
import subprocess
import smtplib
from email.mime.text import MIMEText

def check_security_updates():
    result = subprocess.run(
        ['apt-listchanges', '--print', '--upgrade-only'],
        capture_output=True,
        text=True
    )
    
    if result.returncode == 0 and result.stdout:
        send_notification("Security updates available", result.stdout)

def send_notification(subject, body):
    msg = MIMEText(body)
    msg['Subject'] = subject
    msg['From'] = 'updates@example.com'
    msg['To'] = 'admin@example.com'
    
    smtp = smtplib.SMTP('smtp.example.com')
    smtp.send_message(msg)
    smtp.quit()
```

**6. Тестирование обновлений:**

```bash
#!/bin/bash
# test_updates.sh

# Создание тестового окружения
vagrant up test-vm

# Применение обновлений на тестовой машине
vagrant ssh test-vm -c "sudo apt-get update && sudo apt-get upgrade -y"

# Запуск тестов
vagrant ssh test-vm -c "cd /app && npm test"

# Если тесты прошли, применяем на production
if [ $? -eq 0 ]; then
    echo "Updates tested successfully"
else
    echo "Tests failed, not applying updates"
fi
```

**Рекомендации:**
- Тестирование обновлений перед применением
- Автоматическая перезагрузка только при критических обновлениях
- Мониторинг и уведомления
- Резервное копирование перед обновлениями

---

### 185. Как провести обучение сотрудников по ИБ и зафиксировать его прохождение?

**Ответ:** Проведение обучения по информационной безопасности:

**1. Платформа обучения (LMS):**

```python
class SecurityTrainingPlatform:
    def __init__(self):
        self.courses = []
        self.employees = []
        self.completions = []
    
    def create_course(self, title, content, duration):
        course = {
            'id': generate_uuid(),
            'title': title,
            'content': content,
            'duration_minutes': duration,
            'created_at': datetime.now()
        }
        self.courses.append(course)
        return course
    
    def enroll_employee(self, employee_id, course_id):
        enrollment = {
            'employee_id': employee_id,
            'course_id': course_id,
            'enrolled_at': datetime.now(),
            'status': 'in_progress'
        }
        self.enrollments.append(enrollment)
    
    def complete_course(self, employee_id, course_id, score):
        completion = {
            'employee_id': employee_id,
            'course_id': course_id,
            'completed_at': datetime.now(),
            'score': score,
            'certificate_issued': True
        }
        self.completions.append(completion)
```

**2. Система уведомлений:**

```python
def send_training_reminder(employee):
    reminder = {
        'to': employee.email,
        'subject': 'Security Training Reminder',
        'body': f'''
        Dear {employee.name},
        
        You have pending security training courses:
        - Basic Security Awareness (Due: {due_date})
        - Phishing Awareness (Due: {due_date})
        
        Please complete them at: https://training.example.com
        '''
    }
    send_email(reminder)
```

**3. Отслеживание прогресса:**

```sql
CREATE TABLE training_completions (
    id SERIAL PRIMARY KEY,
    employee_id INTEGER,
    course_id INTEGER,
    completed_at TIMESTAMP,
    score DECIMAL(5,2),
    certificate_number VARCHAR(100),
    FOREIGN KEY (employee_id) REFERENCES employees(id),
    FOREIGN KEY (course_id) REFERENCES courses(id)
);

-- Отчёт по завершению обучения
SELECT 
    e.name,
    c.title,
    tc.completed_at,
    tc.score
FROM training_completions tc
JOIN employees e ON tc.employee_id = e.id
JOIN courses c ON tc.course_id = c.id
WHERE tc.completed_at >= NOW() - INTERVAL '1 year';
```

**4. Автоматическая сертификация:**

```python
def issue_certificate(employee_id, course_id):
    completion = get_completion(employee_id, course_id)
    
    if completion.score >= 80:  # Минимальный проходной балл
        certificate = {
            'employee_id': employee_id,
            'course_id': course_id,
            'certificate_number': generate_certificate_number(),
            'issued_at': datetime.now(),
            'expires_at': datetime.now() + timedelta(days=365)
        }
        
        save_certificate(certificate)
        send_certificate_email(employee_id, certificate)
        
        return certificate
    else:
        notify_retake_required(employee_id, course_id)
```

**5. Регулярные проверки знаний:**

```python
def schedule_annual_training():
    employees = get_all_employees()
    
    for employee in employees:
        # Проверка последнего обучения
        last_training = get_last_training_date(employee.id)
        
        if last_training < datetime.now() - timedelta(days=365):
            # Назначение обязательного обучения
            assign_mandatory_training(employee.id, 'annual_refresher')
            send_training_assignment(employee)
```

**6. Отчётность:**

```python
def generate_compliance_report():
    report = {
        'total_employees': count_employees(),
        'trained_this_year': count_trained_in_period(days=365),
        'compliance_rate': calculate_compliance_rate(),
        'overdue_trainings': get_overdue_trainings(),
        'upcoming_expirations': get_upcoming_expirations(days=30)
    }
    
    return report
```

**Требования:**
- Регулярность обучения (минимум раз в год)
- Фиксация прохождения в системе
- Выдача сертификатов
- Отслеживание сроков действия
- Обязательность для всех сотрудников

---

### 186. Как провести пентест (имитацию внешней атаки)?

**Ответ:** Проведение пентеста (penetration testing):

**1. Планирование:**

```markdown
# План пентеста
## Область тестирования:
- Веб-приложение: example.com
- API: api.example.com
- Инфраструктура: 10.0.0.0/24

## Методология:
- OWASP Testing Guide
- PTES (Penetration Testing Execution Standard)
- NIST SP 800-115

## Инструменты:
- Nmap (network scanning)
- Burp Suite (web application)
- Metasploit (exploitation)
```

**2. Разведка (Reconnaissance):**

```bash
# Пассивная разведка
# Whois lookup
whois example.com

# DNS enumeration
dig example.com ANY
nslookup example.com

# Активная разведка
# Port scanning
nmap -sS -O -p- target.example.com

# Service enumeration
nmap -sV -sC target.example.com

# Web application scanning
dirb http://example.com /usr/share/wordlists/dirb/common.txt
```

**3. Тестирование веб-приложения:**

```python
# Использование Burp Suite через API
import requests
from burp import IBurpExtender

class BurpScanner(IBurpExtender):
    def registerExtenderCallbacks(self, callbacks):
        self._callbacks = callbacks
        self._helpers = callbacks.getHelpers()
        callbacks.setExtensionName("Custom Scanner")
        
        # Сканирование на SQL Injection
        self.scan_for_sql_injection()
        
        # Сканирование на XSS
        self.scan_for_xss()
    
    def scan_for_sql_injection(self):
        payloads = [
            "' OR '1'='1",
            "1' UNION SELECT NULL--",
            "admin'--"
        ]
        
        for payload in payloads:
            # Отправка запросов с payloads
            self.send_test_request(payload)
```

**4. Эксплуатация уязвимостей:**

```python
# Пример эксплуатации SQL Injection
import requests

def exploit_sql_injection(url, parameter):
    payload = "1' UNION SELECT username, password FROM users--"
    
    response = requests.get(url, params={parameter: payload})
    
    if "error" not in response.text.lower():
        # Возможно успешная эксплуатация
        return parse_results(response.text)
    
    return None
```

**5. Отчёт о пентесте:**

```python
class PenetrationTestReport:
    def generate_report(self, findings):
        report = {
            'executive_summary': self.generate_executive_summary(findings),
            'methodology': self.get_methodology(),
            'findings': self.format_findings(findings),
            'risk_assessment': self.assess_risks(findings),
            'recommendations': self.generate_recommendations(findings)
        }
        
        return report
    
    def format_findings(self, findings):
        formatted = []
        for finding in findings:
            formatted.append({
                'title': finding.title,
                'severity': finding.severity,
                'cvss_score': finding.cvss_score,
                'description': finding.description,
                'evidence': finding.evidence,
                'recommendation': finding.recommendation
            })
        return formatted
```

**6. Инструменты для пентеста:**

- **Nmap** — сканирование сети
- **Burp Suite** — тестирование веб-приложений
- **Metasploit** — фреймворк эксплуатации
- **OWASP ZAP** — автоматизированное тестирование
- **Nessus** — сканирование уязвимостей

**Этические соображения:**
- Получение письменного разрешения
- Ограничение области тестирования
- Минимизация воздействия на production
- Конфиденциальность результатов

---

### 187. Как настроить и мониторить honeypot?

**Ответ:** Настройка и мониторинг **honeypot** (приманка для атак):

**1. Настройка простого honeypot (Cowrie):**

```bash
# Установка Cowrie (SSH/Telnet honeypot)
git clone https://github.com/cowrie/cowrie
cd cowrie
python3 -m venv cowrie-env
source cowrie-env/bin/activate
pip install -r requirements.txt

# Конфигурация
cp etc/cowrie.cfg.dist etc/cowrie.cfg
# Редактирование конфигурации
nano etc/cowrie.cfg

# Запуск
bin/cowrie start
```

**2. Настройка веб-приложения honeypot:**

```python
from flask import Flask, request, render_template_string
import logging

app = Flask(__name__)

# Логирование всех запросов
logging.basicConfig(filename='honeypot.log', level=logging.INFO)

@app.route('/', defaults={'path': ''})
@app.route('/<path:path>')
def catch_all(path):
    # Логирование подозрительных запросов
    log_suspicious_request(request)
    return render_template_string('<h1>404 Not Found</h1>')

def log_suspicious_request(request):
    suspicious_patterns = [
        'admin', 'phpmyadmin', 'wp-admin', 'sql',
        '../', '..\\', 'union select', '<script>'
    ]
    
    for pattern in suspicious_patterns:
        if pattern in request.path.lower() or pattern in str(request.args):
            logging.warning(
                f"Suspicious request from {request.remote_addr}: "
                f"{request.method} {request.path} - "
                f"User-Agent: {request.headers.get('User-Agent')}"
            )
            send_alert(f"Suspicious activity detected: {request.remote_addr}")
            break

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8080)
```

**3. Настройка network honeypot (Honeyd):**

```bash
# Установка Honeyd
apt-get install honeyd

# Конфигурация
cat > /etc/honeyd/honeyd.conf <<EOF
create template
set template personality "Linux 2.6.31"
set template default tcp action reset
set template default udp action reset

add template tcp port 22 "sh /usr/share/honeyd/scripts/linux.sh"
add template tcp port 80 "sh /usr/share/honeyd/scripts/web.sh"

bind 10.0.0.100 template
EOF

# Запуск
honeyd -d -f /etc/honeyd/honeyd.conf
```

**4. Мониторинг honeypot:**

```python
import json
from datetime import datetime
import smtplib

class HoneypotMonitor:
    def __init__(self, log_file):
        self.log_file = log_file
        self.alert_threshold = 5  # Количество событий для алерта
    
    def monitor_logs(self):
        with open(self.log_file, 'r') as f:
            # Чтение последних строк
            lines = f.readlines()[-100:]
            
            # Анализ событий
            for line in lines:
                event = json.loads(line)
                self.analyze_event(event)
    
    def analyze_event(self, event):
        # Подсчёт событий от одного IP
        ip = event.get('src_ip')
        count = self.count_events_from_ip(ip, minutes=5)
        
        if count > self.alert_threshold:
            self.send_alert(
                f"High activity from {ip}: {count} events in 5 minutes"
            )
    
    def send_alert(self, message):
        # Отправка алерта
        print(f"ALERT: {message}")
        # send_email('security@example.com', 'Honeypot Alert', message)
```

**5. Интеграция с SIEM:**

```python
def send_to_siem(event):
    siem_client.send_event({
        'event_type': 'honeypot_interaction',
        'source_ip': event['src_ip'],
        'destination_port': event['dst_port'],
        'timestamp': event['timestamp'],
        'severity': 'medium'
    })
```

**6. Дашборд мониторинга:**

```python
from flask import Flask, render_template, jsonify

app = Flask(__name__)

@app.route('/dashboard')
def dashboard():
    # Статистика по honeypot
    stats = {
        'total_events': count_total_events(),
        'unique_ips': count_unique_ips(),
        'top_attackers': get_top_attackers(limit=10),
        'recent_events': get_recent_events(limit=20)
    }
    return render_template('dashboard.html', stats=stats)

@app.route('/api/events')
def api_events():
    events = get_recent_events(limit=100)
    return jsonify(events)
```

**Рекомендации:**
- Изоляция honeypot от production сети
- Регулярный мониторинг логов
- Автоматические алерты при подозрительной активности
- Интеграция с SIEM для корреляции событий

---

### 188. Как настроить DLP-систему (предотвращение утечек данных)?

**Ответ:** Настройка **DLP (Data Loss Prevention)** системы:

**1. Классификация данных:**

```python
class DataClassifier:
    def classify_document(self, content):
        classifications = []
        
        # Поиск персональных данных
        if self.contains_pii(content):
            classifications.append('PII')
        
        # Поиск финансовых данных
        if self.contains_credit_card(content):
            classifications.append('FINANCIAL')
        
        # Поиск коммерческой тайны
        if self.contains_trade_secret(content):
            classifications.append('CONFIDENTIAL')
        
        return classifications
    
    def contains_pii(self, content):
        import re
        # Поиск email
        email_pattern = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'
        if re.search(email_pattern, content):
            return True
        
        # Поиск телефонных номеров
        phone_pattern = r'\b\d{3}[-.]?\d{3}[-.]?\d{4}\b'
        if re.search(phone_pattern, content):
            return True
        
        return False
```

**2. Мониторинг передачи данных:**

```python
class DLPMonitor:
    def monitor_email(self, email):
        # Проверка вложений
        for attachment in email.attachments:
            if self.contains_sensitive_data(attachment.content):
                self.block_email(email)
                self.alert_security_team(email)
    
    def monitor_file_transfer(self, file_path, destination):
        content = read_file(file_path)
        
        if self.contains_sensitive_data(content):
            # Блокировка передачи
            self.block_transfer(file_path, destination)
            self.log_violation(
                file_path=file_path,
                destination=destination,
                user=get_current_user()
            )
```

**3. Блокировка утечек:**

```python
class DLPEnforcer:
    def check_upload(self, file_content, user):
        classification = self.classifier.classify(file_content)
        
        if 'CONFIDENTIAL' in classification:
            if not self.has_permission(user, 'upload_confidential'):
                raise DLPViolation("Unauthorized upload of confidential data")
        
        return True
    
    def check_email(self, email_body, attachments, user):
        # Проверка содержимого
        if self.contains_sensitive_data(email_body):
            self.quarantine_email(email)
            return False
        
        # Проверка вложений
        for attachment in attachments:
            if self.contains_sensitive_data(attachment):
                self.quarantine_email(email)
                return False
        
        return True
```

**4. Маскирование данных:**

```python
def mask_sensitive_data(text):
    import re
    
    # Маскирование email
    text = re.sub(
        r'\b([A-Za-z0-9._%+-]+)@([A-Za-z0-9.-]+\.[A-Z|a-z]{2,})\b',
        r'***@\2',
        text
    )
    
    # Маскирование кредитных карт
    text = re.sub(
        r'\b\d{4}[- ]?\d{4}[- ]?\d{4}[- ]?(\d{4})\b',
        r'****-****-****-\1',
        text
    )
    
    return text
```

**5. Мониторинг принтеров и USB:**

```python
class DeviceMonitor:
    def monitor_usb_access(self, device_path, user):
        # Блокировка USB устройств для пользователей без прав
        if not self.has_permission(user, 'usb_access'):
            self.block_usb_device(device_path)
            self.alert_security_team(user, 'usb_blocked')
    
    def monitor_printing(self, document, user):
        # Логирование печати конфиденциальных документов
        if self.contains_sensitive_data(document):
            self.log_print_event(
                user=user,
                document=document,
                timestamp=datetime.now()
            )
```

**6. Интеграция с SIEM:**

```python
def send_dlp_event_to_siem(event):
    siem.send_event({
        'event_type': 'dlp_violation',
        'user': event['user'],
        'data_classification': event['classification'],
        'action': event['action'],  # blocked, logged, alerted
        'timestamp': event['timestamp']
    })
```

---

### 189. Как настроить SIEM для сбора и анализа журналов?

**Ответ:** Настройка **SIEM (Security Information and Event Management)**:

**1. Настройка сбора логов (ELK Stack):**

```yaml
# Filebeat configuration
filebeat.inputs:
- type: log
  enabled: true
  paths:
    - /var/log/apache2/access.log
    - /var/log/apache2/error.log
  fields:
    log_type: apache
    
- type: log
  enabled: true
  paths:
    - /var/log/auth.log
  fields:
    log_type: auth

output.elasticsearch:
  hosts: ["elasticsearch:9200"]
  index: "security-logs-%{+yyyy.MM.dd}"
```

**2. Правила корреляции (Splunk):**

```python
# Splunk SPL query
search index=security_logs
| eval risk_score=case(
    status>=400, 5,
    user_agent="*bot*", 3,
    status>=500, 8,
    1=1, 1
)
| where risk_score >= 5
| stats count by src_ip, risk_score
| sort -risk_score
```

**3. Настройка алертов:**

```python
class SIEMAlertRules:
    def check_brute_force(self, events):
        # Поиск множественных неудачных попыток входа
        failed_logins = [
            e for e in events 
            if e['event_type'] == 'auth_failed'
        ]
        
        # Группировка по IP
        ip_counts = {}
        for event in failed_logins:
            ip = event['src_ip']
            ip_counts[ip] = ip_counts.get(ip, 0) + 1
        
        # Алерт при превышении порога
        for ip, count in ip_counts.items():
            if count >= 5:
                self.trigger_alert(
                    f"Brute force attack from {ip}: {count} failed attempts"
                )
    
    def check_lateral_movement(self, events):
        # Обнаружение попыток горизонтального перемещения
        unique_ips = set(e['src_ip'] for e in events)
        
        if len(unique_ips) > 10:
            self.trigger_alert(
                f"Possible lateral movement: {len(unique_ips)} unique IPs"
            )
```

**4. Дашборд безопасности:**

```python
from flask import Flask, render_template, jsonify

app = Flask(__name__)

@app.route('/security-dashboard')
def security_dashboard():
    # Метрики безопасности
    metrics = {
        'total_events_24h': count_events(hours=24),
        'critical_alerts': count_critical_alerts(),
        'top_threats': get_top_threats(),
        'geographic_distribution': get_geo_distribution()
    }
    return render_template('dashboard.html', metrics=metrics)
```

**5. Интеграция источников данных:**

```python
class SIEMConnector:
    def connect_sources(self):
        sources = [
            {'type': 'syslog', 'host': '10.0.1.10', 'port': 514},
            {'type': 'snmp', 'host': '10.0.1.20', 'community': 'public'},
            {'type': 'api', 'url': 'https://api.example.com/logs'}
        ]
        
        for source in sources:
            self.add_source(source)
```

---

### 190. Как разработать и утвердить IR-план (план реагирования на инциденты)?

**Ответ:** Разработка **IR (Incident Response)** плана:

**1. Структура IR-плана:**

```markdown
# IR Plan

## 1. Команда реагирования
- Incident Response Manager
- Security Analysts
- System Administrators
- Legal Counsel
- Communications

## 2. Классификация инцидентов
- Critical: Полная компрометация системы
- High: Частичная компрометация
- Medium: Подозрительная активность
- Low: Минорные события

## 3. Процедуры реагирования
### 3.1 Обнаружение
### 3.2 Анализ
### 3.3 Сдерживание
### 3.4 Устранение
### 3.5 Восстановление
### 3.6 Пост-инцидентный анализ

## 4. Контакты
- IR Team Lead: +7-XXX-XXX-XXXX
- External Security Firm: +7-YYY-YYY-YYYY
- Law Enforcement: 102
```

**2. Автоматизация реагирования:**

```python
class IncidentResponseAutomation:
    def handle_incident(self, incident):
        # Классификация
        severity = self.classify_incident(incident)
        
        # Автоматические действия
        if severity == 'critical':
            self.isolate_affected_systems(incident)
            self.notify_ir_team(incident)
            self.escalate_to_management(incident)
        
        # Создание задачи
        self.create_incident_ticket(incident)
```

**3. Процедуры сдерживания:**

```python
def contain_incident(incident):
    actions = []
    
    if incident['type'] == 'malware':
        # Изоляция заражённой системы
        actions.append(isolate_system(incident['affected_host']))
        actions.append(block_network_access(incident['affected_host']))
    
    elif incident['type'] == 'unauthorized_access':
        # Блокировка учётной записи
        actions.append(disable_account(incident['username']))
        actions.append(invalidate_sessions(incident['username']))
    
    return actions
```

**4. Утверждение плана:**

- **Review:** Проверка плана командой безопасности
- **Approval:** Утверждение руководством
- **Distribution:** Распространение среди заинтересованных сторон
- **Training:** Обучение команды IR
- **Testing:** Регулярные учения

---

### 191. Как протестировать DR-план (план восстановления после аварии)?

**Ответ:** Тестирование **DR (Disaster Recovery)** плана:

**1. Типы тестирования:**

```python
class DRPlanTesting:
    def tabletop_exercise(self):
        # Настольное учение
        scenario = self.generate_scenario()
        participants = self.get_dr_team()
        
        # Симуляция сценария
        for step in scenario.steps:
            response = participants.discuss(step)
            self.evaluate_response(response)
    
    def walkthrough_test(self):
        # Пошаговая проверка процедур
        for procedure in self.dr_plan.procedures:
            result = self.execute_procedure(procedure, test_mode=True)
            self.validate_result(result)
    
    def simulation_test(self):
        # Симуляция частичной аварии
        self.simulate_failure('database')
        self.measure_recovery_time()
        self.validate_data_integrity()
    
    def full_interruption_test(self):
        # Полное тестирование восстановления
        self.shutdown_production()
        self.execute_full_recovery()
        self.validate_all_systems()
```

**2. Метрики тестирования:**

```python
class DRMetrics:
    def calculate_rto(self, test_results):
        # Recovery Time Objective
        recovery_start = test_results['recovery_start_time']
        recovery_end = test_results['recovery_end_time']
        rto = (recovery_end - recovery_start).total_seconds()
        return rto
    
    def calculate_rpo(self, test_results):
        # Recovery Point Objective
        last_backup = test_results['last_backup_time']
        failure_time = test_results['failure_time']
        rpo = (failure_time - last_backup).total_seconds()
        return rpo
```

**3. Отчёт о тестировании:**

```python
def generate_dr_test_report(test_results):
    report = {
        'test_date': test_results['date'],
        'test_type': test_results['type'],
        'scenario': test_results['scenario'],
        'metrics': {
            'rto': calculate_rto(test_results),
            'rpo': calculate_rpo(test_results),
            'data_loss': test_results['data_loss']
        },
        'issues_found': test_results['issues'],
        'recommendations': generate_recommendations(test_results)
    }
    return report
```

---

### 192. Как проверить соответствие требованиям GDPR, PCI DSS, ФЗ-152?

**Ответ:** Проверка соответствия требованиям:

**1. GDPR Compliance:**

```python
class GDPRCompliance:
    def check_compliance(self):
        checks = {
            'data_mapping': self.map_personal_data(),
            'consent_management': self.check_consent_system(),
            'data_minimization': self.check_data_minimization(),
            'right_to_access': self.check_access_procedures(),
            'right_to_deletion': self.check_deletion_procedures(),
            'data_breach_notification': self.check_breach_procedures(),
            'encryption': self.check_encryption(),
            'access_controls': self.check_access_controls()
        }
        return checks
    
    def check_consent_system(self):
        # Проверка системы управления согласием
        return has_consent_tracking() and has_consent_withdrawal()
    
    def check_right_to_deletion(self):
        # Проверка процедур удаления данных
        return has_data_deletion_procedure() and can_delete_all_user_data()
```

**2. PCI DSS Compliance:**

```python
class PCIDSSCompliance:
    def check_requirements(self):
        requirements = {
            'firewall_config': self.check_firewall(),
            'password_policy': self.check_password_policy(),
            'card_data_protection': self.check_card_data_protection(),
            'encryption': self.check_encryption(),
            'vulnerability_management': self.check_vuln_management(),
            'access_control': self.check_access_control(),
            'monitoring': self.check_monitoring(),
            'testing': self.check_security_testing()
        }
        return requirements
    
    def check_card_data_protection(self):
        # Проверка защиты данных карт
        return (
            no_card_data_stored() or
            (card_data_encrypted() and access_logged())
        )
```

**3. ФЗ-152 Compliance:**

```python
class FZ152Compliance:
    def check_compliance(self):
        checks = {
            'consent_processing': self.check_consent(),
            'data_localization': self.check_localization(),
            'data_protection': self.check_protection(),
            'notification_authority': self.check_notification(),
            'access_rights': self.check_access_rights()
        }
        return checks
    
    def check_localization(self):
        # Проверка локализации данных граждан РФ
        return personal_data_stored_in_russia()
```

**4. Автоматизированная проверка:**

```bash
#!/bin/bash
# compliance_check.sh

echo "=== GDPR Compliance Check ==="
check_gdpr_requirements

echo "=== PCI DSS Compliance Check ==="
check_pci_dss_requirements

echo "=== ФЗ-152 Compliance Check ==="
check_fz152_requirements

# Генерация отчёта
generate_compliance_report > compliance_report.json
```

---

### 193. Как настроить маскировку данных (data masking)?

**Ответ:** Настройка маскировки данных:

**1. Маскирование в базе данных:**

```sql
-- PostgreSQL: Функция маскирования
CREATE OR REPLACE FUNCTION mask_email(email TEXT)
RETURNS TEXT AS $$
BEGIN
    RETURN regexp_replace(
        email,
        '^(.{1,3}).*(@.+)$',
        '\1***\2',
        'g'
    );
END;
$$ LANGUAGE plpgsql;

-- Использование
SELECT mask_email('john.doe@example.com');  -- joh***@example.com
```

**2. Маскирование в приложении:**

```python
import re
from cryptography.fernet import Fernet

class DataMasking:
    def __init__(self):
        self.key = Fernet.generate_key()
        self.cipher = Fernet(self.key)
    
    def mask_email(self, email):
        parts = email.split('@')
        if len(parts) == 2:
            username = parts[0]
            domain = parts[1]
            masked_username = username[:2] + '***' + username[-1] if len(username) > 3 else '***'
            return f"{masked_username}@{domain}"
        return email
    
    def mask_phone(self, phone):
        # +7 (XXX) XXX-XX-XX -> +7 (***) ***-**-XX
        return re.sub(r'(\+?\d{1,3}\s*\(?)(\d{1,3})(\)?\s*)(\d{1,3})(-?)(\d{1,2})(-?)(\d{1,2})',
                     r'\1***\3***\5**\7**',
                     phone)
    
    def mask_credit_card(self, card_number):
        # 1234 5678 9012 3456 -> **** **** **** 3456
        return re.sub(r'(\d{4}\s?){3}(\d{4})', r'**** **** **** \2', card_number)
    
    def mask_ssn(self, ssn):
        # XXX-XX-XXXX -> ***-**-XXXX
        return re.sub(r'(\d{3})-(\d{2})-(\d{4})', r'***-**-\3', ssn)
```

**3. Маскирование для логов:**

```python
class SecureLogger:
    SENSITIVE_PATTERNS = [
        (r'password["\']?\s*[:=]\s*["\']?([^"\'\s]+)', r'password="***"'),
        (r'api_key["\']?\s*[:=]\s*["\']?([^"\'\s]+)', r'api_key="***"'),
        (r'\b\d{4}[- ]?\d{4}[- ]?\d{4}[- ]?(\d{4})\b', r'****-****-****-\1'),
    ]
    
    def mask_log(self, message):
        masked = str(message)
        for pattern, replacement in self.SENSITIVE_PATTERNS:
            masked = re.sub(pattern, replacement, masked, flags=re.IGNORECASE)
        return masked
```

**4. Маскирование при экспорте:**

```python
def export_data_with_masking(data, user_role):
    masked_data = []
    
    for record in data:
        masked_record = record.copy()
        
        # Маскирование в зависимости от роли
        if user_role != 'admin':
            if 'email' in masked_record:
                masked_record['email'] = mask_email(masked_record['email'])
            if 'phone' in masked_record:
                masked_record['phone'] = mask_phone(masked_record['phone'])
        
        masked_data.append(masked_record)
    
    return masked_data
```

---

### 194. Какие механизмы обеспечивают защиту от атак Man-in-the-Middle?

**Ответ:** Механизмы защиты от **MitM (Man-in-the-Middle)** атак:

**1. TLS/SSL (HTTPS):**
- Шифрование трафика
- Проверка сертификатов сервера
- Валидация цепочки сертификатов

**2. Certificate Pinning:**
```python
import ssl
import socket
import hashlib

def verify_certificate_pin(hostname, port, expected_pin):
    context = ssl.create_default_context()
    
    with socket.create_connection((hostname, port)) as sock:
        with context.wrap_socket(sock, server_hostname=hostname) as ssock:
            cert = ssock.getpeercert(True)  # Получение DER-encoded сертификата
            cert_hash = hashlib.sha256(cert).hexdigest()
            
            if cert_hash != expected_pin:
                raise ssl.CertificateError("Certificate pin mismatch!")
```

**3. HSTS (HTTP Strict Transport Security):**
```nginx
# Nginx
add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;
```

**4. Certificate Transparency:**
- Мониторинг выданных сертификатов
- Обнаружение поддельных сертификатов

**5. DNSSEC:**
- Защита DNS запросов от подмены
- Проверка подписи DNS ответов

**6. Mutual TLS (mTLS):**
```nginx
# Требование клиентских сертификатов
ssl_verify_client on;
ssl_client_certificate /etc/ssl/certs/client-ca.crt;
```

---

### 195. Какие средства защиты применяются при физической краже устройств?

**Ответ:** Средства защиты при физической краже устройств:

**1. Шифрование дисков:**
- **BitLocker** (Windows)
- **FileVault** (macOS)
- **LUKS** (Linux)

**2. Удалённое стирание:**
```python
class RemoteWipe:
    def initiate_wipe(self, device_id):
        # Отправка команды на устройство
        send_command(device_id, 'wipe_device')
        
        # Проверка выполнения
        status = check_wipe_status(device_id)
        return status
```

**3. Геолокация:**
- Отслеживание местоположения устройства
- Удалённая блокировка

**4. Аутентификация:**
- Сильные пароли
- Биометрическая аутентификация
- Двухфакторная аутентификация

**5. Политики безопасности:**
- Автоблокировка при неактивности
- Ограничение количества попыток входа
- Удалённая блокировка после кражи

---

### 196. Какие меры защиты данных применяются в облачной инфраструктуре?

**Ответ:** Меры защиты данных в облачной инфраструктуре:

**1. Шифрование:**
- Шифрование данных в покое (encryption at rest)
- Шифрование данных при передаче (encryption in transit)
- Управление ключами (KMS)

**2. Identity and Access Management:**
- IAM политики
- Принцип наименьших привилегий
- Многофакторная аутентификация

**3. Network Security:**
- Security Groups
- Network ACLs
- VPC изоляция
- Private endpoints

**4. Мониторинг:**
- CloudTrail (AWS) / Activity Log (Azure)
- CloudWatch / Monitor
- SIEM интеграция

**5. Compliance:**
- SOC 2, ISO 27001 сертификация провайдера
- Shared Responsibility Model
- Регулярные аудиты

---

### 197. Какие практики используются для сегментации сети?

**Ответ:** Практики сегментации сети:

**1. VLAN сегментация:**
```bash
# Настройка VLAN
vlan 100
 name management
vlan 200
 name servers
vlan 300
 name clients
```

**2. Firewall правила:**
```bash
# Разрешение только необходимого трафика
iptables -A FORWARD -s 192.168.1.0/24 -d 10.0.1.0/24 -p tcp --dport 3306 -j ACCEPT
iptables -A FORWARD -s 192.168.1.0/24 -d 10.0.1.0/24 -j DROP
```

**3. Micro-segmentation:**
- Изоляция на уровне хоста
- Zero-trust архитектура
- Политики на основе идентичности

**4. Software-Defined Networking (SDN):**
- Централизованное управление
- Динамические политики
- Автоматизация

---

### 198. Как обеспечить безопасность при развёртывании в Kubernetes?

**Ответ:** Безопасность в Kubernetes:

**1. Pod Security Policies:**
```yaml
apiVersion: policy/v1beta1
kind: PodSecurityPolicy
metadata:
  name: restricted
spec:
  privileged: false
  allowPrivilegeEscalation: false
  requiredDropCapabilities:
    - ALL
  volumes:
    - 'configMap'
    - 'emptyDir'
  hostNetwork: false
  hostIPC: false
  hostPID: false
  runAsUser:
    rule: 'MustRunAsNonRoot'
  seLinux:
    rule: 'RunAsAny'
```

**2. Network Policies:**
```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: deny-all
spec:
  podSelector: {}
  policyTypes:
  - Ingress
  - Egress
```

**3. RBAC:**
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: pod-reader
rules:
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "watch", "list"]
```

**4. Secrets Management:**
```yaml
apiVersion: v1
kind: Secret
metadata:
  name: my-secret
type: Opaque
data:
  password: <base64-encoded>
```

**5. Image Security:**
- Сканирование образов на уязвимости
- Использование минимальных базовых образов
- Запрет root пользователя

---

### 199. Какие средства защиты применяются в микросервисных архитектурах?

**Ответ:** Средства защиты в микросервисах:

**1. Service Mesh (Istio):**
- mTLS между сервисами
- Авторизация на уровне сервисов
- Мониторинг и трассировка

**2. API Gateway:**
- Единая точка аутентификации
- Rate limiting
- WAF функциональность

**3. Secrets Management:**
- Vault
- Kubernetes Secrets
- Cloud KMS

**4. Network Policies:**
- Изоляция между сервисами
- Микро-сегментация

**5. Service-to-Service Authentication:**
- mTLS
- JWT токены
- Service accounts

---

### 200. Какие методы используются для защиты от атак типа DDoS?

**Ответ:** Методы защиты от **DDoS (Distributed Denial of Service)**:

**1. Rate Limiting:**
```python
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address

app = Flask(__name__)
limiter = Limiter(
    app,
    key_func=get_remote_address,
    default_limits=["100 per hour"]
)

@app.route('/api/data')
@limiter.limit("10 per minute")
def get_data():
    return {"data": "..."}
```

**2. CDN и Load Balancing:**
- Распределение нагрузки
- Географическое распределение
- Кэширование

**3. DDoS Protection Services:**
- Cloudflare
- AWS Shield
- Azure DDoS Protection

**4. Firewall правила:**
```bash
# Ограничение соединений
iptables -A INPUT -p tcp --dport 80 -m connlimit --connlimit-above 10 -j DROP

# Rate limiting
iptables -A INPUT -p tcp --dport 80 -m limit --limit 25/minute --limit-burst 100 -j ACCEPT
```

**5. Мониторинг и обнаружение:**
- Анализ трафика в реальном времени
- Аномалийное обнаружение
- Автоматическое реагирование

---

## Источники:
- Best practices в области операционной безопасности
- NIST Guidelines
- CIS Benchmarks
- OWASP Security Guidelines
- Опыт настройки инфраструктуры безопасности


