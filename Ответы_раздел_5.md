# Ответы на вопросы к зачёту
## Раздел 5: Архитектурные паттерны и практики безопасного проектирования

### 101. Что такое паттерн «Привратник (Gateway)» и зачем он нужен?

**Ответ:** Паттерн **"Gateway" (Привратник)** — это единая точка входа, которая служит посредником между клиентами и внутренними микросервисами или системами, централизованно обрабатывая запросы и обеспечивая общие функции.

**Основные функции Gateway:**

1. **Маршрутизация запросов** — направление запросов к соответствующим микросервисам
2. **Аутентификация и авторизация** — централизованная проверка прав доступа
3. **Rate limiting** — ограничение количества запросов от клиентов
4. **Балансировка нагрузки** — распределение нагрузки между экземплярами сервисов
5. **Мониторинг и логирование** — централизованный сбор метрик и логов
6. **Преобразование протоколов** — преобразование между HTTP/REST, gRPC, WebSocket и др.
7. **Кэширование** — кэширование ответов для улучшения производительности
8. **SSL/TLS терминация** — обработка шифрования на уровне Gateway
9. **Валидация запросов** — проверка формата и содержимого запросов
10. **Защита от атак** — WAF, DDoS-защита, фильтрация вредоносных запросов

**Пример архитектуры:**

```
Клиенты → API Gateway → [Микросервис 1, Микросервис 2, Микросервис 3]
```

**Зачем нужен:**
- **Централизация безопасности** — единая точка для применения политик безопасности
- **Упрощение клиентского доступа** — клиенты обращаются к одному endpoint
- **Изоляция микросервисов** — внутренние сервисы не доступны напрямую извне
- **Снижение сложности** — общие функции реализуются один раз в Gateway
- **Улучшение производительности** — кэширование и оптимизация запросов

---

### 102. В чём преимущество использования Gateway перед прямым доступом к микросервисам?

**Ответ:** Преимущества использования Gateway перед прямым доступом к микросервисам:

**1. Безопасность:**
- **Единая точка аутентификации** — проверка прав один раз в Gateway, а не в каждом сервисе
- **Изоляция внутренних сервисов** — микросервисы недоступны извне, только через Gateway
- **Централизованная защита** — WAF, rate limiting, валидация в одном месте
- **Упрощение управления ключами** — клиенты общаются только с Gateway

**2. Управляемость:**
- **Централизованное логирование** — все запросы логируются в одном месте
- **Мониторинг** — единая точка для сбора метрик
- **Упрощение обновлений** — изменения в политиках применяются один раз
- **Версионирование API** — управление версиями API в Gateway

**3. Производительность:**
- **Кэширование** — Gateway может кэшировать ответы от нескольких сервисов
- **Агрегация запросов** — объединение нескольких запросов в один
- **Оптимизация протоколов** — преобразование между разными протоколами

**4. Масштабируемость:**
- **Балансировка нагрузки** — Gateway распределяет нагрузку между экземплярами
- **Динамическая маршрутизация** — автоматическое обнаружение и маршрутизация к сервисам
- **Градуальное развёртывание** — Gateway может направлять трафик на разные версии сервисов

**5. Упрощение клиентского кода:**
- **Единый endpoint** — клиенты обращаются к одному адресу вместо множества
- **Упрощение аутентификации** — один токен для всех сервисов
- **Стандартизация API** — единый формат ответов

**6. Снижение связанности:**
- **Слабая связанность** — клиенты не зависят от внутренней структуры сервисов
- **Независимое развёртывание** — изменения в сервисах не затрагивают клиентов
- **Абстракция** — Gateway скрывает сложность внутренней архитектуры

**Пример:**

**Без Gateway:**
```
Клиент → Микросервис A (аутентификация)
Клиент → Микросервис B (аутентификация)
Клиент → Микросервис C (аутентификация)
```

**С Gateway:**
```
Клиент → Gateway (аутентификация) → Микросервис A
                                    → Микросервис B
                                    → Микросервис C
```

---

### 103. Что такое паттерн «Федеративное удостоверение»?

**Ответ:** Паттерн **"Федеративное удостоверение (Federated Identity)"** — это подход к управлению аутентификацией и авторизацией, при котором пользователи могут использовать свои учётные данные из одного домена (провайдера удостоверений, IdP) для доступа к приложениям в других доменах (провайдерам услуг, SP).

**Основные компоненты:**

1. **Identity Provider (IdP)** — провайдер удостоверений, который аутентифицирует пользователей (Google, Microsoft Azure AD, Okta, корпоративный Active Directory)

2. **Service Provider (SP)** — приложение или сервис, который предоставляет услуги после аутентификации через IdP

3. **Протоколы федерации:**
   - **SAML 2.0** — для корпоративных приложений
   - **OAuth 2.0 / OpenID Connect** — для веб и мобильных приложений
   - **WS-Federation** — для веб-сервисов Microsoft

**Преимущества:**

1. **Single Sign-On (SSO)** — пользователь входит один раз и получает доступ ко всем приложениям
2. **Централизованное управление** — управление пользователями в одном месте
3. **Упрощение для пользователей** — не нужно запоминать множество паролей
4. **Повышенная безопасность** — специализированные IdP лучше защищают учётные данные
5. **Снижение административных затрат** — не нужно управлять учётными записями в каждом приложении

**Архитектура:**

```
Пользователь → Приложение (SP) → Редирект на IdP → Аутентификация → 
IdP → Выдача токена/assertion → Приложение → Проверка токена → Доступ предоставлен
```

**Пример использования:**

```python
# Приложение (SP) перенаправляет на IdP
@app.route('/login')
def login():
    # Редирект на провайдера удостоверений
    saml_request = create_saml_authn_request()
    return redirect(f"{IDP_URL}?SAMLRequest={saml_request}")

# IdP аутентифицирует пользователя и возвращает assertion
@app.route('/sso/callback')
def callback():
    saml_response = request.form.get('SAMLResponse')
    assertion = verify_saml_response(saml_response)
    
    # Создание сессии на основе assertion
    session['user'] = assertion.attributes
    return redirect('/dashboard')
```

**Сценарии использования:**
- Корпоративные приложения с единым входом
- Партнёрские порталы
- Облачные приложения SaaS
- Мобильные приложения с социальным входом

---

### 104. Почему не рекомендуется реализовывать собственную систему хранения паролей?

**Ответ:** Не рекомендуется реализовывать собственную систему хранения паролей по следующим причинам:

**1. Сложность правильной реализации:**
- **Хеширование паролей** — необходимо использовать криптографически стойкие алгоритмы (bcrypt, Argon2, scrypt), а не MD5 или SHA-1
- **Salt** — необходимо генерировать уникальную соль для каждого пароля
- **Итерации** — правильный выбор количества итераций для замедления брутфорса
- **Защита от timing attacks** — постоянное время выполнения для предотвращения утечки информации

**2. Высокий риск ошибок:**
- **Уязвимости** — легко допустить ошибки, которые приведут к компрометации всех паролей
- **Накопление технического долга** — сложно обновлять систему при появлении новых уязвимостей
- **Отсутствие экспертизы** — большинство разработчиков не являются экспертами по криптографии

**3. Правовые и нормативные требования:**
- **GDPR, ФЗ-152** — требования к защите персональных данных
- **Стандарты** — необходимо соответствие стандартам безопасности (ISO 27001, PCI DSS)
- **Аудит** — необходимость прохождения аудитов безопасности

**4. Дополнительные функции безопасности:**
- **Защита от брутфорса** — rate limiting, блокировка после неудачных попыток
- **Проверка на утечки** — интеграция с сервисами проверки (Have I Been Pwned)
- **Политики паролей** — сложность, длина, требования к символам
- **Двухфакторная аутентификация (2FA)** — поддержка TOTP, SMS, аппаратных ключей
- **Восстановление пароля** — безопасный процесс сброса пароля

**5. Затраты на поддержку:**
- **Обновления** — необходимость обновления при обнаружении уязвимостей
- **Мониторинг** — отслеживание попыток взлома и аномальной активности
- **Обучение** — обучение команды современным практикам безопасности

**Рекомендуемые альтернативы:**

1. **Использование готовых решений:**
   - **Auth0** — облачный сервис аутентификации
   - **AWS Cognito** — сервис управления пользователями
   - **Azure AD B2C** — решение Microsoft
   - **Keycloak** — open-source решение
   - **Okta** — корпоративное решение

2. **Использование проверенных библиотек:**
   - **Passport.js** (Node.js) — с поддержкой различных стратегий
   - **Django Auth** (Python) — встроенная система Django
   - **Spring Security** (Java) — фреймворк безопасности Spring
   - **ASP.NET Identity** (.NET) — решение Microsoft

3. **Использование федеративной аутентификации:**
   - OAuth 2.0 / OpenID Connect
   - SAML 2.0
   - Позволяет делегировать хранение паролей проверенным провайдерам

**Если всё же необходимо хранить пароли:**

```python
# Использование проверенной библиотеки
import bcrypt

# Хеширование пароля
def hash_password(password: str) -> str:
    salt = bcrypt.gensalt(rounds=12)  # Достаточное количество раундов
    hashed = bcrypt.hashpw(password.encode('utf-8'), salt)
    return hashed.decode('utf-8')

# Проверка пароля
def verify_password(password: str, hashed: str) -> bool:
    return bcrypt.checkpw(
        password.encode('utf-8'),
        hashed.encode('utf-8')
    )
```

**Рекомендация:** Используйте готовые проверенные решения вместо собственной реализации, если только у вас нет команды криптографов и экспертов по безопасности.

---

### 105. Что такое паттерн «Ключ валета (Valet Key)»?

**Ответ:** Паттерн **"Valet Key" (Ключ валета)** — это паттерн безопасности, при котором предоставляется временный, ограниченный токен доступа (Shared Access Signature, SAS) к конкретному ресурсу вместо постоянных полных учётных данных.

**Концепция:**
Аналогия с реальным ключом валета: вместо того чтобы дать кому-то полный доступ к вашему дому (постоянный ключ), вы даёте временный ключ только для входа в гараж на определённое время.

**Характеристики Valet Key:**

1. **Временный доступ** — токен действителен только в течение ограниченного периода
2. **Ограниченные права** — только необходимые операции (чтение, запись, удаление)
3. **Ограничение ресурсов** — доступ только к конкретному объекту или контейнеру
4. **Нельзя отозвать** — после выдачи токен нельзя отозвать до истечения срока
5. **Прямой доступ** — клиент обращается напрямую к ресурсу, минуя сервер

**Пример использования в облачных хранилищах:**

```python
from datetime import datetime, timedelta
import boto3

# Генерация временного токена для доступа к объекту S3
def generate_valet_key(bucket, object_key, user_id):
    s3_client = boto3.client('s3')
    
    # Генерация предварительно подписанного URL (Presigned URL)
    url = s3_client.generate_presigned_url(
        'get_object',
        Params={
            'Bucket': bucket,
            'Key': object_key
        },
        ExpiresIn=3600  # 1 час
    )
    
    return {
        'url': url,
        'expires_at': (datetime.utcnow() + timedelta(hours=1)).isoformat(),
        'bucket': bucket,
        'object_key': object_key
    }
```

**Преимущества:**

1. **Безопасность** — при компрометации токена ущерб ограничен (только один объект на ограниченное время)
2. **Производительность** — клиент загружает файлы напрямую в облако, не нагружая сервер
3. **Масштабируемость** — снижение нагрузки на сервер приложений
4. **Гибкость** — разные токены с разными правами для разных пользователей

**Использование:**

```python
# Пользователь запрашивает возможность загрузить файл
@app.route('/upload/request')
def request_upload():
    user_id = current_user.id
    file_name = request.json['filename']
    
    # Генерация valet key для загрузки
    valet_key = generate_valet_key(
        bucket='user-uploads',
        object_key=f'{user_id}/{file_name}',
        user_id=user_id
    )
    
    # Возвращаем токен клиенту
    return jsonify({
        'upload_url': valet_key['url'],
        'expires_in': 3600
    })

# Клиент использует URL для прямой загрузки в S3
# fetch(valet_key.url, { method: 'PUT', body: file })
```

**Сравнение с постоянным ключом:**

**Постоянный ключ:**
- Действует бессрочно
- Полный доступ ко всем ресурсам
- При компрометации — полный доступ злоумышленника
- Необходимо хранить на сервере

**Valet Key (SAS токен):**
- Временный (минуты/часы)
- Ограниченный доступ к конкретному ресурсу
- При компрометации — минимальный ущерб
- Генерируется по требованию

---

### 106. В чём отличие постоянного ключа от временного SAS-токена?

**Ответ:** Отличия постоянного ключа от временного SAS-токена (Shared Access Signature):

**Постоянный ключ (Permanent Key):**

1. **Срок действия:**
   - Действует бессрочно или до явной отмены
   - Требует ручного управления жизненным циклом

2. **Область доступа:**
   - Полный доступ ко всем ресурсам в учётной записи/сервисе
   - Доступ ко всем операциям (чтение, запись, удаление, управление)

3. **Безопасность:**
   - При компрометации — полный доступ злоумышленника ко всем ресурсам
   - Высокий риск утечки
   - Сложность отзыва при компрометации

4. **Хранение:**
   - Должен храниться на сервере в безопасном месте
   - Нельзя передавать клиентам
   - Требует управления секретами (Vault, Secrets Manager)

5. **Использование:**
   - Используется сервером для операций от имени пользователей
   - Все запросы идут через сервер приложений

6. **Пример:**
   ```python
   # Постоянный ключ AWS
   AWS_ACCESS_KEY_ID = "AKIAIOSFODNN7EXAMPLE"
   AWS_SECRET_ACCESS_KEY = "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY"
   # Действует до явной отмены
   ```

**Временный SAS-токен (Temporary SAS Token):**

1. **Срок действия:**
   - Временный (обычно минуты, часы, максимум несколько дней)
   - Автоматически истекает через заданное время
   - Не требует ручного управления

2. **Область доступа:**
   - Ограниченный доступ к конкретному ресурсу (объект, контейнер)
   - Только разрешённые операции (например, только чтение или только запись)
   - Можно ограничить по IP-адресу, протоколу (HTTPS)

3. **Безопасность:**
   - При компрометации — минимальный ущерб (только один ресурс на короткое время)
   - Низкий риск утечки (токен действителен ограниченное время)
   - Автоматическая отмена через истечение срока

4. **Хранение:**
   - Генерируется по требованию
   - Можно передавать клиентам (в URL)
   - Не требуется долгосрочное хранение

5. **Использование:**
   - Используется клиентами для прямого доступа к ресурсам
   - Запросы идут напрямую к хранилищу, минуя сервер приложений

6. **Пример:**
   ```python
   # Временный SAS токен Azure Blob Storage
   sas_token = generate_blob_sas(
       account_name='storage',
       container_name='uploads',
       blob_name='file.pdf',
       permission=BlobSasPermissions(read=True),
       expiry=datetime.utcnow() + timedelta(hours=1)  # Истекает через 1 час
   )
   
   url = f"https://storage.blob.core.windows.net/uploads/file.pdf?{sas_token}"
   # Действует только 1 час
   ```

**Сравнительная таблица:**

| Характеристика | Постоянный ключ | SAS-токен |
|----------------|-----------------|-----------|
| Срок действия | Бессрочный | Временный (минуты-дни) |
| Область доступа | Все ресурсы | Конкретный ресурс |
| Права доступа | Полные | Ограниченные |
| Безопасность | Высокий риск | Низкий риск |
| Хранение | На сервере | Временное |
| Передача клиенту | Нет | Да (в URL) |
| Отзыв | Ручной | Автоматический |
| Нагрузка на сервер | Высокая | Низкая |

**Рекомендации:**
- Используйте **постоянные ключи** для серверных операций и управления ресурсами
- Используйте **SAS-токены** для предоставления клиентам временного доступа к ресурсам
- Никогда не передавайте постоянные ключи клиентам
- Генерируйте SAS-токены с минимально необходимыми правами и временем действия

---

### 107. Что такое паттерн «BFF (Backend for Frontend)»?

**Ответ:** Паттерн **"BFF (Backend for Frontend)"** — это архитектурный паттерн, при котором создаётся отдельный серверный компонент (backend) специально для каждого типа клиентского приложения (web, mobile, desktop), который адаптирует данные и функциональность микросервисов под специфические потребности конкретного фронтенда.

**Концепция:**

Вместо того чтобы все клиенты обращались напрямую к микросервисам, каждый тип клиента имеет свой собственный BFF, который:
- Агрегирует данные из нескольких микросервисов
- Оптимизирует ответы под конкретный клиент
- Упрощает API для клиента
- Реализует клиент-специфичную логику

**Архитектура:**

```
Web App → Web BFF → [Микросервис A, Микросервис B, Микросервис C]
Mobile App → Mobile BFF → [Микросервис A, Микросервис B, Микросервис C]
Desktop App → Desktop BFF → [Микросервис A, Микросервис B, Микросервис C]
```

**Преимущества:**

1. **Оптимизация под клиента:**
   - Web BFF может возвращать HTML-шаблоны
   - Mobile BFF может возвращать минимальный JSON для экономии трафика
   - Desktop BFF может возвращать полные данные для офлайн-режима

2. **Упрощение клиентского кода:**
   - Клиент делает один запрос вместо нескольких
   - BFF агрегирует данные из разных микросервисов
   - Клиент получает готовые данные в удобном формате

3. **Независимое развёртывание:**
   - Изменения в микросервисах не затрагивают клиентов
   - BFF изолирует изменения в backend от frontend
   - Разные версии BFF для разных версий клиентов

4. **Безопасность:**
   - BFF проверяет права доступа перед запросами к микросервисам
   - Клиенты не имеют прямого доступа к микросервисам
   - Централизованная обработка ошибок и валидации

**Пример реализации:**

```python
# Web BFF для веб-приложения
@app.route('/api/web/dashboard')
def web_dashboard():
    user_id = current_user.id
    
    # Агрегация данных из нескольких микросервисов
    user_service = UserService()
    order_service = OrderService()
    notification_service = NotificationService()
    
    # Параллельные запросы
    user_data = user_service.get_user(user_id)
    orders = order_service.get_recent_orders(user_id, limit=5)
    notifications = notification_service.get_unread(user_id)
    
    # Оптимизация для веб: включить только необходимые поля
    return jsonify({
        'user': {
            'name': user_data['name'],
            'email': user_data['email'],
            'avatar': user_data['avatar']
        },
        'recent_orders': orders,
        'notifications': notifications
    })

# Mobile BFF для мобильного приложения
@app.route('/api/mobile/dashboard')
def mobile_dashboard():
    user_id = current_user.id
    
    # Для мобильного: минимум данных для экономии трафика
    user_data = user_service.get_user(user_id)
    orders = order_service.get_recent_orders(user_id, limit=3)
    
    # Минимальный JSON
    return jsonify({
        'user': user_data['name'],
        'orders': [{'id': o['id'], 'status': o['status']} for o in orders]
    })
```

**Когда использовать:**

- Разные типы клиентов с разными требованиями
- Необходимость оптимизации данных для каждого клиента
- Сложная агрегация данных из множества микросервисов
- Необходимость изоляции изменений backend от frontend

**Недостатки:**

- Дублирование логики между BFF
- Дополнительный слой инфраструктуры
- Необходимость поддержки нескольких BFF

---

### 108. Как BFF помогает уменьшить поверхность атаки?

**Ответ:** BFF (Backend for Frontend) помогает уменьшить поверхность атаки следующими способами:

**1. Изоляция микросервисов:**
- **Микросервисы недоступны напрямую** — клиенты не могут обращаться напрямую к внутренним сервисам
- **Ограничение экспонированных эндпоинтов** — доступны только те API, которые предоставляет BFF
- **Скрытие внутренней архитектуры** — клиенты не знают о структуре микросервисов

**2. Централизованная валидация:**
```python
# BFF валидирует все входные данные
@app.route('/api/web/orders')
def create_order():
    # Валидация перед передачей в микросервис
    data = request.json
    if not validate_order_data(data):
        return "Invalid data", 400
    
    # Только валидированные данные передаются в микросервис
    order_service.create_order(data)
```

**3. Централизованная аутентификация и авторизация:**
- **Единая точка проверки прав** — BFF проверяет права доступа один раз
- **Контроль доступа** — BFF ограничивает доступ к функциям на основе прав пользователя
- **Защита от несанкционированного доступа** — микросервисы не нужно защищать индивидуально

**4. Фильтрация данных:**
```python
# BFF фильтрует чувствительные данные
@app.route('/api/mobile/user')
def get_user():
    user_data = user_service.get_user(user_id)
    
    # Удаление чувствительных данных для мобильного клиента
    filtered = {
        'name': user_data['name'],
        'email': user_data['email'],
        # 'credit_card': удалено для безопасности
        # 'ssn': удалено для безопасности
    }
    return jsonify(filtered)
```

**5. Ограничение функциональности:**
- **Только необходимые операции** — BFF предоставляет только те функции, которые нужны клиенту
- **Запрет административных операций** — клиенты не могут выполнять опасные операции
- **Ограничение параметров** — BFF ограничивает параметры запросов

**6. Защита от атак:**
```python
# BFF реализует защиту от атак
@app.route('/api/web/search')
@rate_limit(per_minute=60)  # Rate limiting
@validate_input  # Валидация
@sanitize_output  # Санитизация выходных данных
def search():
    query = request.args.get('q')
    # BFF защищает от XSS, SQL injection, и других атак
    results = search_service.search(sanitize(query))
    return jsonify(sanitize_output(results))
```

**7. Мониторинг и логирование:**
- **Централизованное логирование** — все запросы логируются в BFF
- **Обнаружение аномалий** — BFF может обнаружить подозрительную активность
- **Аудит доступа** — все обращения к данным проходят через BFF

**8. Версионирование и депрекация:**
- **Контроль версий API** — старые версии API могут быть отключены в BFF
- **Постепенная миграция** — BFF может направлять запросы к разным версиям микросервисов

**Пример архитектуры безопасности:**

```
Интернет
  ↓
[WAF / DDoS Protection]
  ↓
[API Gateway] ← Аутентификация, Rate Limiting
  ↓
[BFF] ← Валидация, Авторизация, Фильтрация
  ↓
[Микросервисы] ← Защищены, недоступны извне
```

**Преимущества для безопасности:**
- Единая точка применения политик безопасности
- Упрощение аудита и мониторинга
- Изоляция внутренних компонентов
- Снижение риска прямых атак на микросервисы

---

### 109. Что такое паттерн «Bulkhead (Отсек)» и как он повышает отказоустойчивость?

**Ответ:** Паттерн **"Bulkhead (Отсек)"** — это паттерн изоляции, который разделяет элементы приложения на пулы изолированных ресурсов, чтобы сбой в одной части системы не приводил к отказу всей системы.

**Концепция:**
Аналогия с кораблём: отсеки (bulkheads) изолируют воду в случае пробоины, предотвращая затопление всего корабля.

**Применение в программном обеспечении:**

**1. Изоляция пулов соединений:**
```python
# Разделение пулов соединений к базе данных
class DatabasePoolManager:
    def __init__(self):
        # Отдельный пул для критичных операций
        self.critical_pool = create_pool(max_connections=10, name='critical')
        
        # Отдельный пул для некритичных операций
        self.normal_pool = create_pool(max_connections=20, name='normal')
        
        # Отдельный пул для отчётов (не критично)
        self.reporting_pool = create_pool(max_connections=5, name='reporting')
    
    def get_critical_connection(self):
        return self.critical_pool.get_connection()
    
    def get_normal_connection(self):
        return self.normal_pool.get_connection()
```

**2. Изоляция потоков/процессов:**
```python
# Разделение worker-процессов по типам задач
# Критичные задачи в отдельном пуле
critical_executor = ThreadPoolExecutor(max_workers=5, thread_name_prefix='critical')

# Некритичные задачи в другом пуле
normal_executor = ThreadPoolExecutor(max_workers=20, thread_name_prefix='normal')
```

**3. Изоляция ресурсов по клиентам:**
```python
# Разделение ресурсов по клиентам/тенантам
class TenantIsolation:
    def __init__(self):
        # Каждый тенант имеет свой пул ресурсов
        self.tenant_pools = {}
    
    def get_pool_for_tenant(self, tenant_id):
        if tenant_id not in self.tenant_pools:
            self.tenant_pools[tenant_id] = create_pool(max_connections=10)
        return self.tenant_pools[tenant_id]
```

**4. Изоляция в микросервисах:**
```yaml
# Kubernetes: отдельные deployment для разных типов нагрузок
# Критичный сервис
apiVersion: apps/v1
kind: Deployment
metadata:
  name: critical-service
spec:
  replicas: 3
  resources:
    requests:
      cpu: "1"
      memory: "2Gi"
---
# Некритичный сервис (отдельный отсек)
apiVersion: apps/v1
kind: Deployment
metadata:
  name: non-critical-service
spec:
  replicas: 2
  resources:
    requests:
      cpu: "0.5"
      memory: "1Gi"
```

**Как повышает отказоустойчивость:**

1. **Предотвращение каскадных отказов:**
   - Сбой в некритичной части не влияет на критичную
   - Перегрузка одного пула не блокирует другие

2. **Ограничение распространения проблем:**
   - Утечка памяти в одном отсеке не влияет на другие
   - Блокировки в одном пуле не блокируют другие операции

3. **Гранулярное масштабирование:**
   - Можно увеличивать ресурсы для критичных частей независимо
   - Некритичные части могут использовать меньше ресурсов

4. **Приоритизация:**
   - Критичные операции всегда имеют доступ к ресурсам
   - Некритичные операции не могут исчерпать ресурсы критичных

**Пример реализации:**
```python
from concurrent.futures import ThreadPoolExecutor
import threading

class BulkheadExecutor:
    def __init__(self):
        # Отдельные executor'ы для разных типов задач
        self.critical_executor = ThreadPoolExecutor(max_workers=5)
        self.normal_executor = ThreadPoolExecutor(max_workers=20)
    
    def execute_critical(self, task):
        # Критичные задачи в изолированном пуле
        return self.critical_executor.submit(task)
    
    def execute_normal(self, task):
        # Некритичные задачи в отдельном пуле
        return self.normal_executor.submit(task)

# Использование
executor = BulkheadExecutor()

# Критичная операция платежа - изолирована
payment_future = executor.execute_critical(process_payment)

# Некритичная отправка email - не блокирует платежи
email_future = executor.execute_normal(send_notification)
```

---

### 110. Что такое паттерн «Database per Service»?

**Ответ:** Паттерн **"Database per Service"** — это архитектурный паттерн микросервисов, при котором каждый микросервис имеет свою собственную базу данных, к которой имеют доступ только этот сервис и никакой другой.

**Принципы:**

1. **Изоляция данных:** Каждый сервис владеет своими данными
2. **Независимость:** Сервисы могут использовать разные типы БД
3. **Автономность:** Изменения схемы БД одного сервиса не влияют на другие
4. **Масштабируемость:** Каждая БД масштабируется независимо

**Архитектура:**

```
Микросервис A → База данных A (PostgreSQL)
Микросервис B → База данных B (MongoDB)
Микросервис C → База данных C (Redis)
```

**Преимущества:**

1. **Независимое развёртывание:**
   - Изменение схемы БД одного сервиса не требует координации с другими
   - Каждый сервис может использовать оптимальную для него БД

2. **Изоляция отказов:**
   - Сбой одной БД не влияет на другие сервисы
   - Можно применять разные стратегии резервного копирования

3. **Производительность:**
   - Каждая БД оптимизирована под конкретный сервис
   - Нет конкуренции за ресурсы между сервисами

4. **Безопасность:**
   - Каждый сервис имеет доступ только к своим данным
   - Упрощение контроля доступа

**Пример:**

```python
# Сервис пользователей
class UserService:
    def __init__(self):
        # Своя БД для пользователей
        self.db = PostgreSQLConnection('user_db')
    
    def get_user(self, user_id):
        return self.db.query("SELECT * FROM users WHERE id = %s", user_id)

# Сервис заказов
class OrderService:
    def __init__(self):
        # Своя БД для заказов
        self.db = PostgreSQLConnection('order_db')
    
    def get_order(self, order_id):
        return self.db.query("SELECT * FROM orders WHERE id = %s", order_id)
```

**Проблемы и решения:**

1. **Согласованность данных:**
   - Проблема: Транзакции между сервисами невозможны
   - Решение: Использование паттернов Saga, Event Sourcing, CQRS

2. **Дублирование данных:**
   - Проблема: Данные могут дублироваться между сервисами
   - Решение: Принятие дублирования как компромисса за изоляцию

3. **Сложность запросов:**
   - Проблема: Сложно делать запросы, требующие данных из нескольких сервисов
   - Решение: API-композиция, агрегация на уровне Gateway или BFF

---

### 111. Что такое Sidecar-паттерн и как он используется для безопасности?

**Ответ:** Паттерн **"Sidecar"** — это архитектурный паттерн, при котором вспомогательный компонент (sidecar) развёртывается вместе с основным приложением в том же контейнере или поде, предоставляя дополнительные функции без изменения основного приложения.

**Концепция:**
Аналогия с мотоциклом с коляской: sidecar — это дополнительный компонент, который работает рядом с основным приложением.

**Использование для безопасности:**

**1. Проксирование и шифрование:**
```yaml
# Kubernetes: Sidecar для TLS-терминации
apiVersion: v1
kind: Pod
spec:
  containers:
  - name: app
    image: myapp:latest
  - name: envoy-sidecar
    image: envoyproxy/envoy:latest
    # Envoy проксирует трафик и обрабатывает TLS
```

**2. Логирование и мониторинг:**
```python
# Sidecar для логирования
class LoggingSidecar:
    def intercept_logs(self):
        # Перехватывает логи приложения и отправляет в централизованное хранилище
        # Безопасное логирование без модификации основного приложения
        pass
```

**3. Аутентификация и авторизация:**
```python
# Sidecar для проверки токенов
class AuthSidecar:
    def validate_request(self, request):
        # Проверяет JWT токены перед передачей в основное приложение
        # Основное приложение получает уже аутентифицированные запросы
        token = request.headers.get('Authorization')
        if not validate_token(token):
            return 401
        return request
```

**4. Шифрование данных:**
```python
# Sidecar для шифрования трафика
class EncryptionSidecar:
    def encrypt_response(self, data):
        # Шифрует данные перед отправкой
        return encrypt(data, key)
    
    def decrypt_request(self, encrypted_data):
        # Расшифровывает входящие данные
        return decrypt(encrypted_data, key)
```

**5. Инъекция секретов:**
```yaml
# Sidecar для управления секретами
apiVersion: apps/v1
kind: Deployment
spec:
  template:
    spec:
      containers:
      - name: app
        image: myapp:latest
      - name: vault-agent-sidecar
        image: vault:latest
        # Автоматически инжектит секреты из Vault в основное приложение
```

**6. WAF (Web Application Firewall):**
```yaml
# Sidecar как WAF
containers:
- name: app
  image: myapp:latest
- name: modsecurity-sidecar
  image: owasp/modsecurity-crs:latest
  # Перехватывает и фильтрует HTTP-запросы
```

**Преимущества для безопасности:**

1. **Изоляция функций безопасности:**
   - Безопасность отделена от бизнес-логики
   - Упрощение обновлений безопасности

2. **Единообразие:**
   - Одинаковые политики безопасности для всех приложений
   - Централизованное управление

3. **Прозрачность:**
   - Основное приложение не знает о безопасности
   - Не требует изменений в коде приложения

4. **Независимое развёртывание:**
   - Обновления безопасности без перезапуска приложения
   - A/B тестирование политик безопасности

**Пример реализации с Envoy:**
```yaml
# Envoy sidecar конфигурация
static_resources:
  listeners:
  - name: listener_0
    address:
      socket_address:
        address: 0.0.0.0
        port_value: 8080
    filter_chains:
    - filters:
      - name: envoy.filters.network.http_connection_manager
        typed_config:
          http_filters:
          - name: envoy.filters.http.jwt_authn  # JWT аутентификация
          - name: envoy.filters.http.router
      route_config:
        routes:
        - match:
            prefix: "/"
          route:
            cluster: service_cluster
```

---

### 112. Что такое MILS-архитектура?

**Ответ:** **MILS (Multiple Independent Levels of Security)** — это архитектура безопасности, основанная на принципе разделения и изоляции компонентов системы по уровням безопасности.

**Основные принципы:**

1. **Разделение (Separation):** Компоненты изолированы друг от друга
2. **Независимость (Independence):** Сбои одного уровня не влияют на другие
3. **Уровни безопасности (Levels of Security):** Разные компоненты могут иметь разные уровни защиты

**Компоненты архитектуры:**

1. **Partitioning (Разделение):**
   - Разделение системы на независимые разделы (partitions)
   - Каждый раздел изолирован от других

2. **Isolation (Изоляция):**
   - Строгая изоляция между разделами
   - Запрет несанкционированного обмена данными

3. **Information Flow Control (Контроль потоков информации):**
   - Контроль направлений потоков данных
   - Предотвращение утечек информации от высокого уровня к низкому

4. **Trusted Components (Доверенные компоненты):**
   - Минимальный набор доверенных компонентов
   - Верификация безопасности доверенных компонентов

**Архитектура:**

```
┌─────────────────────────────────────┐
│   MILS Separation Kernel            │
│  (Доверенная основа системы)        │
├─────────────────────────────────────┤
│   Partition 1  │  Partition 2       │
│   (Level 1)    │  (Level 2)         │
│                │                    │
│   Isolated     │  Isolated          │
└─────────────────────────────────────┘
```

**Применение:**

1. **Критически важные системы:**
   - Военные системы
   - Системы управления воздушным движением
   - Медицинское оборудование

2. **Системы с разными уровнями классификации:**
   - Системы, обрабатывающие данные разного уровня секретности
   - Системы, где необходимо разделение публичных и конфиденциальных данных

3. **КИИ (Критическая информационная инфраструктура):**
   - Системы энергетики
   - Системы управления транспортом

**Преимущества:**

1. **Безопасность:**
   - Высокая степень изоляции
   - Предотвращение утечек информации

2. **Надёжность:**
   - Сбой одного раздела не влияет на другие
   - Повышенная отказоустойчивость

3. **Сертификация:**
   - Облегчает сертификацию по Common Criteria
   - Соответствие требованиям безопасности

**Пример реализации:**
```python
# Концептуальный пример разделения
class MILSPartition:
    def __init__(self, security_level):
        self.security_level = security_level
        self.isolated_memory = IsolatedMemory()
        self.isolated_storage = IsolatedStorage()
    
    def send_to_partition(self, data, target_partition):
        # Проверка политики информации
        if target_partition.security_level < self.security_level:
            raise SecurityError("Cannot send to lower security level")
        
        # Отправка через доверенный коммуникационный канал
        trusted_kernel.send(self, target_partition, data)
```

---

### 113. Что такое паттерн «Claim Check»?

**Ответ:** Паттерн **"Claim Check"** (чек-квитанция) — это паттерн интеграции, при котором вместо передачи больших данных через промежуточную систему (например, очередь сообщений) передаётся только идентификатор (чек), по которому получатель может извлечь данные из хранилища.

**Проблема, которую решает:**
- Очереди сообщений ограничены по размеру сообщений
- Передача больших данных через очередь неэффективна
- Большие сообщения замедляют обработку очереди

**Как работает:**

1. **Отправитель:**
   - Сохраняет большие данные в хранилище
   - Получает уникальный идентификатор (claim check)
   - Отправляет в очередь только claim check и метаданные

2. **Получатель:**
   - Получает claim check из очереди
   - Извлекает данные из хранилища по claim check
   - Обрабатывает данные

**Пример реализации:**

```python
import uuid
import redis
from cryptography.fernet import Fernet

class ClaimCheckService:
    def __init__(self):
        self.storage = redis.Redis()
        self.cipher = Fernet(Fernet.generate_key())
    
    def store_data(self, data: bytes) -> str:
        """Сохраняет данные и возвращает claim check"""
        claim_id = str(uuid.uuid4())
        
        # Шифрование перед сохранением
        encrypted_data = self.cipher.encrypt(data)
        
        # Сохранение с TTL
        self.storage.setex(
            f"claim:{claim_id}",
            3600,  # 1 час
            encrypted_data
        )
        
        return claim_id
    
    def retrieve_data(self, claim_id: str) -> bytes:
        """Извлекает данные по claim check"""
        # Валидация claim_id
        if not self._validate_claim_id(claim_id):
            raise ValueError("Invalid claim ID")
        
        encrypted_data = self.storage.get(f"claim:{claim_id}")
        if not encrypted_data:
            raise ValueError("Claim check not found or expired")
        
        # Расшифровка
        data = self.cipher.decrypt(encrypted_data)
        
        # Удаление после использования (опционально)
        self.storage.delete(f"claim:{claim_id}")
        
        return data
    
    def _validate_claim_id(self, claim_id: str) -> bool:
        """Валидация формата claim ID"""
        import re
        return bool(re.match(r'^[a-f0-9-]{36}$', claim_id))

# Использование
service = ClaimCheckService()

# Отправитель: сохраняет большие данные
large_data = b"Very large data..." * 10000
claim_id = service.store_data(large_data)

# Передача только claim_id через очередь
message_queue.send({
    "claim_id": claim_id,
    "metadata": {"type": "report", "size": len(large_data)}
})

# Получатель: извлекает данные
message = message_queue.receive()
data = service.retrieve_data(message["claim_id"])
```

**Безопасные особенности:**

1. **Уникальный идентификатор** — UUID, сложно угадать
2. **Валидация** — проверка формата claim ID
3. **Шифрование** — данные шифруются перед сохранением
4. **TTL** — автоматическое удаление через время
5. **Одноразовое использование** — удаление после извлечения

**Преимущества:**

- Эффективность — очередь не перегружается большими данными
- Безопасность — данные хранятся в защищённом хранилище
- Масштабируемость — можно обрабатывать данные любого размера
- Гибкость — разные получатели могут извлекать данные

---

### 114. Что такое паттерн «Circuit Breaker»?

**Ответ:** Паттерн **"Circuit Breaker" (Автоматический выключатель)** — это паттерн проектирования, который предотвращает каскадные отказы, временно прерывая вызовы к неисправному сервису, позволяя ему восстановиться.

**Состояния Circuit Breaker:**

1. **Closed (Закрыт) — нормальная работа:**
   - Запросы проходят через circuit breaker
   - Отслеживание ошибок и времени отклика

2. **Open (Открыт) — сбой обнаружен:**
   - Запросы немедленно отклоняются без обращения к сервису
   - Быстрый ответ об ошибке

3. **Half-Open (Полуоткрыт) — тестирование:**
   - Разрешается ограниченное количество запросов
   - Если запросы успешны → переход в Closed
   - Если запросы неудачны → возврат в Open

**Реализация:**

```python
import time
from enum import Enum
from threading import Lock

class CircuitState(Enum):
    CLOSED = "closed"
    OPEN = "open"
    HALF_OPEN = "half_open"

class CircuitBreaker:
    def __init__(self, failure_threshold=5, timeout=60, success_threshold=2):
        self.failure_threshold = failure_threshold  # Порог ошибок
        self.timeout = timeout  # Время ожидания в Open
        self.success_threshold = success_threshold  # Успешных запросов для перехода в Closed
        
        self.failure_count = 0
        self.success_count = 0
        self.last_failure_time = None
        self.state = CircuitState.CLOSED
        self.lock = Lock()
    
    def call(self, func, *args, **kwargs):
        with self.lock:
            # Проверка состояния
            if self.state == CircuitState.OPEN:
                if time.time() - self.last_failure_time > self.timeout:
                    # Переход в Half-Open
                    self.state = CircuitState.HALF_OPEN
                    self.success_count = 0
                else:
                    # Circuit открыт, отклоняем запрос
                    raise CircuitBreakerOpenError("Circuit breaker is OPEN")
            
            # Выполнение функции
            try:
                result = func(*args, **kwargs)
                
                # Успешный запрос
                if self.state == CircuitState.HALF_OPEN:
                    self.success_count += 1
                    if self.success_count >= self.success_threshold:
                        self.state = CircuitState.CLOSED
                        self.failure_count = 0
                
                if self.state == CircuitState.CLOSED:
                    self.failure_count = 0
                
                return result
            
            except Exception as e:
                # Неудачный запрос
                self.failure_count += 1
                self.last_failure_time = time.time()
                
                if self.failure_count >= self.failure_threshold:
                    self.state = CircuitState.OPEN
                
                raise

# Использование
breaker = CircuitBreaker(failure_threshold=5, timeout=60)

try:
    result = breaker.call(external_service.request, data)
except CircuitBreakerOpenError:
    # Быстрый ответ при открытом circuit
    return {"error": "Service temporarily unavailable"}
except Exception as e:
    # Обработка других ошибок
    return {"error": str(e)}
```

**Преимущества:**

1. **Предотвращение каскадных отказов:**
   - Быстрый отказ вместо длительного ожидания
   - Защита от перегрузки неисправного сервиса

2. **Время на восстановление:**
   - Сервису даётся время на восстановление
   - Автоматическое тестирование восстановления

3. **Улучшение производительности:**
   - Быстрые ответы при открытом circuit
   - Нет ожидания таймаутов

**Настройки:**

- **failure_threshold** — количество ошибок для открытия circuit
- **timeout** — время в открытом состоянии перед переходом в half-open
- **success_threshold** — количество успешных запросов для закрытия circuit

---

### 115. Что такое паттерн «Retry with Backoff»?

**Ответ:** Паттерн **"Retry with Backoff" (Повтор с экспоненциальной задержкой)** — это паттерн обработки ошибок, при котором неудачные запросы повторяются с увеличивающейся задержкой между попытками.

**Типы backoff:**

1. **Exponential Backoff (Экспоненциальная задержка):**
   - Задержка увеличивается экспоненциально: 1s, 2s, 4s, 8s, 16s...

2. **Linear Backoff (Линейная задержка):**
   - Задержка увеличивается линейно: 1s, 2s, 3s, 4s, 5s...

3. **Jitter (Случайная вариация):**
   - Добавление случайности для предотвращения "thundering herd"

**Реализация:**

```python
import time
import random
from functools import wraps

def retry_with_backoff(max_retries=3, initial_delay=1, max_delay=60, exponential_base=2, jitter=True):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            delay = initial_delay
            
            for attempt in range(max_retries):
                try:
                    return func(*args, **kwargs)
                except RetryableError as e:
                    if attempt == max_retries - 1:
                        raise
                    
                    # Вычисление задержки
                    if jitter:
                        # Добавление случайности
                        delay_with_jitter = delay * (0.5 + random.random())
                    else:
                        delay_with_jitter = delay
                    
                    # Ограничение максимальной задержки
                    delay_with_jitter = min(delay_with_jitter, max_delay)
                    
                    time.sleep(delay_with_jitter)
                    
                    # Увеличение задержки для следующей попытки
                    delay = min(delay * exponential_base, max_delay)
            
            raise MaxRetriesExceeded(f"Failed after {max_retries} attempts")
        
        return wrapper
    return decorator

# Использование
@retry_with_backoff(max_retries=5, initial_delay=1, max_delay=30)
def api_call():
    response = requests.get("https://api.example.com/data")
    if response.status_code == 429:  # Rate limit
        raise RetryableError("Rate limited")
    response.raise_for_status()
    return response.json()
```

**Безопасные практики:**

1. **Только для временных ошибок:**
   - Retry только для transient errors (timeout, 429, 503)
   - Не retry для permanent errors (400, 401, 404)

2. **Ограничение количества попыток:**
   - Максимальное количество retry
   - Общий timeout для всех попыток

3. **Jitter:**
   - Предотвращение одновременных retry от множества клиентов
   - Снижение нагрузки на сервис

**Пример с различными стратегиями:**

```python
class RetryStrategy:
    @staticmethod
    def exponential(delay, attempt, base=2):
        return min(delay * (base ** attempt), 60)
    
    @staticmethod
    def linear(delay, attempt):
        return delay * (attempt + 1)
    
    @staticmethod
    def constant(delay, attempt):
        return delay

def retry(func, strategy=RetryStrategy.exponential, max_retries=3):
    for attempt in range(max_retries):
        try:
            return func()
        except RetryableError:
            if attempt < max_retries - 1:
                delay = strategy(1, attempt)
                time.sleep(delay)
            else:
                raise
```

---

### 116. Что такое паттерн «Throttling» и как он защищает от Resource Exhaustion?

**Ответ:** Паттерн **"Throttling" (Дросселирование)** — это механизм ограничения количества запросов или операций от клиента в единицу времени для предотвращения перегрузки системы и атак на исчерпание ресурсов.

**Как защищает от Resource Exhaustion:**

1. **Ограничение количества запросов:**
   - Предотвращает отправку большого количества запросов одним клиентом
   - Защищает от DDoS и брутфорс-атак

2. **Защита ресурсов:**
   - Предотвращает исчерпание CPU, памяти, соединений с БД
   - Обеспечивает доступность системы для всех пользователей

3. **Справедливое распределение:**
   - Ограничивает использование ресурсов одним клиентом
   - Гарантирует ресурсы для других пользователей

**Реализация:**

```python
import time
from collections import defaultdict
from threading import Lock

class Throttler:
    def __init__(self, requests_per_second=10, requests_per_minute=100):
        self.rps_limit = requests_per_second
        self.rpm_limit = requests_per_minute
        self.requests = defaultdict(list)
        self.lock = Lock()
    
    def is_allowed(self, identifier: str) -> bool:
        """Проверяет, разрешён ли запрос"""
        now = time.time()
        
        with self.lock:
            # Получение истории запросов
            request_history = self.requests[identifier]
            
            # Удаление старых запросов (старше минуты)
            request_history[:] = [t for t in request_history if now - t < 60]
            
            # Проверка лимита в минуту
            if len(request_history) >= self.rpm_limit:
                return False
            
            # Проверка лимита в секунду
            recent_requests = [t for t in request_history if now - t < 1]
            if len(recent_requests) >= self.rps_limit:
                return False
            
            # Добавление текущего запроса
            request_history.append(now)
            
            return True

# Использование
throttler = Throttler(requests_per_second=10, requests_per_minute=100)

@app.route('/api/data')
def get_data():
    client_id = request.remote_addr
    
    if not throttler.is_allowed(client_id):
        return {"error": "Rate limit exceeded"}, 429
    
    return {"data": "..."}
```

**Типы throttling:**

1. **Rate Limiting** — ограничение количества запросов в единицу времени
2. **Connection Throttling** — ограничение количества одновременных соединений
3. **Bandwidth Throttling** — ограничение пропускной способности

---

### 117. Что такое паттерн «Saga» и как он обеспечивает согласованность в распределённых системах?

**Ответ:** Паттерн **"Saga"** — это паттерн управления транзакциями в распределённых системах, где длинная транзакция разбивается на последовательность локальных транзакций, каждая из которых может быть откачена через компенсирующую транзакцию.

**Проблема:**
В микросервисной архитектуре нельзя использовать двухфазный коммит (2PC) для распределённых транзакций, так как это блокирует ресурсы и снижает производительность.

**Типы Saga:**

1. **Choreography (Хореография):**
   - Каждый сервис знает, что делать дальше
   - События публикуются в брокер сообщений
   - Слабая связанность, но сложнее отслеживание

2. **Orchestration (Оркестрация):**
   - Центральный оркестратор координирует выполнение
   - Оркестратор знает все шаги
   - Проще отслеживание, но централизованная логика

**Пример Orchestration Saga:**

```python
class OrderSaga:
    def __init__(self):
        self.steps = [
            self.reserve_inventory,
            self.process_payment,
            self.ship_order,
            self.send_notification
        ]
        self.compensations = [
            self.cancel_reservation,
            self.refund_payment,
            self.cancel_shipment,
            None  # Уведомление не требует компенсации
        ]
    
    def execute(self, order_data):
        executed_steps = []
        
        try:
            for step in self.steps:
                step(order_data)
                executed_steps.append(step)
            
            return {"status": "completed"}
        
        except Exception as e:
            # Компенсация выполненных шагов в обратном порядке
            for step in reversed(executed_steps):
                idx = self.steps.index(step)
                if self.compensations[idx]:
                    self.compensations[idx](order_data)
            
            return {"status": "failed", "error": str(e)}
    
    def reserve_inventory(self, order_data):
        # Резервирование товара
        inventory_service.reserve(order_data['items'])
    
    def cancel_reservation(self, order_data):
        # Отмена резервирования
        inventory_service.cancel_reservation(order_data['items'])
    
    def process_payment(self, order_data):
        # Обработка платежа
        payment_service.charge(order_data['payment'])
    
    def refund_payment(self, order_data):
        # Возврат средств
        payment_service.refund(order_data['payment'])
```

**Обеспечение согласованности:**

1. **Атомарность на уровне шагов:**
   - Каждый шаг — локальная транзакция
   - Либо выполняется полностью, либо откатывается

2. **Компенсирующие транзакции:**
   - Для каждого шага есть компенсация
   - Откат в обратном порядке выполнения

3. **Идемпотентность:**
   - Компенсирующие транзакции должны быть идемпотентными
   - Повторное выполнение не должно вызывать проблем

**Преимущества:**

- Работает в распределённых системах
- Не блокирует ресурсы надолго
- Подходит для длительных процессов

**Недостатки:**

- Сложность реализации компенсаций
- Возможна временная несогласованность
- Сложность отладки

---

### 118. Что такое паттерн «Input Validation (Allowlist)»?

**Ответ:** Паттерн **"Input Validation (Allowlist)"** — это практика безопасности, при которой разрешаются только заранее определённые, известные безопасные значения входных данных, а всё остальное отклоняется.

**Принципы:**

1. **Whitelist (Allowlist):** Определение списка разрешённых значений
2. **Deny by default:** По умолчанию всё запрещено
3. **Строгая валидация:** Проверка формата и содержимого

**Примеры:**

```python
# 1. Валидация по фиксированному списку
ALLOWED_ROLES = ['admin', 'user', 'guest']

def validate_role(role: str) -> str:
    if role not in ALLOWED_ROLES:
        raise ValueError(f"Role {role} not allowed")
    return role

# 2. Валидация по паттерну (allowlist символов)
import re

def validate_username(username: str) -> str:
    # Только буквы, цифры, подчёркивания, длина 3-20
    if not re.match(r'^[a-zA-Z0-9_]{3,20}$', username):
        raise ValueError("Invalid username format")
    return username

# 3. Валидация файлов
ALLOWED_EXTENSIONS = {'.jpg', '.png', '.pdf'}

def validate_file(filename: str) -> str:
    ext = os.path.splitext(filename)[1].lower()
    if ext not in ALLOWED_EXTENSIONS:
        raise ValueError("File type not allowed")
    return filename

# 4. Валидация HTTP методов
ALLOWED_METHODS = {'GET', 'POST', 'PUT', 'DELETE'}

def validate_method(method: str) -> str:
    method = method.upper()
    if method not in ALLOWED_METHODS:
        raise ValueError("Method not allowed")
    return method
```

**Преимущества:**

- Высокий уровень безопасности
- Простота реализации
- Предсказуемость поведения

**Рекомендации:**

- Всегда используйте allowlist вместо blacklist
- Валидируйте на стороне сервера
- Нормализуйте данные перед валидацией
- Используйте строгие регулярные выражения

---

### 119. Что такое «Secure Logger» и зачем он нужен?

**Ответ:** **Secure Logger** — это система логирования, которая защищает чувствительные данные от утечек при записи в логи, применяя автоматическое маскирование, фильтрацию и шифрование.

**Проблемы обычного логирования:**

1. **Утечка чувствительных данных:**
   - Пароли, токены, номера карт в логах
   - Персональные данные в логах
   - Ключи шифрования в логах

2. **Несанкционированный доступ:**
   - Логи могут быть доступны неавторизованным пользователям
   - Логи хранятся в незашифрованном виде

**Функции Secure Logger:**

1. **Автоматическое маскирование:**
```python
import re
import logging

class SecureLogger:
    SENSITIVE_PATTERNS = [
        (r'password["\']?\s*[:=]\s*["\']?([^"\'\s]+)', r'password="***"'),
        (r'credit_card["\']?\s*[:=]\s*["\']?(\d+)', r'credit_card="****-****-****-****"'),
        (r'api_key["\']?\s*[:=]\s*["\']?([^"\'\s]+)', r'api_key="***"'),
        (r'ssn["\']?\s*[:=]\s*["\']?(\d+)', r'ssn="***-**-****"'),
    ]
    
    def mask_sensitive_data(self, message: str) -> str:
        for pattern, replacement in self.SENSITIVE_PATTERNS:
            message = re.sub(pattern, replacement, message, flags=re.IGNORECASE)
        return message
    
    def info(self, message):
        masked = self.mask_sensitive_data(str(message))
        logging.info(masked)
```

2. **Шифрование логов:**
```python
from cryptography.fernet import Fernet

class EncryptedLogger:
    def __init__(self, key: bytes):
        self.cipher = Fernet(key)
    
    def log(self, level, message):
        # Шифрование перед записью
        encrypted = self.cipher.encrypt(message.encode())
        logging.log(level, encrypted.hex())
```

3. **Фильтрация полей:**
```python
class FieldFilterLogger:
    SENSITIVE_FIELDS = ['password', 'token', 'api_key', 'credit_card']
    
    def filter_dict(self, data: dict) -> dict:
        filtered = {}
        for key, value in data.items():
            if key.lower() in self.SENSITIVE_FIELDS:
                filtered[key] = "***MASKED***"
            elif isinstance(value, dict):
                filtered[key] = self.filter_dict(value)
            else:
                filtered[key] = value
        return filtered
```

**Зачем нужен:**

- Защита от утечек конфиденциальных данных
- Соответствие требованиям GDPR, ФЗ-152
- Предотвращение компрометации через логи
- Аудит безопасности

---

### 120. Как правильно обрабатывать загрузку файлов на сервере?

**Ответ:** Правильная обработка загрузки файлов включает следующие меры безопасности:

**1. Валидация типа файла:**
```python
import magic
ALLOWED_MIME_TYPES = {'image/jpeg', 'image/png', 'application/pdf'}

def validate_file(file):
    file_content = file.read()
    file.seek(0)
    
    # Проверка MIME-типа по содержимому (не по расширению!)
    mime_type = magic.from_buffer(file_content, mime=True)
    if mime_type not in ALLOWED_MIME_TYPES:
        raise ValueError("Invalid file type")
```

**2. Валидация размера:**
```python
MAX_FILE_SIZE = 10 * 1024 * 1024  # 10 MB

if file.size > MAX_FILE_SIZE:
    raise ValueError("File too large")
```

**3. Безопасное имя файла:**
```python
import uuid
from werkzeug.utils import secure_filename

def get_safe_filename(original_filename):
    # Использование UUID вместо оригинального имени
    ext = os.path.splitext(original_filename)[1]
    return str(uuid.uuid4()) + ext
```

**4. Изоляция загруженных файлов:**
```python
from pathlib import Path

UPLOAD_DIR = Path("/var/uploads").resolve()

def save_file(file, filename):
    filepath = UPLOAD_DIR / filename
    
    # Проверка, что путь внутри UPLOAD_DIR
    try:
        filepath.resolve().relative_to(UPLOAD_DIR)
    except ValueError:
        raise ValueError("Invalid path")
    
    with open(filepath, 'wb') as f:
        f.write(file.read())
    
    # Безопасные права доступа
    os.chmod(filepath, 0o644)
```

**5. Сканирование на вирусы:**
```python
def scan_file(filepath):
    result = subprocess.run(['clamscan', str(filepath)], capture_output=True)
    if result.returncode != 0:
        raise ValueError("File contains malware")
```

**6. Контроль доступа:**
```python
@app.route('/download/<file_id>')
def download_file(file_id):
    # Валидация file_id
    if not re.match(r'^[a-f0-9-]{36}$', file_id):
        abort(400)
    
    # Проверка прав доступа
    if not user_has_access(current_user, file_id):
        abort(403)
    
    return send_file(filepath)
```

---

### 121. Что такое «Quarantine» артефактов и зачем он используется?

**Ответ:** **Quarantine (Карантин) артефактов** — это механизм блокировки артефактов сборки (Docker-образов, исполняемых файлов, пакетов), которые содержат обнаруженные уязвимости или не прошли проверки безопасности, с целью предотвращения их развёртывания в production.

**Зачем используется:**

1. **Предотвращение развёртывания уязвимостей**
2. **Контроль качества** — соответствие политикам безопасности
3. **Compliance** — соответствие стандартам
4. **Автоматизация** — автоматическая блокировка без ручного вмешательства

**Реализация:**

```python
class ArtifactQuarantine:
    def __init__(self):
        self.quarantine_storage = QuarantineStorage()
        self.vulnerability_scanner = VulnerabilityScanner()
    
    def check_and_quarantine(self, artifact):
        # Проверка на уязвимости
        vulnerabilities = self.vulnerability_scanner.scan(artifact)
        
        critical_vulns = [v for v in vulnerabilities if v.severity == 'critical']
        
        if critical_vulns:
            # Перемещение в карантин
            self.quarantine_storage.quarantine(artifact, critical_vulns)
            raise QuarantinedError("Artifact quarantined due to critical vulnerabilities")
        
        return artifact
```

---

### 122. Какие паттерны обеспечивают защиту в глубину (Defense-in-Depth)?

**Ответ:** Паттерны, обеспечивающие **защиту в глубину (Defense-in-Depth):**

1. **Gateway (Привратник)** — первая линия защиты
2. **BFF (Backend for Frontend)** — валидация и фильтрация
3. **Authentication/Authorization** — проверка прав доступа
4. **Input Validation** — валидация входных данных
5. **Output Encoding** — кодирование выходных данных
6. **Encryption** — шифрование данных в покое и при передаче
7. **Rate Limiting** — ограничение количества запросов
8. **WAF (Web Application Firewall)** — фильтрация на уровне сети
9. **Logging and Monitoring** — обнаружение аномалий
10. **Network Segmentation** — сегментация сети

**Многоуровневая защита:**

```
Интернет
  ↓ [WAF / DDoS Protection]
  ↓ [API Gateway - Rate Limiting]
  ↓ [Authentication]
  ↓ [BFF - Validation]
  ↓ [Authorization]
  ↓ [Application - Input Validation]
  ↓ [Database - Encryption]
```

---

### 123. Какие паттерны используются для изоляции компонентов согласно ГОСТ Р 71207-2024?

**Ответ:** Согласно ГОСТ Р 71207-2024, для изоляции компонентов используются:

1. **Разделение на изолированные модули**
2. **Использование границ изоляции (Boundaries)**
3. **Минимизация интерфейсов между компонентами**
4. **Контроль потоков данных между компонентами**
5. **Использование контейнеризации**
6. **Применение принципа наименьших привилегий**

---

### 124. Какие паттерны применяются для защиты данных в REST API?

**Ответ:** Паттерны для защиты данных в REST API:

1. **HTTPS/TLS** — шифрование трафика
2. **Authentication (OAuth 2.0, JWT)** — аутентификация
3. **Authorization (RBAC, ABAC)** — авторизация
4. **Input Validation** — валидация входных данных
5. **Output Filtering** — фильтрация чувствительных данных
6. **Rate Limiting** — ограничение количества запросов
7. **CORS** — контроль доступа к API
8. **API Versioning** — версионирование API
9. **Error Handling** — безопасная обработка ошибок

---

### 125. Какие архитектурные решения рекомендуются при проектировании КИИ?

**Ответ:** При проектировании КИИ (критической информационной инфраструктуры) рекомендуются:

1. **MILS-архитектура** — множественные независимые уровни безопасности
2. **Изоляция компонентов** — строгое разделение по уровням
3. **Защита в глубину** — многоуровневая защита
4. **Избыточность** — резервирование критичных компонентов
5. **Сегментация сети** — разделение на сегменты
6. **Мониторинг и логирование** — непрерывный мониторинг
7. **Аудит и соответствие** — соответствие требованиям ФСТЭК
8. **Управление инцидентами** — планы реагирования
9. **Шифрование данных** — защита данных в покое и при передаче
10. **Контроль доступа** — строгий контроль прав доступа

---

## Источники:
- Паттерны проектирования в области безопасности
- ГОСТ Р 56939-2024, ГОСТ Р 71207-2024
- OWASP Security Patterns
- Microsoft Architecture Patterns
- Best practices в области безопасного проектирования

