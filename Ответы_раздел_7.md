# Ответы на вопросы к зачёту
## Раздел 7: Инструменты, технологии и интеграции

### 151. Какие языки поддерживает PVS-Studio?

**Ответ:** **PVS-Studio** — статический анализатор кода, который поддерживает следующие языки программирования:

**Основные языки:**
1. **C/C++** — основной фокус инструмента
   - C89, C99, C11, C17
   - C++98, C++03, C++11, C++14, C++17, C++20

2. **C#** — поддержка с версии 7.00
   - .NET Framework
   - .NET Core
   - .NET 5/6/7/8

3. **Java** — поддержка с версии 7.20
   - Java 8, 11, 17, 21

**Платформы:**
- Windows
- Linux
- macOS

**Возможности:**
- Обнаружение более 1000 типов ошибок
- Поддержка IDE (Visual Studio, IntelliJ IDEA, Qt Creator и др.)
- Интеграция с CI/CD (Jenkins, TeamCity, GitLab CI, GitHub Actions)
- Поддержка SARIF для интеграции с другими инструментами
- Межпроцедурный анализ
- Анализ кода на соответствие MISRA, AUTOSAR, CERT

**Особенности:**
- Высокая точность обнаружения уязвимостей
- Низкий уровень false positives
- Поддержка крупных проектов (многие миллионы строк кода)
- Использование анализа потока данных и символьного выполнения

---

### 152. Какие языки поддерживает Svaser?

**Ответ:** **Svaser** — это российский статический анализатор кода, разработанный компанией "Базис". 

**Поддерживаемые языки:**
1. **C/C++** — основная поддержка
2. **Java** — поддержка Java-приложений
3. **C#** — поддержка .NET приложений

**Особенности:**
- Российская разработка
- Соответствие требованиям российских стандартов
- Поддержка ГОСТ Р 71207-2024
- Интеграция с российскими системами разработки
- Поддержка кириллицы в коде и комментариях

**Возможности:**
- Обнаружение уязвимостей безопасности
- Проверка соответствия стандартам кодирования
- Межпроцедурный анализ
- Интеграция с CI/CD
- Поддержка крупных проектов

**Применение:**
- Критически важная информационная инфраструктура (КИИ)
- Государственные системы
- Системы с требованиями к локализации инструментов

---

### 153. Какие инструменты соответствуют требованиям ГОСТ Р 71207–2024?

**Ответ:** Согласно ГОСТ Р 71207–2024 "Статический анализ программного обеспечения", инструменты должны соответствовать следующим требованиям:

**Общие требования:**
1. **Функциональные возможности:**
   - Выполнение статического анализа исходного кода
   - Обнаружение уязвимостей и дефектов
   - Поддержка соответствующих языков программирования

2. **Требования к результатам:**
   - Структурированные результаты анализа
   - Связь с требованиями безопасности (CWE, OWASP)
   - Трассируемость результатов

3. **Требования к точности:**
   - Минимизация false positives
   - Высокая полнота обнаружения (recall)

4. **Требования к интеграции:**
   - Поддержка стандартных форматов (SARIF)
   - Интеграция с системами разработки
   - Возможность автоматизации

**Инструменты, соответствующие требованиям:**

**Российские инструменты:**
1. **Svaser** — российский статический анализатор
2. **PVS-Studio** — поддерживает российские стандарты
3. **Polyspace** (MathWorks) — при наличии сертификации

**Международные инструменты:**
1. **Coverity** (Synopsys) — при соответствии требованиям
2. **Klocwork** (Perforce) — при наличии необходимых функций
3. **CodeSonar** (GrammaTech)
4. **SonarQube** — при правильной настройке

**Критерии соответствия:**
- Поддержка языков, используемых в проекте
- Обнаружение уязвимостей согласно требованиям
- Документирование результатов
- Возможность верификации результатов
- Соответствие требованиям по хранению артефактов

**Примечание:** Для использования в КИИ и государственных системах требуется подтверждение соответствия требованиям ФСТЭК России.

---

### 154. Как интегрировать SAST в GitHub Actions?

**Ответ:** Интеграция SAST в GitHub Actions выполняется через создание workflow файлов (`.github/workflows/security.yml`):

**Пример интеграции:**

```yaml
name: Security Scan

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  schedule:
    - cron: '0 0 * * 0'  # Еженедельное сканирование

jobs:
  sast:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      # Пример с CodeQL
      - name: Initialize CodeQL
        uses: github/codeql-action/init@v2
        with:
          languages: python, javascript
      
      - name: Autobuild
        uses: github/codeql-action/autobuild@v2
      
      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v2
      
      # Пример с SonarQube
      - name: SonarQube Scan
        uses: SonarSource/sonarqube-scan-action@master
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
      
      # Пример с Semgrep
      - name: Semgrep Scan
        uses: returntocorp/semgrep-action@v1
        with:
          config: >-
            p/security-audit
            p/owasp-top-ten
      
      # Пример с Bandit (Python)
      - name: Bandit Security Scan
        run: |
          pip install bandit
          bandit -r . -f json -o bandit-report.json
      
      # Пример с ESLint Security Plugin (JavaScript)
      - name: ESLint Security Scan
        run: |
          npm install eslint-plugin-security
          npx eslint . --ext .js,.jsx
      
      # Загрузка отчётов
      - name: Upload SARIF results
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: results.sarif
      
      # Отправка уведомлений при критических уязвимостях
      - name: Notify on critical issues
        if: failure()
        run: |
          echo "Critical vulnerabilities found!"
```

**Интеграция с конкретными инструментами:**

**1. GitHub CodeQL (встроенный):**
```yaml
- name: CodeQL Analysis
  uses: github/codeql-action/analyze@v2
```

**2. SonarQube:**
```yaml
- name: SonarQube Scan
  uses: SonarSource/sonarqube-scan-action@master
```

**3. Semgrep:**
```yaml
- name: Semgrep
  uses: returntocorp/semgrep-action@v1
```

**4. PVS-Studio:**
```yaml
- name: PVS-Studio
  run: |
    pvs-studio-analyzer trace -- make
    pvs-studio-analyzer analyze
    plog-converter -a GA:1,2 -t sarif -o results.sarif PVS-Studio.log
```

**5. Custom SAST инструмент:**
```yaml
- name: Custom SAST
  run: |
    docker run --rm -v $PWD:/src sast-tool /src
    # Загрузка результатов
```

**Security gates:**
```yaml
- name: Check for critical vulnerabilities
  run: |
    if grep -q "CRITICAL" results.sarif; then
      echo "Critical vulnerabilities found!"
      exit 1
    fi
```

---

### 155. Как интегрировать SAST в GitLab CI?

**Ответ:** Интеграция SAST в GitLab CI выполняется через файл `.gitlab-ci.yml`:

**Пример базовой интеграции:**

```yaml
stages:
  - build
  - test
  - security

variables:
  SAST_IMAGE: registry.gitlab.com/security-products/sast:latest

sast:
  stage: security
  image: $SAST_IMAGE
  script:
    - /analyzer run
  artifacts:
    reports:
      sast: gl-sast-report.json
    paths:
      - gl-sast-report.json
    expire_in: 1 week
  allow_failure: false  # Блокировать pipeline при критических уязвимостях
  only:
    - merge_requests
    - main
    - develop
```

**Интеграция с конкретными инструментами:**

**1. GitLab SAST (встроенный):**
```yaml
include:
  - template: Security/SAST.gitlab-ci.yml

sast:
  variables:
    SAST_EXCLUDED_PATHS: "spec, test, tests"
    SAST_ANALYZER_IMAGE_TAG: "3"
```

**2. SonarQube:**
```yaml
sonarqube:
  stage: security
  image: sonarsource/sonar-scanner-cli:latest
  variables:
    SONAR_USER_HOME: "${CI_PROJECT_DIR}/.sonar"
    GIT_DEPTH: "0"
  cache:
    key: "${CI_JOB_NAME}"
    paths:
      - .sonar/cache
  script:
    - sonar-scanner
      -Dsonar.host.url=${SONAR_HOST_URL}
      -Dsonar.login=${SONAR_TOKEN}
      -Dsonar.projectKey=${CI_PROJECT_NAME}
  only:
    - merge_requests
    - main
```

**3. Semgrep:**
```yaml
semgrep:
  stage: security
  image: returntocorp/semgrep:latest
  script:
    - semgrep --config=auto --json --output=semgrep-report.json .
  artifacts:
    reports:
      sast: semgrep-report.json
  allow_failure: false
```

**4. Bandit (Python):**
```yaml
bandit:
  stage: security
  image: python:3.9
  before_script:
    - pip install bandit bandit-sarif-formatter
  script:
    - bandit -r . -f sarif -o bandit-report.sarif
  artifacts:
    reports:
      sast: bandit-report.sarif
```

**5. ESLint Security (JavaScript):**
```yaml
eslint-security:
  stage: security
  image: node:18
  before_script:
    - npm install eslint eslint-plugin-security
  script:
    - npx eslint . --ext .js,.jsx --format json -o eslint-report.json
  artifacts:
    reports:
      sast: eslint-report.json
```

**Многоязычная интеграция:**
```yaml
sast-python:
  stage: security
  extends: .sast-template
  variables:
    SAST_LANGUAGE: python
  script:
    - bandit -r . -f sarif -o python-sast.sarif

sast-javascript:
  stage: security
  extends: .sast-template
  variables:
    SAST_LANGUAGE: javascript
  script:
    - npm audit --json > js-sast.json
```

**Security gates:**
```yaml
check-sast-results:
  stage: security
  script:
    - |
      if grep -q "critical" gl-sast-report.json; then
        echo "Critical vulnerabilities found!"
        exit 1
      fi
```

---

### 156. Как настроить хранение отчётов SAST для аудита?

**Ответ:** Настройка хранения отчётов SAST для аудита включает следующие шаги:

**1. Централизованное хранилище:**

```yaml
# GitHub Actions
- name: Upload reports to artifact storage
  uses: actions/upload-artifact@v3
  with:
    name: sast-reports
    path: |
      reports/*.sarif
      reports/*.json
    retention-days: 90
```

```yaml
# GitLab CI
sast:
  artifacts:
    reports:
      sast: gl-sast-report.json
    paths:
      - reports/
    expire_in: 1 year
    name: "sast-report-$CI_COMMIT_SHORT_SHA"
```

**2. Хранение в объектном хранилище:**

```python
import boto3
from datetime import datetime

def upload_sast_report(report_path, project_name):
    s3 = boto3.client('s3')
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    key = f"sast-reports/{project_name}/{timestamp}/report.sarif"
    
    s3.upload_file(
        report_path,
        'security-audit-bucket',
        key,
        Metadata={
            'project': project_name,
            'timestamp': timestamp,
            'report_type': 'SAST'
        }
    )
```

**3. База данных для хранения метаданных:**

```sql
CREATE TABLE sast_reports (
    id SERIAL PRIMARY KEY,
    project_name VARCHAR(255),
    commit_sha VARCHAR(40),
    report_path VARCHAR(500),
    scan_date TIMESTAMP,
    total_issues INTEGER,
    critical_issues INTEGER,
    high_issues INTEGER,
    tool_name VARCHAR(100),
    version VARCHAR(50)
);
```

**4. Интеграция с SIEM:**

```python
def send_to_siem(report):
    # Отправка в SIEM для анализа и корреляции
    siem_client.send_event({
        'event_type': 'sast_scan',
        'timestamp': datetime.now().isoformat(),
        'project': report['project'],
        'issues': report['issues'],
        'severity': report['severity']
    })
```

**5. Архивирование:**

```bash
#!/bin/bash
# Архивирование старых отчётов
tar -czf "sast-reports-$(date +%Y-%m).tar.gz" reports/
aws s3 cp "sast-reports-$(date +%Y-%m).tar.gz" s3://audit-archive/
```

**6. Соответствие требованиям ГОСТ Р 71207-2024:**

```python
class AuditReportStorage:
    def __init__(self):
        self.storage_path = "/var/audit/sast-reports"
        self.retention_period_days = 365 * 3  # 3 года
    
    def store_report(self, report_data, metadata):
        # Сохранение отчёта
        report_id = generate_uuid()
        report_path = f"{self.storage_path}/{report_id}.sarif"
        
        with open(report_path, 'w') as f:
            json.dump(report_data, f)
        
        # Сохранение метаданных
        self.store_metadata(report_id, metadata)
        
        # Логирование для аудита
        self.audit_log('report_stored', report_id, metadata)
    
    def audit_log(self, action, report_id, details):
        log_entry = {
            'timestamp': datetime.now().isoformat(),
            'action': action,
            'report_id': report_id,
            'user': get_current_user(),
            'details': details
        }
        # Невозможно изменить логи аудита
        self.append_to_audit_log(log_entry)
```

**Требования к хранению:**
- Невозможность изменения отчётов
- Долгосрочное хранение (3+ года)
- Шифрование чувствительных данных
- Контроль доступа
- Регулярное резервное копирование

---

### 157. Какие форматы отчётов поддерживаются (SARIF, CEF и др.)?

**Ответ:** SAST-инструменты поддерживают различные форматы отчётов:

**1. SARIF (Static Analysis Results Interchange Format):**
- **Стандарт:** OASIS стандарт (SARIF 2.1.0)
- **Использование:** Стандартный формат для статического анализа
- **Поддержка:** GitHub, GitLab, большинство SAST-инструментов
- **Преимущества:** Структурированный формат, поддержка трассировки

```json
{
  "version": "2.1.0",
  "$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
  "runs": [{
    "tool": {
      "driver": {
        "name": "Example Tool",
        "version": "1.0.0"
      }
    },
    "results": [{
      "ruleId": "CWE-89",
      "level": "error",
      "message": {
        "text": "SQL Injection vulnerability"
      },
      "locations": [{
        "physicalLocation": {
          "artifactLocation": {
            "uri": "src/main.py"
          },
          "region": {
            "startLine": 42,
            "startColumn": 10
          }
        }
      }]
    }]
  }]
}
```

**2. CEF (Common Event Format):**
- **Стандарт:** ArcSight
- **Использование:** Интеграция с SIEM-системами
- **Формат:** Key-Value пары

```
CEF:0|Security Tool|SAST|1.0|CWE-89|SQL Injection|8|src=main.py line=42
```

**3. JSON:**
- **Использование:** Универсальный формат
- **Преимущества:** Легко парсится, широко поддерживается

```json
{
  "tool": "bandit",
  "timestamp": "2024-01-15T10:30:00Z",
  "results": [
    {
      "issue_id": "B608",
      "severity": "MEDIUM",
      "file": "app.py",
      "line": 42,
      "description": "SQL injection"
    }
  ]
}
```

**4. XML:**
- **Использование:** Интеграция с Enterprise системами
- **Примеры:** Checkstyle XML, PMD XML

```xml
<?xml version="1.0"?>
<checkstyle>
  <file name="main.py">
    <error line="42" severity="error" message="SQL Injection" source="CWE-89"/>
  </file>
</checkstyle>
```

**5. HTML:**
- **Использование:** Визуализация для разработчиков
- **Преимущества:** Удобное представление результатов

**6. CSV:**
- **Использование:** Импорт в Excel/таблицы
- **Формат:** Простой табличный формат

```csv
Severity,File,Line,Rule ID,Description
ERROR,main.py,42,CWE-89,SQL Injection
```

**7. JUnit XML:**
- **Использование:** Интеграция с CI/CD системами
- **Стандарт:** JUnit test results format

```xml
<?xml version="1.0"?>
<testsuites>
  <testsuite name="Security Scan">
    <testcase name="CWE-89" file="main.py" line="42">
      <failure message="SQL Injection detected"/>
    </testcase>
  </testsuite>
</testsuites>
```

**8. Custom форматы:**
- **SonarQube:** Собственный формат для интеграции
- **CodeSonar:** XML формат с расширенной информацией

**Конвертация форматов:**

```python
import json

def sarif_to_json(sarif_file):
    with open(sarif_file, 'r') as f:
        sarif_data = json.load(f)
    
    # Конвертация в простой JSON
    results = []
    for run in sarif_data.get('runs', []):
        for result in run.get('results', []):
            results.append({
                'rule': result.get('ruleId'),
                'level': result.get('level'),
                'message': result.get('message', {}).get('text'),
                'file': result['locations'][0]['physicalLocation']['artifactLocation']['uri'],
                'line': result['locations'][0]['physicalLocation']['region']['startLine']
            })
    
    return {'issues': results}
```

**Рекомендации:**
- Использовать **SARIF** для стандартизации
- Поддерживать **JSON** для гибкости
- Использовать **CEF** для интеграции с SIEM
- Предоставлять **HTML** для удобства разработчиков

---

### 158. Какие инструменты используют SMT-решатели?

**Ответ:** Инструменты, использующие **SMT (Satisfiability Modulo Theories)** решатели для формальной верификации и статического анализа:

**1. Dafny:**
- **SMT-решатель:** Z3
- **Применение:** Верификация программ
- **Особенности:** Язык с встроенной верификацией

**2. Frama-C:**
- **SMT-решатели:** Z3, Alt-Ergo, CVC4
- **Применение:** Анализ кода на C
- **Особенности:** Доказательство свойств программ

**3. CBMC (Bounded Model Checker):**
- **SMT-решатель:** Z3, Boolector
- **Применение:** Проверка C/C++ программ
- **Особенности:** Модельная проверка с ограничениями

**4. KLEE:**
- **SMT-решатели:** STP, Z3
- **Применение:** Символьное выполнение
- **Особенности:** Автоматическая генерация тестов

**5. SeaHorn:**
- **SMT-решатель:** Z3, Spacer
- **Применение:** Верификация программ
- **Особенности:** Horn clause solving

**6. Infer (Facebook):**
- **SMT-решатель:** Встроенный решатель
- **Применение:** Статический анализ
- **Особенности:** Абстрактная интерпретация

**7. CodeSonar:**
- **SMT-решатели:** Внутренние решатели
- **Применение:** Глубокий статический анализ
- **Особенности:** Межпроцедурный анализ

**8. Z3 (сам по себе):**
- **SMT-решатель:** Z3
- **Применение:** Основа для других инструментов
- **Особенности:** Microsoft Research

**Применение SMT-решателей:**
- Доказательство корректности программ
- Обнаружение невыполнимых путей
- Проверка инвариантов
- Верификация свойств безопасности

---

### 159. Чем Frama-C отличается от KLEE?

**Ответ:** Различия между **Frama-C** и **KLEE**:

**Frama-C:**
- **Подход:** Дедуктивная верификация
- **Метод:** Математические доказательства с использованием SMT-решателей
- **Цель:** Доказательство корректности программ
- **Язык:** C
- **Применение:** Критически важные системы, сертификация
- **Результат:** Доказательство или опровержение свойств
- **Преимущества:** Высокая точность, формальные гарантии
- **Недостатки:** Требует аннотаций, трудоёмкий процесс

**KLEE:**
- **Подход:** Символьное выполнение
- **Метод:** Выполнение программы с символьными значениями
- **Цель:** Обнаружение ошибок и генерация тестов
- **Язык:** LLVM IR (поддерживает C, C++)
- **Применение:** Тестирование, поиск уязвимостей
- **Результат:** Конкретные тест-кейсы и найденные ошибки
- **Преимущества:** Автоматическое тестирование, обнаружение реальных ошибок
- **Недостатки:** Проблемы с масштабируемостью, сложными вычислениями

**Сравнение:**

| Характеристика | Frama-C | KLEE |
|----------------|---------|------|
| Подход | Дедуктивная верификация | Символьное выполнение |
| Цель | Доказательство корректности | Обнаружение ошибок |
| Аннотации | Требуются | Не требуются |
| Тест-кейсы | Не генерирует | Генерирует |
| Формальные гарантии | Да | Нет |
| Масштабируемость | Ограничена | Ограничена |
| Применение | Критические системы | Тестирование |

---

### 160. Какие преимущества у абстрактной интерпретации перед линтерами?

**Ответ:** Преимущества **абстрактной интерпретации** перед простыми линтерами:

**1. Более глубокий анализ:**
- **Абстрактная интерпретация:** Анализирует все возможные пути выполнения программы
- **Линтеры:** Проверяют синтаксические паттерны без понимания семантики

**2. Точность:**
- **Абстрактная интерпретация:** Отслеживает значения переменных и состояния программы
- **Линтеры:** Много false positives из-за поверхностного анализа

**3. Обнаружение сложных ошибок:**
- **Абстрактная интерпретация:** Может найти ошибки, требующие анализа потока данных
- **Линтеры:** Находят только очевидные паттерны

**4. Межпроцедурный анализ:**
- **Абстрактная интерпретация:** Анализирует вызовы функций через границы модулей
- **Линтеры:** Обычно ограничены одним файлом/функцией

**5. Отслеживание состояний:**
- **Абстрактная интерпретация:** Отслеживает абстрактные состояния программы
- **Линтеры:** Не понимают состояние программы

**6. Обнаружение runtime ошибок:**
- **Абстрактная интерпретация:** Может обнаружить деление на ноль, переполнение, null pointer
- **Линтеры:** Не могут обнаружить runtime ошибки без выполнения

**Пример:**

```python
# Абстрактная интерпретация обнаружит:
def divide(a, b):
    if a == b:
        return 100 / (a - b)  # Обнаружит деление на ноль!

# Линтер не обнаружит, так как это требует анализа значений
```

**Недостатки абстрактной интерпретации:**
- Более медленная работа
- Требует больше ресурсов
- Сложнее в настройке

**Когда использовать:**
- **Абстрактная интерпретация:** Критически важные системы, глубокий анализ
- **Линтеры:** Быстрая проверка, стайл-гайды, очевидные ошибки

---

### 161. Что такое символьное выполнение и в чём его ограничения?

**Ответ:** **Символьное выполнение (Symbolic Execution)** — это техника анализа программ, при которой программа выполняется с символьными значениями вместо конкретных входных данных, что позволяет исследовать множество путей выполнения одновременно.

**Как работает:**

1. Переменные представлены символьными выражениями
2. Программа выполняется, создавая ограничения на символьные переменные
3. SMT-решатель проверяет выполнимость ограничений
4. Для каждого выполнимого пути генерируются конкретные входные данные

**Пример:**

```c
int foo(int x, int y) {
    if (x > 0) {
        if (y == x * 2) {
            return 100 / (x - y);  // Деление на ноль при x > 0 и y == 2x
        }
    }
    return 0;
}
```

Символьное выполнение найдёт, что при `x = 10, y = 20` происходит деление на ноль.

**Ограничения:**

**1. Взрывная сложность (State Space Explosion):**
- Количество путей выполнения растёт экспоненциально
- Невозможность анализа больших программ целиком

**2. Сложные вычисления:**
- Проблемы с циклами и рекурсией
- Сложные математические операции
- Внешние зависимости

**3. Ограничения SMT-решателей:**
- Не все выражения разрешимы
- Время решения может быть экспоненциальным
- Ограничения на типы данных

**4. Интерактивные программы:**
- Проблемы с пользовательским вводом
- Системные вызовы
- Сетевое взаимодействие

**5. Неполнота:**
- Не все пути могут быть проанализированы
- Возможны пропущенные ошибки

**Инструменты символьного выполнения:**
- **KLEE** — для LLVM
- **SAGE** — Microsoft Research
- **angr** — Python framework
- **Triton** — binary analysis

**Применение:**
- Автоматическая генерация тестов
- Обнаружение уязвимостей
- Поиск путей к конкретным точкам кода
- Анализ бинарных файлов

---

### 162. Какие подходы используются для снижения false positives?

**Ответ:** Подходы для снижения **false positives** (ложных срабатываний) в статическом анализе:

**1. Межпроцедурный анализ:**
- Анализ вызовов функций через границы модулей
- Отслеживание потока данных через функции
- Более точное понимание контекста

**2. Анализ потока данных (Data Flow Analysis):**
- Отслеживание значений переменных
- Понимание, откуда приходят данные
- Проверка санитизации данных

**3. Контекстно-чувствительный анализ:**
- Учёт контекста использования кода
- Различная обработка в разных контекстах
- Учёт особенностей API

**4. Условный анализ:**
- Учёт условий выполнения
- Исключение невыполнимых путей
- SMT-решатели для проверки условий

**5. Машинное обучение:**
- Обучение на размеченных данных
- Классификация результатов как true/false positive
- Ранжирование по вероятности

**6. Интерактивная верификация:**
- Предоставление дополнительной информации
- Аннотации от разработчиков
- Обратная связь для улучшения анализа

**7. Использование аннотаций:**
```java
@NonNull
String processInput(@Sanitized String input) {
    // Анализатор знает, что input санитизирован
    return input;
}
```

**8. Whitelist известных безопасных паттернов:**
```python
# Игнорирование известных безопасных случаев
if is_known_safe_pattern(code):
    return False  # Не сообщать об этом
```

**9. Статистический анализ:**
- Анализ исторических данных
- Обучение на основе предыдущих результатов
- Фильтрация по частоте ложных срабатываний

**10. Конфигурируемые правила:**
```yaml
rules:
  sql_injection:
    severity: high
    ignore_patterns:
      - "prepared_statement.*"
    require_context:
      - user_input
```

**Метрики качества:**
- **Precision** — процент правильных результатов
- **Recall** — процент найденных реальных проблем
- **F-measure** — баланс между precision и recall

---

### 163. Какие подходы используются для снижения false negatives?

**Ответ:** Подходы для снижения **false negatives** (пропущенных уязвимостей) в статическом анализе:

**1. Комбинация методов анализа:**
- SAST + DAST + IAST
- Различные инструменты с разными подходами
- Синергия методов

**2. Глубокий межпроцедурный анализ:**
- Анализ всех вызовов функций
- Отслеживание данных через модули
- Учёт сложных зависимостей

**3. Символьное выполнение:**
- Исследование всех путей выполнения
- Генерация тестов для покрытия путей
- Обнаружение сложных условий

**4. Фаззинг (Fuzzing):**
- Автоматическая генерация входных данных
- Обнаружение уязвимостей через динамическое тестирование
- Комбинация с символьным выполнением

**5. Абстрактная интерпретация:**
- Анализ всех возможных состояний
- Консервативные приближения
- Гарантии полноты

**6. Анализ на уровне нескольких языков:**
- Анализ серверной и клиентской частей
- Учёт взаимодействия компонентов
- Полное покрытие системы

**7. Обновление баз знаний:**
- Регулярное обновление правил
- Добавление новых паттернов уязвимостей
- Учёт последних атак

**8. Кастомные правила:**
```yaml
custom_rules:
  - pattern: "eval(${input})"
    severity: critical
    description: "Code injection vulnerability"
```

**9. Анализ зависимостей:**
- SCA (Software Composition Analysis)
- Обнаружение уязвимостей в библиотеках
- Анализ цепочки зависимостей

**10. Регулярные сканирования:**
- Непрерывный мониторинг
- Периодические глубокие сканирования
- Анализ изменений в коде

**11. Ручной аудит:**
- Code review с фокусом на безопасность
- Пентестинг
- Экспертный анализ

**12. Использование множественных инструментов:**
```python
# Комбинация инструментов
tools = [
    PVS_Studio(),
    Coverity(),
    SonarQube(),
    CodeQL()
]

results = []
for tool in tools:
    results.extend(tool.analyze(code))
```

**Метрики покрытия:**
- Покрытие кода анализом
- Покрытие классов уязвимостей (CWE)
- Количество обнаруженных vs реальных проблем

---

### 164. Что такое SBOM и какие форматы он использует?

**Ответ:** **SBOM (Software Bill of Materials)** — это структурированный список компонентов, библиотек и зависимостей, входящих в состав программного обеспечения, аналогичный списку ингредиентов для продуктов питания.

**Назначение:**
- Прозрачность состава ПО
- Управление уязвимостями
- Соответствие требованиям (например, Executive Order 14028 в США)
- Отслеживание лицензий

**Форматы SBOM:**

**1. SPDX (Software Package Data Exchange):**
- **Стандарт:** ISO/IEC 5962:2021
- **Формат:** JSON, YAML, XML, Tag-Value
- **Разработчик:** Linux Foundation

```json
{
  "SPDXID": "SPDXRef-DOCUMENT",
  "spdxVersion": "SPDX-2.3",
  "dataLicense": "CC0-1.0",
  "name": "Example Package",
  "packages": [
    {
      "SPDXID": "SPDXRef-Package-1",
      "name": "express",
      "versionInfo": "4.18.2",
      "downloadLocation": "https://npmjs.com/package/express"
    }
  ]
}
```

**2. CycloneDX:**
- **Формат:** JSON, XML
- **Разработчик:** OWASP
- **Особенности:** Фокус на безопасности

```json
{
  "bomFormat": "CycloneDX",
  "specVersion": "1.4",
  "components": [
    {
      "type": "library",
      "name": "express",
      "version": "4.18.2",
      "purl": "pkg:npm/express@4.18.2"
    }
  ]
}
```

**3. SWID (Software Identification Tags):**
- **Стандарт:** ISO/IEC 19770-2
- **Формат:** XML
- **Применение:** Инвентаризация ПО

**4. JSON (Custom):**
```json
{
  "components": [
    {
      "name": "package-name",
      "version": "1.0.0",
      "type": "library",
      "license": "MIT",
      "vulnerabilities": []
    }
  ]
}
```

**Генерация SBOM:**

```bash
# Для Node.js
npm install -g @cyclonedx/cyclonedx-npm
cyclonedx-npm --output-file sbom.json

# Для Python
pip install cyclonedx-bom
cyclonedx-py -o sbom.json

# Для Java/Maven
mvn org.cyclonedx:cyclonedx-maven-plugin:makeAggregateBom
```

**Использование:**
- Сканирование уязвимостей в зависимостях
- Управление лицензиями
- Соответствие требованиям безопасности
- Отслеживание цепочки поставок

---

### 165. Как работает SCA и как он интегрируется в CI/CD?

**Ответ:** **SCA (Software Composition Analysis)** — это процесс анализа открытого исходного кода и зависимостей на наличие известных уязвимостей.

**Как работает SCA:**

1. **Идентификация зависимостей:**
   - Парсинг файлов зависимостей (package.json, requirements.txt, pom.xml)
   - Построение дерева зависимостей
   - Определение всех используемых библиотек

2. **Проверка уязвимостей:**
   - Сопоставление с базой данных CVE
   - Проверка версий библиотек
   - Определение уровня критичности

3. **Анализ лицензий:**
   - Проверка совместимости лицензий
   - Обнаружение лицензионных конфликтов

4. **Генерация отчёта:**
   - Список уязвимостей
   - Рекомендации по обновлению
   - SBOM (Software Bill of Materials)

**Интеграция в CI/CD:**

**1. GitHub Actions:**
```yaml
name: SCA Scan

on: [push, pull_request]

jobs:
  sca:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      # Snyk
      - name: Run Snyk
        uses: snyk/actions/node@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          args: --severity-threshold=high
      
      # WhiteSource / Mend
      - name: Mend Scan
        uses: whitesource/run-alerts@v1
        env:
          WS_APIKEY: ${{ secrets.WS_APIKEY }}
      
      # OWASP Dependency-Check
      - name: OWASP Dependency-Check
        run: |
          docker run --rm -v $PWD:/src owasp/dependency-check --scan /src --format SARIF
```

**2. GitLab CI:**
```yaml
include:
  - template: Security/Dependency-Scanning.gitlab-ci.yml

dependency_scanning:
  variables:
    DS_EXCLUDED_PATHS: "spec, test, tests"
    DS_ANALYZER_IMAGE_TAG: "3"
```

**3. Jenkins:**
```groovy
pipeline {
    agent any
    stages {
        stage('SCA') {
            steps {
                sh 'npm audit --json > audit-report.json'
                dependencyCheck additionalArguments: '--format JSON --format HTML'
            }
        }
    }
}
```

**4. Azure DevOps:**
```yaml
- task: WhiteSource@21
  inputs:
    cwd: '$(System.DefaultWorkingDirectory)'

- task: SnykSecurityScan@1
  inputs:
    serviceConnectionEndpoint: 'Snyk'
```

**5. Custom интеграция:**
```python
def sca_scan():
    # Сканирование зависимостей
    result = subprocess.run(['npm', 'audit', '--json'], capture_output=True)
    vulnerabilities = json.loads(result.stdout)
    
    # Проверка критических уязвимостей
    critical = [v for v in vulnerabilities if v['severity'] == 'critical']
    
    if critical:
        # Блокировка pipeline
        raise Exception("Critical vulnerabilities found!")
    
    # Генерация SBOM
    generate_sbom()
```

**Автоматические действия:**
- Блокировка развёртывания при критических уязвимостях
- Автоматическое создание issue
- Уведомления в Slack/Email
- Генерация SBOM

**Популярные инструменты SCA:**
- **Snyk** — облачный сервис
- **WhiteSource / Mend** — комплексное решение
- **OWASP Dependency-Check** — открытый инструмент
- **GitHub Dependabot** — встроенный в GitHub
- **GitLab Dependency Scanning** — встроенный в GitLab

---

### 166. Какие меры автоматического реагирования возможны при обнаружении уязвимости в pipeline?

**Ответ:** Меры автоматического реагирования при обнаружении уязвимостей в CI/CD pipeline:

**1. Блокировка развёртывания (Fail Pipeline):**
```yaml
- name: Security Gate
  run: |
    if [ "$(grep -c 'CRITICAL' sast-report.json)" -gt 0 ]; then
      echo "Critical vulnerabilities found!"
      exit 1  # Остановка pipeline
    fi
```

**2. Quarantine артефактов:**
```python
def quarantine_artifact(artifact, vulnerabilities):
    if has_critical_vulnerabilities(vulnerabilities):
        # Перемещение в карантин
        quarantine_storage.quarantine(artifact)
        # Блокировка развёртывания
        block_deployment(artifact)
```

**3. Создание issue/тикета:**
```python
def create_security_issue(vulnerability):
    github.create_issue(
        title=f"Security: {vulnerability['name']}",
        body=vulnerability['description'],
        labels=['security', 'critical'],
        assignees=['security-team']
    )
```

**4. Уведомления:**
```python
def send_alert(vulnerability):
    # Slack
    slack_client.send_message(
        channel='#security',
        text=f"Critical vulnerability found: {vulnerability['name']}"
    )
    
    # Email
    send_email(
        to='security-team@company.com',
        subject='Critical Security Alert',
        body=vulnerability['description']
    )
```

**5. Автоматическое создание pull request:**
```python
def auto_fix_dependency(vulnerability):
    # Автоматическое обновление уязвимой зависимости
    updated_version = get_fixed_version(vulnerability)
    update_dependency(vulnerability['package'], updated_version)
    
    # Создание PR
    create_pull_request(
        title=f"Security: Update {vulnerability['package']}",
        branch='security/auto-fix'
    )
```

**6. Откат развёртывания:**
```python
def auto_rollback(deployment, vulnerability):
    if is_production(deployment) and is_critical(vulnerability):
        rollback_deployment(deployment)
        notify_team("Deployment rolled back due to security issue")
```

**7. Автоматическое сканирование:**
```python
def trigger_deep_scan(vulnerability):
    # Запуск дополнительных проверок
    run_penetration_test()
    run_dynamic_scan()
```

**8. Интеграция с SIEM:**
```python
def send_to_siem(vulnerability):
    siem_client.send_event({
        'event_type': 'vulnerability_detected',
        'severity': vulnerability['severity'],
        'component': vulnerability['component'],
        'timestamp': datetime.now().isoformat()
    })
```

**9. Условная блокировка:**
```yaml
- name: Conditional Gate
  run: |
    critical_count=$(grep -c 'CRITICAL' report.json)
    if [ "$critical_count" -gt 5 ]; then
      exit 1  # Блокировка только при > 5 критических
    fi
```

**10. Автоматическое обновление:**
```python
def auto_update_dependencies():
    # Автоматическое обновление небезопасных зависимостей
    for vuln in critical_vulnerabilities:
        if auto_fix_available(vuln):
            update_dependency(vuln['package'], vuln['fixed_version'])
```

**Пример полного workflow:**
```yaml
security-scan:
  steps:
    - name: Run SAST
      run: sast-scan
    
    - name: Check Results
      run: |
        if has_critical_issues(); then
          create_issue()
          send_alert()
          exit 1  # Fail pipeline
        fi
    
    - name: Quarantine if needed
      if: has_high_issues()
      run: quarantine_artifact()
```

---

### 167. Какие инструменты подходят для анализа JavaScript и динамических языков?

**Ответ:** Инструменты для анализа JavaScript и динамических языков:

**JavaScript:**

**1. ESLint Security Plugin:**
- Обнаружение XSS, injection
- Проверка использования небезопасных функций
- Интеграция с ESLint

**2. Semgrep:**
- Поддержка JavaScript/TypeScript
- Правила для обнаружения уязвимостей
- Быстрый анализ

**3. Snyk Code:**
- SAST для JavaScript
- Обнаружение уязвимостей в коде
- Интеграция с IDE

**4. CodeQL:**
- Поддержка JavaScript/TypeScript
- Глубокий анализ
- Символьное выполнение

**5. SonarQube:**
- Анализ JavaScript/TypeScript
- Обнаружение уязвимостей
- Code smells

**Python:**

**1. Bandit:**
- Специализируется на безопасности Python
- Обнаружение типичных уязвимостей
- Простой в использовании

**2. Safety:**
- Проверка уязвимостей в зависимостях
- База данных известных уязвимостей
- Интеграция с CI/CD

**3. Semgrep:**
- Python правила
- Быстрый анализ
- Кастомные правила

**4. Pylint:**
- Общий анализ кода
- Плагины для безопасности
- Интеграция с IDE

**5. CodeQL:**
- Поддержка Python
- Глубокий анализ
- Обнаружение сложных уязвимостей

**Ruby:**

**1. Brakeman:**
- Специализируется на Ruby on Rails
- Обнаружение типичных уязвимостей Rails
- Быстрый анализ

**2. Semgrep:**
- Ruby правила
- Анализ Rails приложений

**PHP:**

**1. PHPStan Security Plugin:**
- Статический анализ PHP
- Обнаружение уязвимостей
- Интеграция с PHPStan

**2. Psalm:**
- Статический анализатор PHP
- Обнаружение ошибок
- Правила безопасности

**Особенности анализа динамических языков:**
- Сложность из-за динамической типизации
- Проблемы с анализом метапрограммирования
- Необходимость runtime информации

---

### 168. Какие инструменты используются для генерации тест-кейсов на основе символьного выполнения?

**Ответ:** Инструменты для генерации тест-кейсов через символьное выполнение:

**1. KLEE:**
- Символьное выполнение для LLVM
- Автоматическая генерация тестов
- Покрытие путей выполнения

**2. SAGE (Microsoft):**
- Автоматическая генерация тестов
- Фокус на обнаружении ошибок
- Использование в Microsoft

**3. angr:**
- Python framework
- Анализ бинарных файлов
- Генерация тестов

**4. CVC4 / Z3:**
- SMT-решатели
- Используются для генерации входных данных
- Основа для других инструментов

**5. Triton:**
- Binary analysis framework
- Символьное выполнение
- Генерация тестов для бинарников

**6. CREST:**
- Автоматическая генерация тестов для C
- Использование символьного выполнения
- Покрытие веток

**Принцип работы:**
1. Символьное выполнение программы
2. Создание ограничений для каждого пути
3. Решение ограничений SMT-решателем
4. Генерация конкретных входных данных

---

### 169. Какие инструменты подходят для верификации критических систем (авионика, энергетика)?

**Ответ:** Инструменты для верификации критических систем:

**1. Frama-C:**
- Дедуктивная верификация для C
- Формальные доказательства
- Применение в авионике

**2. SPARK (Ada):**
- Формальная верификация для Ada
- Применение в авионике
- Доказательство отсутствия ошибок

**3. Polyspace (MathWorks):**
- Статический анализ
- Верификация встраиваемых систем
- Применение в авионике, автомобилях

**4. Astrée:**
- Абстрактная интерпретация
- Применение в авионике
- Автоматическая верификация

**5. CBMC:**
- Модельная проверка
- Верификация C/C++ программ
- Применение в критических системах

**6. TLA+:**
- Спецификация и верификация
- Моделирование систем
- Применение в распределённых системах

**7. Isabelle / Coq:**
- Интерактивные доказательства
- Формальная верификация
- Высокий уровень гарантий

**Требования:**
- Формальные методы
- Доказательство корректности
- Соответствие стандартам (DO-178C, IEC 61508)
- Сертификация

---

### 170. Какие инструменты рекомендуются ФСТЭК для КИИ?

**Ответ:** ФСТЭК России рекомендует следующие инструменты для анализа ПО в КИИ:

**Российские инструменты:**
1. **Svaser** — российский статический анализатор
2. **PVS-Studio** — при наличии сертификации

**Требования ФСТЭК:**
- Соответствие ГОСТ Р 71207-2024
- Сертификация инструментов
- Поддержка российских стандартов
- Локализация инструментов

**Общие рекомендации:**
- Инструменты должны соответствовать требованиям безопасности
- Возможность верификации результатов
- Документирование процесса анализа
- Сохранение артефактов анализа

**Примечание:** Конкретный список рекомендуемых инструментов может изменяться, необходимо проверять актуальные рекомендации ФСТЭК.

---

### 171. Какие инструменты обеспечивают межпроцедурный анализ?

**Ответ:** Инструменты с межпроцедурным анализом:

**1. Coverity (Synopsys):**
- Глубокий межпроцедурный анализ
- Отслеживание данных через функции
- Высокая точность

**2. CodeSonar (GrammaTech):**
- Межпроцедурный анализ потока данных
- Обнаружение сложных уязвимостей
- Применение в критических системах

**3. PVS-Studio:**
- Межпроцедурный анализ для C/C++/C#/Java
- Отслеживание значений через функции
- Высокая точность

**4. Klocwork (Perforce):**
- Межпроцедурный анализ
- Обнаружение уязвимостей
- Интеграция с CI/CD

**5. Infer (Facebook):**
- Межпроцедурный анализ
- Абстрактная интерпретация
- Поддержка Java, C/C++, Objective-C

**6. CodeQL:**
- Межпроцедурные запросы
- Отслеживание данных через модули
- Глубокий анализ

**7. SonarQube:**
- Межпроцедурный анализ (ограниченный)
- Зависит от языка и правил

**Особенности межпроцедурного анализа:**
- Анализ вызовов функций
- Отслеживание параметров и возвращаемых значений
- Учёт побочных эффектов
- Анализ через границы модулей

---

### 172. Какие инструменты поддерживают CWE Top 25?

**Ответ:** Инструменты, поддерживающие CWE Top 25:

**1. Coverity:**
- Поддержка большинства CWE Top 25
- Глубокий анализ
- Высокая точность

**2. CodeSonar:**
- Покрытие CWE Top 25
- Специализация на критических системах

**3. PVS-Studio:**
- Обнаружение многих CWE Top 25
- Фокус на C/C++/C#/Java

**4. SonarQube:**
- Поддержка CWE через правила
- Зависит от языка

**5. Checkmarx:**
- Покрытие CWE Top 25
- Анализ веб-приложений

**6. Veracode:**
- Поддержка CWE Top 25
- SAST + DAST

**7. Semgrep:**
- Правила для CWE Top 25
- Настраиваемые правила

**CWE Top 25 включает:**
- CWE-787 (Out-of-bounds Write)
- CWE-79 (XSS)
- CWE-89 (SQL Injection)
- CWE-20 (Improper Input Validation)
- И другие критичные уязвимости

---

### 173. Что такое SARIF и зачем он нужен?

**Ответ:** **SARIF (Static Analysis Results Interchange Format)** — это стандартный формат (OASIS стандарт) для представления результатов статического анализа кода.

**Назначение:**
- Унификация формата результатов
- Интеграция инструментов
- Обмен результатами между системами

**Преимущества:**
- Стандартизация
- Совместимость инструментов
- Интеграция с CI/CD
- Визуализация результатов

**Структура SARIF:**
```json
{
  "version": "2.1.0",
  "runs": [{
    "tool": {
      "driver": {
        "name": "Example Tool"
      }
    },
    "results": [{
      "ruleId": "CWE-89",
      "level": "error",
      "message": {
        "text": "SQL Injection"
      },
      "locations": [...]
    }]
  }]
}
```

**Поддержка:**
- GitHub Security
- GitLab Security Dashboard
- Большинство SAST-инструментов
- CI/CD платформы

---

### 174. Какие CI/CD-платформы поддерживают встроенный SAST?

**Ответ:** CI/CD-платформы с встроенным SAST:

**1. GitHub:**
- **CodeQL** — встроенный SAST
- **Dependabot** — сканирование зависимостей
- **GitHub Advanced Security**

**2. GitLab:**
- **GitLab SAST** — встроенный анализатор
- **Security Dashboard**
- Интеграция с внешними инструментами

**3. Azure DevOps:**
- **Microsoft Security Code Analysis**
- Интеграция с SonarQube
- WhiteSource / Mend

**4. Jenkins:**
- Плагины для SAST
- Интеграция с различными инструментами
- Гибкая настройка

**5. CircleCI:**
- Орбиты для SAST
- Интеграция с Snyk, SonarQube

**6. Bitbucket Pipelines:**
- Интеграция с Snyk
- Поддержка внешних инструментов

---

### 175. Какие решения подходят для анализа открытых зависимостей (open-source)?

**Ответ:** Решения для анализа открытых зависимостей:

**1. Snyk:**
- Сканирование зависимостей
- Мониторинг уязвимостей
- Автоматические обновления

**2. WhiteSource / Mend:**
- Комплексное решение
- Управление лицензиями
- SBOM генерация

**3. OWASP Dependency-Check:**
- Открытый инструмент
- Локальное выполнение
- Поддержка множества форматов

**4. GitHub Dependabot:**
- Встроен в GitHub
- Автоматические PR
- Бесплатно

**5. GitLab Dependency Scanning:**
- Встроен в GitLab
- Автоматическое сканирование
- Интеграция с Security Dashboard

**6. npm audit / yarn audit:**
- Встроен в npm/yarn
- Быстрое сканирование
- Для JavaScript проектов

**7. Safety (Python):**
- Сканирование Python зависимостей
- База данных уязвимостей
- Интеграция с CI/CD

**Функции:**
- Обнаружение известных уязвимостей (CVE)
- Управление лицензиями
- Генерация SBOM
- Рекомендации по обновлению

---

## Источники:
- Документация инструментов статического анализа
- ГОСТ Р 71207-2024
- OWASP Tools and Standards
- NIST Guidelines
- Опыт использования инструментов в индустрии

