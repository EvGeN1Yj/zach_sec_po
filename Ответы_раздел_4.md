# Ответы на вопросы к зачёту
## Раздел 4: Практический анализ кода и выявление уязвимостей

### 76. Найдите уязвимость в коде: query = "SELECT * FROM users WHERE id = " + user_id.

**Ответ:** В данном коде присутствует уязвимость **SQL-инъекции (SQL Injection, CWE-89)**.

**Проблема:** Пользовательский ввод `user_id` напрямую конкатенируется в SQL-запрос без экранирования и валидации. Злоумышленник может ввести SQL-код, который будет выполнен на сервере.

**Пример атаки:**
```python
# Злонамеренный ввод
user_id = "1 OR 1=1 --"

# Результирующий запрос
query = "SELECT * FROM users WHERE id = 1 OR 1=1 --"
# Вернёт все записи из таблицы users
```

**Безопасное исправление (параметризованные запросы):**
```python
# Python с использованием параметризованных запросов
cursor.execute("SELECT * FROM users WHERE id = %s", (user_id,))

# Или с использованием ORM
User.query.filter_by(id=user_id).first()
```

**Альтернативное исправление (валидация + экранирование):**
```python
# Валидация типа
if not user_id.isdigit():
    raise ValueError("Invalid user_id")
query = "SELECT * FROM users WHERE id = " + user_id
```

---

### 77. Есть ли уязвимость в os.system("ls " + user_input)? Какая?

**Ответ:** Да, присутствует уязвимость **Command Injection (CWE-78)** — инъекция команд операционной системы.

**Проблема:** Пользовательский ввод `user_input` напрямую вставляется в системную команду без валидации и экранирования. Злоумышленник может выполнить произвольные команды на сервере.

**Пример атаки:**
```python
# Злонамеренный ввод
user_input = "/tmp; rm -rf /"

# Выполнится команда
os.system("ls /tmp; rm -rf /")  # Выполнит ls, а затем удалит файлы
```

**Безопасное исправление:**
```python
# Вариант 1: Использование subprocess с параметрами
import subprocess
subprocess.run(["ls", user_input])  # user_input передаётся как аргумент

# Вариант 2: Валидация и санитизация входных данных
import os
import shlex

# Валидация пути (только буквы, цифры, слэши)
if not re.match(r'^[a-zA-Z0-9/._-]+$', user_input):
    raise ValueError("Invalid path")

# Безопасное выполнение
subprocess.run(["ls", shlex.quote(user_input)])
```

---

### 78. Есть ли уязвимость в subprocess.run(["echo", user_input])?

**Ответ:** Нет прямой уязвимости, но есть потенциальные риски в зависимости от контекста.

**Анализ:**
- В данном случае `user_input` передаётся как **отдельный аргумент** команды `echo`, а не как часть строки команды
- Command Injection здесь маловероятен, так как `subprocess.run` с массивом аргументов корректно экранирует каждый аргумент

**Однако, риски могут возникнуть, если:**
1. `user_input` содержит очень длинную строку (DoS через переполнение)
2. Вывод используется в другом небезопасном месте (например, для построения команд)
3. `user_input` передаётся в другие небезопасные функции

**Безопасный вариант:**
```python
import subprocess

# Безопасно, так как каждый аргумент передаётся отдельно
subprocess.run(["echo", user_input])  # OK

# Опасно, если используется shell=True
subprocess.run(f"echo {user_input}", shell=True)  # Уязвимо к инъекции!

# Для дополнительной безопасности можно валидировать ввод
if len(user_input) > 1000:  # Ограничение длины
    raise ValueError("Input too long")
subprocess.run(["echo", user_input])
```

---

### 79. Как безопасно прочитать файл, имя которого пришло от пользователя?

**Ответ:** Для безопасного чтения файла, имя которого пришло от пользователя, нужно применить следующие меры:

**1. Валидация имени файла (allowlist):**
```python
import os
import re
from pathlib import Path

def safe_read_file(filename):
    # Проверка на допустимые символы
    if not re.match(r'^[a-zA-Z0-9._-]+$', filename):
        raise ValueError("Invalid filename")
    
    # Запрет на path traversal
    if '..' in filename or '/' in filename or '\\' in filename:
        raise ValueError("Path traversal detected")
    
    # Определение базовой директории
    BASE_DIR = "/var/www/uploads"
    
    # Использование Path для безопасной работы с путями
    safe_path = Path(BASE_DIR) / filename
    
    # Проверка, что итоговый путь находится в разрешённой директории
    try:
        safe_path.resolve().relative_to(Path(BASE_DIR).resolve())
    except ValueError:
        raise ValueError("Path outside allowed directory")
    
    # Проверка существования файла
    if not safe_path.exists():
        raise FileNotFoundError("File not found")
    
    # Проверка, что это файл, а не директория
    if not safe_path.is_file():
        raise ValueError("Not a file")
    
    # Чтение файла
    with open(safe_path, 'rb') as f:
        return f.read()
```

**2. Использование whitelist допустимых файлов:**
```python
ALLOWED_FILES = {'config.txt', 'data.json', 'readme.md'}

def safe_read_file(filename):
    if filename not in ALLOWED_FILES:
        raise ValueError("File not allowed")
    
    BASE_DIR = "/var/www/uploads"
    filepath = os.path.join(BASE_DIR, filename)
    
    # Дополнительная проверка
    realpath = os.path.realpath(filepath)
    if not realpath.startswith(os.path.realpath(BASE_DIR)):
        raise ValueError("Invalid path")
    
    with open(realpath, 'rb') as f:
        return f.read()
```

**3. Использование ID вместо имён файлов:**
```python
# Сохранение файла
def save_file(user_file):
    file_id = str(uuid.uuid4())
    filepath = os.path.join(UPLOAD_DIR, file_id)
    # Сохранить файл с ID, а не с исходным именем
    with open(filepath, 'wb') as f:
        f.write(user_file.read())
    return file_id

# Чтение файла
def read_file(file_id):
    if not re.match(r'^[a-f0-9-]{36}$', file_id):  # UUID format
        raise ValueError("Invalid file ID")
    
    filepath = os.path.join(UPLOAD_DIR, file_id)
    # Безопасно, так как ID валидируется
    with open(filepath, 'rb') as f:
        return f.read()
```

---

### 80. Как исправить уязвимость в eval(request.args.get('code'))?

**Ответ:** В данном коде присутствует критическая уязвимость **Code Injection (CWE-94)** — выполнение произвольного кода.

**Проблема:** Функция `eval()` выполняет произвольный Python-код, что позволяет злоумышленнику выполнить любые команды на сервере.

**Пример атаки:**
```python
# Злонамеренный запрос
# /page?code=__import__('os').system('rm -rf /')

eval(request.args.get('code'))  # Выполнит команду удаления файлов!
```

**Безопасные исправления:**

**1. Полностью отказаться от eval() и использовать безопасные альтернативы:**
```python
# Если нужен калькулятор
import ast
import operator

ALLOWED_OPERATORS = {
    ast.Add: operator.add,
    ast.Sub: operator.sub,
    ast.Mult: operator.mul,
    ast.Div: operator.truediv,
}

def safe_eval(expr):
    # Парсинг в AST
    try:
        tree = ast.parse(expr, mode='eval')
    except SyntaxError:
        raise ValueError("Invalid expression")
    
    # Проверка, что используются только безопасные операторы
    def check_node(node):
        if isinstance(node, (ast.Constant, ast.NameConstant)):
            return True
        elif isinstance(node, ast.BinOp):
            if type(node.op) not in ALLOWED_OPERATORS:
                raise ValueError("Unsupported operator")
            return check_node(node.left) and check_node(node.right)
        elif isinstance(node, ast.Num):
            return True
        else:
            raise ValueError("Unsupported operation")
    
    if not check_node(tree.body):
        raise ValueError("Unsafe expression")
    
    # Безопасное вычисление
    return eval(compile(tree, '<string>', 'eval'), {"__builtins__": {}})
```

**2. Использовать whitelist разрешённых операций:**
```python
ALLOWED_EXPRESSIONS = {
    'sum': lambda x, y: x + y,
    'multiply': lambda x, y: x * y,
    # и т.д.
}

def safe_operation(operation, *args):
    if operation not in ALLOWED_EXPRESSIONS:
        raise ValueError("Operation not allowed")
    
    # Валидация аргументов
    for arg in args:
        if not isinstance(arg, (int, float)):
            raise ValueError("Invalid argument type")
    
    return ALLOWED_EXPRESSIONS[operation](*args)

# Использование
operation = request.args.get('op')  # 'sum', 'multiply', etc.
result = safe_operation(operation, arg1, arg2)
```

**3. Использовать sandbox или ограниченный интерпретатор:**
```python
# Использование RestrictedPython или аналогичных библиотек
from RestrictedPython import compile_restricted
from RestrictedPython.Guards import safe_builtins

def safe_exec(code):
    # Компиляция с ограничениями
    byte_code = compile_restricted(code, '<inline>', 'eval')
    # Выполнение с безопасным окружением
    return eval(byte_code, {"__builtins__": safe_builtins}, {})
```

**4. Если eval() действительно необходим, максимально ограничить окружение:**
```python
def limited_eval(code):
    # Очень ограниченное окружение
    safe_dict = {
        "__builtins__": {},
        "abs": abs,
        "max": max,
        "min": min,
        "sum": sum,
    }
    
    # Валидация входных данных
    if not re.match(r'^[0-9+\-*/(). ]+$', code):
        raise ValueError("Invalid characters")
    
    return eval(code, safe_dict)
```

**Рекомендация:** Лучше всего полностью отказаться от `eval()` и использовать безопасные альтернативы или специализированные библиотеки.

---

### 81. Как предотвратить XSS при выводе пользовательского ввода в HTML?

**Ответ:** Для предотвращения **XSS (Cross-Site Scripting, CWE-79)** при выводе пользовательского ввода в HTML необходимо экранировать специальные HTML-символы.

**1. Экранирование HTML (HTML Encoding):**
```python
# Python
import html

user_input = request.form.get('comment')
# Безопасный вывод
safe_output = html.escape(user_input)
# <script>alert('XSS')</script> → &lt;script&gt;alert(&#x27;XSS&#x27;)&lt;/script&gt;
```

```javascript
// JavaScript/Node.js
function escapeHtml(text) {
    const map = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#039;'
    };
    return text.replace(/[&<>"']/g, m => map[m]);
}

const safeOutput = escapeHtml(userInput);
```

**2. Использование шаблонизаторов с автоматическим экранированием:**
```python
# Jinja2 (Python)
from jinja2 import Environment, escape

# Автоматическое экранирование включено по умолчанию
{{ user_input }}  # Автоматически экранируется
{{ user_input | safe }}  # Только если вы уверены, что данные безопасны
```

```python
# Django (Python)
# В шаблонах Django автоматическое экранирование включено по умолчанию
{{ user_input }}  # Автоматически экранируется
{{ user_input | safe }}  # Отключение экранирования (опасно!)
```

**3. Content Security Policy (CSP):**
```html
<!-- В HTTP заголовках или meta теге -->
<meta http-equiv="Content-Security-Policy" 
      content="default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline';">
```

```python
# В заголовках ответа
response.headers['Content-Security-Policy'] = "default-src 'self'; script-src 'self'"
```

**4. Валидация и санитизация входных данных:**
```python
import re
import html
from bleach import clean

# Использование библиотеки bleach для очистки HTML
user_input = request.form.get('comment')
# Разрешить только определённые HTML-теги
safe_html = clean(user_input, tags=['p', 'br', 'strong', 'em'], strip=True)
```

**5. Для разных контекстов вывода — разные методы экранирования:**
```python
# HTML-контекст
html.escape(user_input)

# HTML-атрибут
html.escape(user_input, quote=True)

# JavaScript-контекст
import json
json.dumps(user_input)  # Экранирует для JavaScript

# URL-контекст
from urllib.parse import quote
quote(user_input, safe='')
```

**6. Использование DOMPurify на клиенте (JavaScript):**
```javascript
// DOMPurify — библиотека для очистки HTML
const clean = DOMPurify.sanitize(dirty, {
    ALLOWED_TAGS: ['p', 'br', 'strong', 'em'],
    ALLOWED_ATTR: []
});
```

**Рекомендации:**
- Всегда экранируйте пользовательский ввод перед выводом в HTML
- Используйте шаблонизаторы с автоматическим экранированием
- Применяйте Content Security Policy
- Проводите валидацию на стороне сервера
- Для разрешения HTML используйте whitelist разрешённых тегов

---

### 82. Как предотвратить path traversal при обработке пути к файлу?

**Ответ:** Для предотвращения **Path Traversal (Directory Traversal, CWE-22)** необходимо валидировать и нормализовать пути, ограничивая доступ только к разрешённым директориям.

**1. Использование Path.resolve() и проверка базовой директории:**
```python
from pathlib import Path
import os

def safe_read_file(filename):
    # Базовая директория
    BASE_DIR = Path("/var/www/uploads")
    
    # Полный путь
    file_path = BASE_DIR / filename
    
    # Нормализация пути и проверка, что он внутри BASE_DIR
    try:
        resolved = file_path.resolve()
        resolved.relative_to(BASE_DIR.resolve())
    except ValueError:
        raise ValueError("Path traversal detected")
    
    # Дополнительная проверка
    if '..' in str(resolved):
        raise ValueError("Invalid path")
    
    with open(resolved, 'rb') as f:
        return f.read()
```

**2. Удаление небезопасных последовательностей:**
```python
import os
import re

def safe_path(filename):
    # Удаление path traversal последовательностей
    filename = filename.replace('..', '')
    filename = filename.replace('/', '')
    filename = filename.replace('\\', '')
    
    # Валидация на допустимые символы
    if not re.match(r'^[a-zA-Z0-9._-]+$', filename):
        raise ValueError("Invalid filename")
    
    BASE_DIR = "/var/www/uploads"
    filepath = os.path.join(BASE_DIR, filename)
    
    # Проверка реального пути
    realpath = os.path.realpath(filepath)
    if not realpath.startswith(os.path.realpath(BASE_DIR)):
        raise ValueError("Path outside allowed directory")
    
    return realpath
```

**3. Использование whitelist разрешённых файлов:**
```python
ALLOWED_FILES = {'config.txt', 'data.json', 'readme.md'}

def safe_read_file(filename):
    if filename not in ALLOWED_FILES:
        raise ValueError("File not allowed")
    
    BASE_DIR = "/var/www/uploads"
    filepath = os.path.join(BASE_DIR, filename)
    
    # Дополнительная проверка
    if os.path.commonpath([BASE_DIR, filepath]) != BASE_DIR:
        raise ValueError("Invalid path")
    
    with open(filepath, 'rb') as f:
        return f.read()
```

**4. Использование идентификаторов вместо имён файлов:**
```python
import uuid

# Сохранение файла
def save_file(user_file):
    file_id = str(uuid.uuid4())
    filepath = os.path.join(UPLOAD_DIR, file_id)
    # Сохранить файл с безопасным ID
    with open(filepath, 'wb') as f:
        f.write(user_file.read())
    return file_id

# Чтение по ID
def read_file(file_id):
    # Валидация UUID
    if not re.match(r'^[a-f0-9-]{36}$', file_id):
        raise ValueError("Invalid file ID")
    
    filepath = os.path.join(UPLOAD_DIR, file_id)
    with open(filepath, 'rb') as f:
        return f.read()
```

**5. Использование chroot или jail (на уровне ОС):**
```python
import os

def chroot_safe_read_file(filename):
    # Изменение корневой директории процесса (требует root)
    os.chroot("/var/www/uploads")
    # Теперь путь /var/www/uploads становится корневым /
    with open(f'/{filename}', 'rb') as f:  # Безопасно
        return f.read()
```

**6. Использование библиотек для работы с путями:**
```python
from werkzeug.utils import secure_filename

def safe_filename(filename):
    # Функция из Flask/Werkzeug для безопасных имён файлов
    safe = secure_filename(filename)
    # Удаляет небезопасные символы и path traversal
    return safe
```

---

### 83. Как исправить переполнение буфера в strcpy(buf, user_input)?

**Ответ:** В данном коде присутствует уязвимость **Buffer Overflow (CWE-120)** из-за использования небезопасной функции `strcpy()`.

**Проблема:** `strcpy()` не проверяет размер буфера и может переписать память, что приводит к переполнению буфера.

**Безопасные исправления:**

**1. Использование strncpy() с проверкой размера:**
```c
char buf[256];
size_t buf_size = sizeof(buf);

// Безопасное копирование с ограничением размера
strncpy(buf, user_input, buf_size - 1);
buf[buf_size - 1] = '\0';  // Гарантированное завершение строки

// Дополнительная проверка
if (strlen(user_input) >= buf_size) {
    // Обработка ошибки: входная строка слишком длинная
    return ERROR_TOO_LONG;
}
```

**2. Использование snprintf() (предпочтительно):**
```c
char buf[256];
size_t buf_size = sizeof(buf);

// Безопасное копирование с автоматическим ограничением
int written = snprintf(buf, buf_size, "%s", user_input);

if (written < 0 || written >= buf_size) {
    // Строка была обрезана
    return ERROR_TRUNCATED;
}
```

**3. Использование strlcpy() (если доступна):**
```c
char buf[256];
size_t buf_size = sizeof(buf);

// strlcpy всегда завершает строку и возвращает длину
size_t copied = strlcpy(buf, user_input, buf_size);
if (copied >= buf_size) {
    // Строка была обрезана
    return ERROR_TRUNCATED;
}
```

**4. Валидация размера перед копированием:**
```c
char buf[256];
size_t buf_size = sizeof(buf);

// Проверка размера перед копированием
if (strlen(user_input) >= buf_size) {
    return ERROR_TOO_LONG;
}

strcpy(buf, user_input);  // Теперь безопасно
```

**5. Использование современных безопасных функций (C11):**
```c
// Использование bounds-checked функций (опциональная часть C11)
#define __STDC_WANT_LIB_EXT1__ 1
#include <string.h>

char buf[256];
errno_t result = strcpy_s(buf, sizeof(buf), user_input);
if (result != 0) {
    // Обработка ошибки
    return ERROR_COPY_FAILED;
}
```

**6. Использование динамической памяти (если размер неизвестен):**
```c
// Выделение памяти под нужный размер
size_t input_len = strlen(user_input);
char *buf = malloc(input_len + 1);
if (buf == NULL) {
    return ERROR_MALLOC_FAILED;
}

strcpy(buf, user_input);
// ... использование buf ...
free(buf);  // Освобождение памяти
```

**Рекомендации:**
- Никогда не используйте `strcpy()`, `strcat()`, `sprintf()` с пользовательским вводом
- Используйте функции с ограничением размера: `strncpy()`, `snprintf()`, `strlcpy()`
- Всегда проверяйте размер входных данных перед копированием
- Используйте статический анализ (SAST) для выявления небезопасных функций

---

### 84. Какой анализ обнаружит деление на ноль в 100 / (a - b), если a == b?

**Ответ:** Следующие виды анализа могут обнаружить деление на ноль:

**1. Статический анализ (SAST) с символьным выполнением:**
```python
# Пример: анализ может обнаружить, что если a == b, то (a - b) == 0
# И обнаружить деление на ноль
result = 100 / (a - b)  # Если a == b, то деление на 0
```

**2. Статический анализ с анализом потока данных (Data Flow Analysis):**
- Отслеживание значений переменных `a` и `b`
- Определение, что в некоторых путях выполнения `a - b == 0`
- Обнаружение потенциального деления на ноль

**3. Статический анализ с анализом путей выполнения (Path Analysis):**
- Построение графа потока управления (CFG)
- Анализ всех путей выполнения
- Обнаружение путей, где `a == b` приводит к делению на ноль

**4. Статический анализ с абстрактной интерпретацией:**
- Абстрактное представление значений переменных
- Определение условий, при которых знаменатель равен нулю

**5. Символьное выполнение (Symbolic Execution):**
- Выполнение программы с символьными значениями вместо конкретных
- Решение ограничений: когда `a - b == 0`?
- Обнаружение деления на ноль

**6. Специализированные инструменты:**
- **PVS-Studio** — обнаруживает деление на ноль
- **Coverity** — анализ потока данных
- **Clang Static Analyzer** — обнаружение деления на ноль
- **Infer** (Facebook) — статический анализ с символьным выполнением
- **CodeQL** — запросы для поиска деления на ноль

**7. Тестирование (динамический анализ):**
```python
# Unit-тест
def test_division_by_zero():
    a = 5
    b = 5
    with pytest.raises(ZeroDivisionError):
        result = 100 / (a - b)
```

**Инструменты, которые обнаружат:**
- **PVS-Studio:** V609 Division or mod by zero
- **Clang Static Analyzer:** Division by zero
- **Infer:** Division by zero
- **CodeQL:** Division by zero query

---

### 85. Какой анализ обнаружит использование неинициализированной переменной?

**Ответ:** Следующие виды анализа могут обнаружить использование неинициализированной переменной:

**1. Статический анализ с анализом потока данных (Data Flow Analysis):**
```c
int x;  // Не инициализирована
if (condition) {
    x = 5;
}
int y = x;  // x может быть не инициализирована
```

**2. Статический анализ с анализом определений и использований (Def-Use Analysis):**
- Отслеживание определения (def) переменной
- Отслеживание использования (use) переменной
- Обнаружение использований без предшествующих определений

**3. Статический анализ с абстрактной интерпретацией:**
- Отслеживание состояния переменных (инициализирована/не инициализирована)
- Обнаружение использования переменной в неинициализированном состоянии

**4. Инструменты статического анализа:**
- **PVS-Studio:** V614 Uninitialized variable used
- **Clang Static Analyzer:** Uninitialized variable
- **GCC -Wuninitialized:** Предупреждение компилятора
- **Coverity:** Uninitialized variable defect
- **Infer:** Uninitialized variable
- **CodeQL:** Uninitialized variable query

**5. Динамический анализ с инструментированием:**
```c
// Использование AddressSanitizer (ASan) или Valgrind
// Обнаруживает использование неинициализированной памяти во время выполнения
```

**6. Компиляторы с предупреждениями:**
```bash
# GCC/Clang
gcc -Wall -Wuninitialized -O2 program.c
# Выдаст предупреждение об использовании неинициализированной переменной
```

**Пример обнаружения:**
```c
int x;
int y = x;  // Предупреждение: 'x' используется без инициализации
```

---

### 86. Какой анализ обнаружит утечку памяти в malloc() без free()?

**Ответ:** Следующие виды анализа могут обнаружить утечку памяти:

**1. Статический анализ с анализом выделения/освобождения памяти (Resource Leak Analysis):**
```c
void *ptr = malloc(100);
// Нет free(ptr) - утечка памяти
```

**2. Статический анализ с анализом парных операций (Pair Analysis):**
- Обнаружение парных операций: malloc/free, fopen/fclose, etc.
- Обнаружение случаев, когда выделение памяти не сопровождается освобождением

**3. Динамический анализ с инструментированием:**
- **Valgrind (Memcheck):** Обнаружение утечек памяти во время выполнения
- **AddressSanitizer (ASan):** Обнаружение утечек памяти
- **LeakSanitizer:** Специализированный инструмент для утечек

**4. Инструменты статического анализа:**
- **PVS-Studio:** V773 Memory leak
- **Coverity:** Resource leak
- **Clang Static Analyzer:** Memory leak
- **Infer:** Memory leak
- **CodeQL:** Memory leak query
- **Cppcheck:** Memory leak detection

**5. Специализированные инструменты:**
- **Dr. Memory:** Обнаружение утечек памяти
- **Application Verifier:** Для Windows
- **Purify:** Коммерческий инструмент

**Пример использования Valgrind:**
```bash
valgrind --leak-check=full ./program
# Вывод:
# ==12345== 100 bytes in 1 blocks are definitely lost
# ==12345==    at 0x4C2AB80: malloc (vg_replace_malloc.c:299)
```

**Пример использования AddressSanitizer:**
```bash
gcc -fsanitize=address -g program.c -o program
./program
# Вывод информации об утечках памяти
```

**Статический анализ может обнаружить:**
```c
void function() {
    void *ptr = malloc(100);
    // Выход из функции без free(ptr)
    // Статический анализатор предупредит о потенциальной утечке
}
```

---

### 87. Какой анализ нужен для поиска уязвимостей через вызовы функций в других модулях?

**Ответ:** Для поиска уязвимостей через вызовы функций в других модулях необходим **межпроцедурный анализ (Interprocedural Analysis, IPA)**.

**1. Межпроцедурный статический анализ:**
- Анализ вызовов функций через границы модулей
- Отслеживание потока данных через вызовы функций
- Анализ параметров функций и возвращаемых значений

**2. Межпроцедурный анализ потока данных (Interprocedural Data Flow Analysis):**
```c
// Модуль 1
void process_data(char *input) {
    // ...
}

// Модуль 2
void handle_request(char *user_input) {
    process_data(user_input);  // Нужно отследить поток данных
}
```

**3. Анализ межмодульных вызовов (Cross-Module Analysis):**
- Анализ вызовов между разными файлами/модулями
- Учёт экспортируемых и импортируемых функций
- Анализ связей между модулями

**4. Инструменты с межпроцедурным анализом:**
- **PVS-Studio:** Поддерживает межпроцедурный анализ
- **Coverity:** Глубокий межпроцедурный анализ
- **CodeSonar:** Межпроцедурный анализ для поиска уязвимостей
- **Klocwork:** Межпроцедурный анализ потока данных
- **Infer:** Межпроцедурный анализ
- **CodeQL:** Запросы с поддержкой межпроцедурного анализа

**5. Анализ точек входа (Entry Point Analysis):**
- Определение всех точек входа в программу
- Отслеживание путей от точек входа через вызовы функций
- Обнаружение уязвимостей на всех уровнях

**6. Анализ с использованием summary-функций:**
- Построение summary для каждой функции (что функция делает с параметрами)
- Использование summary для анализа вызывающих функций

**Пример:**
```c
// utils.c
void sanitize_input(char *input) {
    // Санитизация
}

// main.c
#include "utils.h"
void handle_request(char *user_input) {
    char *cleaned = sanitize_input(user_input);
    sql_query(cleaned);  // Нужно отследить, что cleaned безопасен
}
```

**Характеристики межпроцедурного анализа:**
- Более точный, но требует больше ресурсов
- Может анализировать всю программу целиком
- Важен для обнаружения сложных уязвимостей, проходящих через несколько функций

---

### 88. Какие меры нужно принять при загрузке файлов от пользователя?

**Ответ:** При загрузке файлов от пользователя необходимо применить следующие меры безопасности:

**1. Валидация типа файла:**
```python
import magic
import os

ALLOWED_MIME_TYPES = {'image/jpeg', 'image/png', 'application/pdf'}
ALLOWED_EXTENSIONS = {'.jpg', '.jpeg', '.png', '.pdf'}

def validate_file(file):
    # Проверка расширения
    filename = file.filename
    ext = os.path.splitext(filename)[1].lower()
    if ext not in ALLOWED_EXTENSIONS:
        raise ValueError("Invalid file extension")
    
    # Проверка MIME-типа по содержимому (не по расширению!)
    file_content = file.read()
    file.seek(0)  # Сброс указателя
    
    mime_type = magic.from_buffer(file_content, mime=True)
    if mime_type not in ALLOWED_MIME_TYPES:
        raise ValueError("Invalid file type")
    
    # Дополнительная проверка сигнатур файлов (magic bytes)
    if ext == '.jpg' and not file_content.startswith(b'\xff\xd8\xff'):
        raise ValueError("Invalid JPEG file")
    
    return True
```

**2. Ограничение размера файла:**
```python
MAX_FILE_SIZE = 10 * 1024 * 1024  # 10 MB

def validate_file_size(file):
    file.seek(0, os.SEEK_END)
    size = file.tell()
    file.seek(0)
    
    if size > MAX_FILE_SIZE:
        raise ValueError("File too large")
    
    if size == 0:
        raise ValueError("Empty file")
```

**3. Безопасное имя файла:**
```python
from werkzeug.utils import secure_filename
import uuid

def get_safe_filename(original_filename):
    # Генерация безопасного имени файла
    # Вариант 1: Использование UUID
    ext = os.path.splitext(original_filename)[1]
    return str(uuid.uuid4()) + ext
    
    # Вариант 2: Санитизация оригинального имени
    # return secure_filename(original_filename)
```

**4. Проверка на вредоносное содержимое:**
```python
import subprocess

def scan_for_viruses(filepath):
    # Использование антивируса (ClamAV и т.д.)
    result = subprocess.run(['clamscan', filepath], 
                          capture_output=True)
    if result.returncode != 0:
        raise ValueError("File contains malware")
```

**5. Изоляция загруженных файлов:**
```python
import os
from pathlib import Path

# Отдельная директория вне веб-корня
UPLOAD_DIR = Path("/var/uploads")
UPLOAD_DIR.mkdir(exist_ok=True)

# Ограничение прав доступа
os.chmod(UPLOAD_DIR, 0o700)

def save_file(file, filename):
    filepath = UPLOAD_DIR / filename
    
    # Проверка, что файл сохраняется в разрешённой директории
    try:
        filepath.resolve().relative_to(UPLOAD_DIR.resolve())
    except ValueError:
        raise ValueError("Invalid path")
    
    with open(filepath, 'wb') as f:
        f.write(file.read())
    
    # Установка безопасных прав
    os.chmod(filepath, 0o644)
```

**6. Сканирование изображений (для изображений):**
```python
from PIL import Image

def validate_image(file):
    try:
        img = Image.open(file)
        img.verify()  # Верификация целостности
        
        # Пересоздание изображения для удаления метаданных
        img = Image.open(file)
        # Сохранение без метаданных
        img.save(output_path, format='JPEG', quality=85)
    except Exception:
        raise ValueError("Invalid image")
```

**7. Ограничение доступа к загруженным файлам:**
```python
# Предоставление доступа через контролируемый endpoint
@app.route('/download/<file_id>')
def download_file(file_id):
    # Валидация file_id
    if not re.match(r'^[a-f0-9-]{36}$', file_id):
        abort(400)
    
    filepath = UPLOAD_DIR / file_id
    
    # Проверка существования
    if not filepath.exists():
        abort(404)
    
    # Проверка прав доступа пользователя
    if not user_has_access(request.user, file_id):
        abort(403)
    
    # Безопасная отдача файла
    return send_file(filepath, as_attachment=True)
```

**8. Логирование загрузок:**
```python
import logging

def log_file_upload(user, filename, file_size):
    logging.info(f"File upload: user={user}, filename={filename}, size={file_size}")
```

**9. Quarantine (карантин) подозрительных файлов:**
```python
QUARANTINE_DIR = Path("/var/quarantine")

def quarantine_file(filepath):
    # Перемещение в карантин для дальнейшего анализа
    quarantine_path = QUARANTINE_DIR / filepath.name
    shutil.move(filepath, quarantine_path)
```

**10. Проверка на двойные расширения:**
```python
def check_double_extension(filename):
    # Запрет файлов типа "file.jpg.exe"
    parts = filename.rsplit('.', 2)
    if len(parts) == 3:
        raise ValueError("Double extension not allowed")
```

**Итоговый пример:**
```python
@app.route('/upload', methods=['POST'])
def upload_file():
    if 'file' not in request.files:
        return "No file", 400
    
    file = request.files['file']
    
    # Валидация
    validate_file(file)
    validate_file_size(file)
    
    # Безопасное имя
    safe_filename = get_safe_filename(file.filename)
    
    # Сканирование
    scan_for_viruses(file)
    
    # Сохранение
    filepath = save_file(file, safe_filename)
    
    # Логирование
    log_file_upload(current_user, safe_filename, file.size)
    
    return {"file_id": safe_filename}, 200
```

---

### 89. Какой код соответствует безопасному паттерну «claim check»?

**Ответ:** Паттерн **"Claim Check"** (чек-квитанция) используется для передачи больших данных через промежуточную систему, передавая только идентификатор (чек) вместо самих данных.

**Безопасная реализация паттерна:**

```python
import uuid
import hashlib
import redis
from cryptography.fernet import Fernet

# Хранилище данных (Redis, база данных, объектное хранилище)
storage = redis.Redis()

class ClaimCheckService:
    def __init__(self):
        self.cipher = Fernet(Fernet.generate_key())
    
    def store_data(self, data: bytes) -> str:
        """Сохраняет данные и возвращает claim check (ID)"""
        # Генерация уникального ID
        claim_id = str(uuid.uuid4())
        
        # Шифрование данных перед сохранением
        encrypted_data = self.cipher.encrypt(data)
        
        # Сохранение в безопасном хранилище
        storage.setex(
            f"claim:{claim_id}",
            ttl=3600,  # TTL для автоматического удаления
            value=encrypted_data
        )
        
        return claim_id
    
    def retrieve_data(self, claim_id: str) -> bytes:
        """Извлекает данные по claim check"""
        # Валидация claim_id (только UUID)
        if not re.match(r'^[a-f0-9-]{36}$', claim_id):
            raise ValueError("Invalid claim ID")
        
        # Извлечение данных
        encrypted_data = storage.get(f"claim:{claim_id}")
        if not encrypted_data:
            raise ValueError("Claim check not found or expired")
        
        # Расшифровка
        data = self.cipher.decrypt(encrypted_data)
        
        # Удаление после использования (опционально)
        storage.delete(f"claim:{claim_id}")
        
        return data

# Использование
service = ClaimCheckService()

# Отправитель: сохраняет большие данные
large_data = b"Very large data..." * 10000
claim_id = service.store_data(large_data)

# Передача только claim_id через очередь сообщений
message_queue.send({
    "claim_id": claim_id,
    "metadata": {...}
})

# Получатель: извлекает данные по claim_id
message = message_queue.receive()
data = service.retrieve_data(message["claim_id"])
```

**Безопасные особенности реализации:**
1. **Уникальный идентификатор** — UUID, который сложно угадать
2. **Валидация claim_id** — проверка формата перед использованием
3. **Шифрование данных** — данные шифруются перед сохранением
4. **TTL (Time To Live)** — автоматическое удаление через определённое время
5. **Одноразовое использование** — удаление после извлечения (опционально)
6. **Изоляция хранилища** — отдельное хранилище, не доступное напрямую

**Пример использования в очереди сообщений:**
```python
# Вместо передачи больших данных напрямую
# message = {"data": large_data}  # Неэффективно

# Передаём только claim check
message = {"claim_id": claim_id}  # Эффективно и безопасно
```

---

### 90. Какой код соответствует безопасному паттерну «Valet Key»?

**Ответ:** Паттерн **"Valet Key" (Ключ валета)** предоставляет временный, ограниченный доступ к ресурсу (например, облачному хранилищу) вместо постоянных полных прав.

**Безопасная реализация паттерна:**

```python
import boto3
from datetime import datetime, timedelta
from botocore.config import Config

class ValetKeyService:
    def __init__(self):
        self.s3_client = boto3.client('s3')
    
    def generate_valet_key(self, 
                          bucket: str, 
                          object_key: str,
                          user_id: str,
                          allowed_operations: list = ['GET']) -> dict:
        """Генерирует временный ключ доступа (SAS token)"""
        
        # Параметры доступа
        expiration = datetime.utcnow() + timedelta(hours=1)  # Короткий срок
        
        # Ограничения доступа
        conditions = [
            {'bucket': bucket},
            {'key': object_key},
        ]
        
        # Генерация предварительно подписанного URL (Presigned URL)
        presigned_url = self.s3_client.generate_presigned_url(
            'get_object' if 'GET' in allowed_operations else 'put_object',
            Params={
                'Bucket': bucket,
                'Key': object_key,
            },
            ExpiresIn=3600,  # 1 час
            HttpMethod='GET' if 'GET' in allowed_operations else 'PUT'
        )
        
        # Дополнительные ограничения
        valet_key = {
            'url': presigned_url,
            'expires_at': expiration.isoformat(),
            'bucket': bucket,
            'object_key': object_key,
            'allowed_operations': allowed_operations,
            'user_id': user_id
        }
        
        return valet_key
    
    def validate_valet_key(self, valet_key: dict) -> bool:
        """Валидирует valet key перед использованием"""
        expires_at = datetime.fromisoformat(valet_key['expires_at'])
        
        if datetime.utcnow() > expires_at:
            return False  # Ключ истёк
        
        return True

# Использование
service = ValetKeyService()

# Генерация временного ключа для пользователя
valet_key = service.generate_valet_key(
    bucket='user-uploads',
    object_key=f'user123/document.pdf',
    user_id='user123',
    allowed_operations=['GET']  # Только чтение
)

# Передача ключа пользователю
# Пользователь может загрузить файл напрямую в S3, используя этот ключ
return {"download_url": valet_key['url'], "expires_in": 3600}
```

**Для Azure Blob Storage:**
```python
from azure.storage.blob import BlobServiceClient, generate_blob_sas
from azure.storage.blob import BlobSasPermissions
from datetime import datetime, timedelta

def generate_azure_valet_key(account_name, container_name, blob_name):
    # Генерация SAS (Shared Access Signature) токена
    sas_token = generate_blob_sas(
        account_name=account_name,
        container_name=container_name,
        blob_name=blob_name,
        account_key=account_key,
        permission=BlobSasPermissions(read=True),  # Только чтение
        expiry=datetime.utcnow() + timedelta(hours=1)
    )
    
    # Формирование URL с SAS токеном
    blob_url = f"https://{account_name}.blob.core.windows.net/{container_name}/{blob_name}?{sas_token}"
    
    return blob_url
```

**Безопасные особенности:**
1. **Временный доступ** — ключ действителен только ограниченное время
2. **Ограниченные права** — только необходимые операции (read, write)
3. **Ограничение ресурсов** — доступ только к конкретному объекту/контейнеру
4. **Отзыв доступа** — невозможно отозвать без изменения политики хранилища
5. **Логирование** — все обращения логируются облачным провайдером

**Преимущества:**
- Не нужно хранить постоянные ключи на клиенте
- Минимизация ущерба при компрометации ключа
- Прямая загрузка в облако без нагрузки на сервер

---

### 91. Какой код нарушает принцип «минимизации поверхности атаки»?

**Ответ:** Принцип **"минимизации поверхности атаки"** нарушается, когда система предоставляет избыточные функции, интерфейсы или возможности, которые не используются, но могут быть атакованы.

**Примеры кода, нарушающего принцип:**

**1. Неиспользуемые эндпоинты API:**
```python
# ПЛОХО: Открыты все эндпоинты, включая административные
@app.route('/admin/users', methods=['GET', 'POST', 'PUT', 'DELETE'])
def admin_users():
    # Административный функционал доступен всем
    pass

@app.route('/debug/info')
def debug_info():
    # Отладочная информация доступна в production
    return {"internal_state": get_internal_state()}

@app.route('/api/v1/users', methods=['GET', 'POST', 'PUT', 'DELETE', 'PATCH'])
def users_v1():
    # Старая версия API всё ещё доступна
    pass

@app.route('/api/v2/users', methods=['GET', 'POST'])
def users_v2():
    # Новая версия
    pass
```

**2. Избыточные методы HTTP:**
```python
# ПЛОХО: Разрешены все HTTP-методы, включая неиспользуемые
@app.route('/users/<id>', methods=['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS', 'HEAD', 'TRACE'])
def users(id):
    # TRACE может использоваться для XST-атак
    pass
```

**3. Ненужные заголовки и информация:**
```python
# ПЛОХО: Раскрытие информации о версиях и технологиях
@app.after_request
def add_headers(response):
    response.headers['Server'] = 'Apache/2.4.41 (Unix)'  # Раскрытие версии
    response.headers['X-Powered-By'] = 'PHP/7.4.3'  # Раскрытие технологий
    response.headers['X-Framework'] = 'Django/3.2'  # Раскрытие фреймворка
    return response
```

**4. Открытые отладочные интерфейсы:**
```python
# ПЛОХО: Отладка включена в production
if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0')  # Отладка и открытый доступ
```

**5. Неиспользуемые импорты и функции:**
```python
# ПЛОХО: Импортированы небезопасные функции, которые не используются
import os
import subprocess
import eval
import exec

# Но они доступны для случайного использования
```

**6. Избыточные зависимости:**
```python
# requirements.txt
# ПЛОХО: Много неиспользуемых зависимостей с известными уязвимостями
flask==2.0.0
django==3.2.0  # Не используется, но установлен
old-vulnerable-library==1.0.0  # Уязвимая библиотека
```

**7. Неограниченные входные точки:**
```python
# ПЛОХО: Принимает данные из любых источников без валидации
@app.route('/process', methods=['POST'])
def process():
    data = request.json  # Без валидации источника
    # Обработка данных
    pass
```

**Безопасный код (минимизация поверхности атаки):**
```python
# ХОРОШО: Только необходимые эндпоинты
@app.route('/api/v2/users', methods=['GET', 'POST'])  # Только нужные методы
@require_auth  # Требуется аутентификация
def users():
    pass

# ХОРОШО: Отладочная информация отключена в production
if __name__ == '__main__':
    app.run(debug=os.getenv('DEBUG', 'False') == 'True', host='127.0.0.1')

# ХОРОШО: Минимальные заголовки
@app.after_request
def add_headers(response):
    # Не раскрываем информацию о технологиях
    response.headers.pop('X-Powered-By', None)
    return response

# ХОРОШО: Только используемые методы
@app.route('/users/<id>', methods=['GET', 'PUT'])  # Только необходимые
def user(id):
    pass
```

---

### 92. Как правильно реализовать rate limiting на gateway?

**Ответ:** Правильная реализация **rate limiting** на gateway должна ограничивать количество запросов от клиента для предотвращения злоупотреблений и DDoS-атак.

**1. Использование Redis для хранения счётчиков (Token Bucket):**
```python
import redis
import time
from functools import wraps

redis_client = redis.Redis()

class RateLimiter:
    def __init__(self, requests_per_minute=60, requests_per_hour=1000):
        self.requests_per_minute = requests_per_minute
        self.requests_per_hour = requests_per_hour
    
    def is_allowed(self, identifier: str) -> tuple[bool, dict]:
        """Проверяет, разрешён ли запрос"""
        now = time.time()
        minute_key = f"rate_limit:minute:{identifier}"
        hour_key = f"rate_limit:hour:{identifier}"
        
        # Счётчик запросов за минуту
        minute_count = redis_client.incr(minute_key)
        if minute_count == 1:
            redis_client.expire(minute_key, 60)
        
        # Счётчик запросов за час
        hour_count = redis_client.incr(hour_key)
        if hour_count == 1:
            redis_client.expire(hour_key, 3600)
        
        # Проверка лимитов
        allowed = (minute_count <= self.requests_per_minute and 
                  hour_count <= self.requests_per_hour)
        
        info = {
            'minute_remaining': max(0, self.requests_per_minute - minute_count),
            'hour_remaining': max(0, self.requests_per_hour - hour_count),
            'retry_after': 60 if minute_count > self.requests_per_minute else None
        }
        
        return allowed, info

limiter = RateLimiter(requests_per_minute=60, requests_per_hour=1000)

def rate_limit_decorator(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        # Идентификация клиента (IP, API key, user ID)
        identifier = request.remote_addr  # Или request.headers.get('X-API-Key')
        
        allowed, info = limiter.is_allowed(identifier)
        
        if not allowed:
            response = make_response("Rate limit exceeded", 429)
            response.headers['X-RateLimit-Limit'] = str(limiter.requests_per_minute)
            response.headers['X-RateLimit-Remaining'] = str(info['minute_remaining'])
            if info['retry_after']:
                response.headers['Retry-After'] = str(info['retry_after'])
            return response
        
        response = f(*args, **kwargs)
        response.headers['X-RateLimit-Limit'] = str(limiter.requests_per_minute)
        response.headers['X-RateLimit-Remaining'] = str(info['minute_remaining'])
        return response
    
    return decorated_function

@app.route('/api/data')
@rate_limit_decorator
def get_data():
    return {"data": "..."}
```

**2. Использование алгоритма Sliding Window:**
```python
class SlidingWindowRateLimiter:
    def __init__(self, max_requests: int, window_seconds: int):
        self.max_requests = max_requests
        self.window_seconds = window_seconds
    
    def is_allowed(self, identifier: str) -> bool:
        now = time.time()
        window_start = now - self.window_seconds
        
        # Удаление старых запросов
        key = f"rate_limit:sliding:{identifier}"
        redis_client.zremrangebyscore(key, 0, window_start)
        
        # Подсчёт текущих запросов
        current_count = redis_client.zcard(key)
        
        if current_count < self.max_requests:
            # Добавление текущего запроса
            redis_client.zadd(key, {str(now): now})
            redis_client.expire(key, self.window_seconds)
            return True
        
        return False
```

**3. Использование готовых решений (Nginx, API Gateway):**
```nginx
# Nginx rate limiting
limit_req_zone $binary_remote_addr zone=api_limit:10m rate=10r/s;

server {
    location /api/ {
        limit_req zone=api_limit burst=20 nodelay;
        proxy_pass http://backend;
    }
}
```

**4. Использование специализированных gateway (Kong, Ambassador):**
```yaml
# Kong rate limiting plugin
plugins:
- name: rate-limiting
  config:
    minute: 100
    hour: 1000
    policy: redis
    redis:
      host: redis
      port: 6379
```

**5. Многоуровневый rate limiting:**
```python
class MultiLevelRateLimiter:
    def __init__(self):
        self.limiters = {
            'global': RateLimiter(10000, 100000),  # Глобальный лимит
            'per_ip': RateLimiter(60, 1000),       # На IP
            'per_user': RateLimiter(100, 5000),    # На пользователя
        }
    
    def is_allowed(self, ip: str, user_id: str = None) -> bool:
        # Проверка всех уровней
        if not self.limiters['global'].is_allowed('global')[0]:
            return False
        
        if not self.limiters['per_ip'].is_allowed(ip)[0]:
            return False
        
        if user_id and not self.limiters['per_user'].is_allowed(user_id)[0]:
            return False
        
        return True
```

**6. Rate limiting с приоритетами:**
```python
class PriorityRateLimiter:
    def __init__(self):
        self.limits = {
            'premium': RateLimiter(1000, 10000),
            'standard': RateLimiter(100, 1000),
            'free': RateLimiter(10, 100),
        }
    
    def is_allowed(self, identifier: str, tier: str = 'free') -> bool:
        limiter = self.limits.get(tier, self.limits['free'])
        return limiter.is_allowed(identifier)[0]
```

**Рекомендации:**
- Использовать Redis для распределённого rate limiting
- Применять разные лимиты для разных типов клиентов
- Возвращать информативные заголовки (X-RateLimit-*)
- Логировать превышения лимитов для анализа
- Использовать graceful degradation вместо полного блокирования

---

### 93. Как реализуется федеративная аутентификация?

**Ответ:** **Федеративная аутентификация (Federated Authentication)** позволяет пользователям аутентифицироваться через внешнего провайдера удостоверений (IdP), вместо хранения учётных данных в приложении.

**Реализация с использованием OAuth 2.0 / OpenID Connect:**

```python
from flask import Flask, redirect, request, session
import requests
import jwt

app = Flask(__name__)
app.secret_key = 'secret'

# Конфигурация OAuth провайдера (Google, Microsoft, Okta и т.д.)
OAUTH_CONFIG = {
    'client_id': 'your-client-id',
    'client_secret': 'your-client-secret',
    'authorization_endpoint': 'https://accounts.google.com/o/oauth2/auth',
    'token_endpoint': 'https://oauth2.googleapis.com/token',
    'userinfo_endpoint': 'https://www.googleapis.com/oauth2/v3/userinfo',
    'redirect_uri': 'http://localhost:5000/callback',
    'scopes': 'openid email profile'
}

@app.route('/login')
def login():
    # Редирект на провайдера для аутентификации
    auth_url = (
        f"{OAUTH_CONFIG['authorization_endpoint']}?"
        f"client_id={OAUTH_CONFIG['client_id']}&"
        f"redirect_uri={OAUTH_CONFIG['redirect_uri']}&"
        f"response_type=code&"
        f"scope={OAUTH_CONFIG['scopes']}&"
        f"state={generate_state()}"  # CSRF защита
    )
    return redirect(auth_url)

@app.route('/callback')
def callback():
    # Получение authorization code
    code = request.args.get('code')
    state = request.args.get('state')
    
    # Проверка state (CSRF защита)
    if state != session.get('oauth_state'):
        return "Invalid state", 400
    
    # Обмен code на access token
    token_response = requests.post(
        OAUTH_CONFIG['token_endpoint'],
        data={
            'code': code,
            'client_id': OAUTH_CONFIG['client_id'],
            'client_secret': OAUTH_CONFIG['client_secret'],
            'redirect_uri': OAUTH_CONFIG['redirect_uri'],
            'grant_type': 'authorization_code'
        }
    )
    
    tokens = token_response.json()
    access_token = tokens['access_token']
    id_token = tokens.get('id_token')
    
    # Верификация ID token (JWT)
    if id_token:
        decoded = jwt.decode(
            id_token,
            # Получение публичного ключа для проверки подписи
            verify=False  # В реальности нужно проверить подпись
        )
        user_info = decoded
    else:
        # Получение информации о пользователе
        user_response = requests.get(
            OAUTH_CONFIG['userinfo_endpoint'],
            headers={'Authorization': f'Bearer {access_token}'}
        )
        user_info = user_response.json()
    
    # Сохранение сессии пользователя
    session['user'] = {
        'email': user_info.get('email'),
        'name': user_info.get('name'),
        'sub': user_info.get('sub')  # Уникальный идентификатор
    }
    
    return redirect('/dashboard')
```

**Реализация с использованием SAML 2.0:**

```python
from onelogin.saml2.auth import OneLogin_Saml2_Auth
from flask import Flask, request, redirect, session

app = Flask(__name__)

def init_saml_auth(req):
    auth = OneLogin_Saml2_Auth(req, custom_base_path='/path/to/saml')
    return auth

@app.route('/sso/saml')
def saml():
    req = prepare_flask_request(request)
    auth = init_saml_auth(req)
    return redirect(auth.login())

@app.route('/sso/saml/acs', methods=['POST'])
def acs():
    req = prepare_flask_request(request)
    auth = init_saml_auth(req)
    auth.process_response()
    
    if auth.is_authenticated():
        session['user'] = auth.get_attributes()
        return redirect('/dashboard')
    else:
        return "Authentication failed", 403
```

**Безопасные практики:**
1. **Проверка подписи токенов** — всегда проверяйте подпись JWT/SAML
2. **Проверка issuer и audience** — убедитесь, что токен от правильного провайдера
3. **CSRF защита** — использование state parameter в OAuth
4. **HTTPS обязателен** — все коммуникации должны быть зашифрованы
5. **Проверка срока действия токенов** — проверяйте exp и nbf claims
6. **Хранение секретов** — храните client_secret в безопасном месте

---

### 94. Какой код реализует безопасную валидацию входных данных по allowlist?

**Ответ:** Безопасная валидация по **allowlist** (белый список) разрешает только определённые, известные безопасные значения.

**Пример безопасной валидации:**

```python
import re
from enum import Enum

# 1. Валидация по фиксированному списку значений
class UserRole(str, Enum):
    ADMIN = "admin"
    USER = "user"
    GUEST = "guest"

def validate_role(role: str) -> str:
    """Валидация роли по allowlist"""
    if role not in [r.value for r in UserRole]:
        raise ValueError(f"Invalid role: {role}")
    return role

# 2. Валидация строк по паттерну (allowlist символов)
def validate_username(username: str) -> str:
    """Валидация имени пользователя: только буквы, цифры, подчёркивания"""
    # Allowlist: только [a-zA-Z0-9_], длина 3-20
    if not re.match(r'^[a-zA-Z0-9_]{3,20}$', username):
        raise ValueError("Username must contain only letters, numbers, and underscores, 3-20 characters")
    return username

# 3. Валидация файловых расширений
ALLOWED_EXTENSIONS = {'.jpg', '.jpeg', '.png', '.pdf', '.txt'}

def validate_filename(filename: str) -> str:
    """Валидация имени файла по allowlist расширений"""
    ext = os.path.splitext(filename)[1].lower()
    if ext not in ALLOWED_EXTENSIONS:
        raise ValueError(f"File extension not allowed: {ext}")
    return filename

# 4. Валидация HTTP методов
ALLOWED_METHODS = {'GET', 'POST', 'PUT', 'DELETE'}

def validate_http_method(method: str) -> str:
    """Валидация HTTP метода"""
    method = method.upper()
    if method not in ALLOWED_METHODS:
        raise ValueError(f"HTTP method not allowed: {method}")
    return method

# 5. Валидация URL (whitelist доменов)
ALLOWED_DOMAINS = {'example.com', 'trusted-site.com'}

def validate_url(url: str) -> str:
    """Валидация URL по allowlist доменов"""
    from urllib.parse import urlparse
    parsed = urlparse(url)
    
    if parsed.netloc not in ALLOWED_DOMAINS:
        raise ValueError(f"Domain not allowed: {parsed.netloc}")
    
    # Дополнительная проверка протокола
    if parsed.scheme not in {'http', 'https'}:
        raise ValueError(f"Protocol not allowed: {parsed.scheme}")
    
    return url

# 6. Валидация цвета (hex)
def validate_color(color: str) -> str:
    """Валидация цвета в формате hex (#RRGGBB)"""
    if not re.match(r'^#[0-9A-Fa-f]{6}$', color):
        raise ValueError("Color must be in format #RRGGBB")
    return color.upper()

# 7. Валидация по регулярному выражению (строгий паттерн)
def validate_email(email: str) -> str:
    """Валидация email по строгому паттерну"""
    # Строгий allowlist паттерн для email
    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(pattern, email):
        raise ValueError("Invalid email format")
    return email.lower()

# 8. Валидация ID (UUID)
def validate_uuid(uuid_str: str) -> str:
    """Валидация UUID"""
    uuid_pattern = r'^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$'
    if not re.match(uuid_pattern, uuid_str, re.IGNORECASE):
        raise ValueError("Invalid UUID format")
    return uuid_str.lower()

# 9. Комплексная валидация с использованием библиотеки
from marshmallow import Schema, fields, validate, ValidationError

class UserSchema(Schema):
    username = fields.Str(
        required=True,
        validate=validate.Regexp(r'^[a-zA-Z0-9_]{3,20}$')
    )
    email = fields.Email(required=True)
    role = fields.Str(
        required=True,
        validate=validate.OneOf(['admin', 'user', 'guest'])
    )
    age = fields.Int(
        required=True,
        validate=validate.Range(min=18, max=120)
    )

def validate_user_data(data: dict) -> dict:
    """Валидация данных пользователя"""
    schema = UserSchema()
    try:
        return schema.load(data)
    except ValidationError as err:
        raise ValueError(err.messages)

# Использование
try:
    user_data = validate_user_data({
        'username': 'john_doe',
        'email': 'john@example.com',
        'role': 'user',
        'age': 25
    })
except ValueError as e:
    print(f"Validation error: {e}")
```

**Принципы безопасной валидации по allowlist:**
1. **Определите точно, что разрешено** — создайте явный список разрешённых значений
2. **Отклоняйте всё остальное** — если значение не в allowlist, отклоняйте его
3. **Нормализуйте данные** — приводите к единому формату (lowercase, trim и т.д.)
4. **Используйте строгие регулярные выражения** — не используйте `.*` или широкие паттерны
5. **Валидируйте на стороне сервера** — не полагайтесь только на клиентскую валидацию

---

### 95. Какой код демонстрирует анти-паттерн «hardcoded credentials»?

**Ответ:** Анти-паттерн **"hardcoded credentials" (хардкод учётных данных, CWE-798)** — это встраивание паролей, ключей и других секретов непосредственно в исходный код.

**Примеры небезопасного кода:**

**1. Хардкод паролей:**
```python
# ПЛОХО: Пароль в коде
DATABASE_PASSWORD = "MySecretPassword123!"
db = connect("localhost", "admin", DATABASE_PASSWORD)

# ПЛОХО: Пароль в строке подключения
connection_string = "postgresql://user:password123@localhost/db"
```

**2. Хардкод API ключей:**
```python
# ПЛОХО: API ключ в коде
API_KEY = "sk_live_51AbCdEfGhIjKlMnOpQrStUvWxYz"
response = requests.get("https://api.example.com/data", 
                       headers={"Authorization": f"Bearer {API_KEY}"})

# ПЛОХО: Ключ доступа AWS
AWS_ACCESS_KEY_ID = "AKIAIOSFODNN7EXAMPLE"
AWS_SECRET_ACCESS_KEY = "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY"
```

**3. Хардкод токенов:**
```python
# ПЛОХО: JWT токен в коде
TOKEN = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
headers = {"Authorization": f"Bearer {TOKEN}"}
```

**4. Хардкод в конфигурационных файлах:**
```python
# config.py - ПЛОХО
DATABASE = {
    'host': 'localhost',
    'user': 'admin',
    'password': 'super_secret_password'  # В открытом виде
}

# settings.json - ПЛОХО
{
    "api_key": "secret_api_key_12345",
    "database_password": "db_pass"
}
```

**5. Хардкод в комментариях:**
```python
# ПЛОХО: Секреты в комментариях
# Для тестирования используйте: admin / TestPassword123
# API Key: sk_test_1234567890abcdef
```

**6. Хардкод в Docker-образах:**
```dockerfile
# Dockerfile - ПЛОХО
ENV DB_PASSWORD=my_secret_password
ENV API_KEY=secret_key_12345
```

**Безопасные альтернативы:**

**1. Использование переменных окружения:**
```python
# ХОРОШО: Использование переменных окружения
import os

DATABASE_PASSWORD = os.getenv('DATABASE_PASSWORD')
if not DATABASE_PASSWORD:
    raise ValueError("DATABASE_PASSWORD environment variable not set")

db = connect("localhost", "admin", DATABASE_PASSWORD)
```

**2. Использование файлов с секретами (не в репозитории):**
```python
# ХОРОШО: Чтение из файла, который не в git
import json

with open('/etc/app/secrets.json', 'r') as f:
    secrets = json.load(f)

DATABASE_PASSWORD = secrets['database_password']
```

**3. Использование систем управления секретами:**
```python
# ХОРОШО: Использование HashiCorp Vault
import hvac

client = hvac.Client(url='http://vault:8200')
client.token = os.getenv('VAULT_TOKEN')

secret = client.secrets.kv.v2.read_secret_version(path='database')
DATABASE_PASSWORD = secret['data']['data']['password']
```

```python
# ХОРОШО: Использование AWS Secrets Manager
import boto3
import json

secrets_client = boto3.client('secretsmanager')
secret = secrets_client.get_secret_value(SecretId='database/password')
DATABASE_PASSWORD = json.loads(secret['SecretString'])['password']
```

**4. Использование .env файлов (не в git):**
```python
# .env (не в git)
DATABASE_PASSWORD=my_secret_password
API_KEY=secret_key

# config.py
from dotenv import load_dotenv
load_dotenv()

DATABASE_PASSWORD = os.getenv('DATABASE_PASSWORD')
```

**5. Использование Docker secrets:**
```dockerfile
# Dockerfile - ХОРОШО
# Секреты передаются через docker secrets, не хардкодятся
```

**6. Использование Kubernetes secrets:**
```yaml
# secret.yaml (зашифрован)
apiVersion: v1
kind: Secret
metadata:
  name: db-secret
data:
  password: <base64-encoded-password>
```

**Рекомендации:**
- Никогда не коммитьте секреты в git
- Используйте `.gitignore` для исключения файлов с секретами
- Используйте переменные окружения или системы управления секретами
- Ротируйте секреты регулярно
- Используйте статический анализ для поиска хардкод секретов в коде

---

### 96. Какой тип уязвимости реализуется в коде: header("Location: " . $_GET['url'])?

**Ответ:** В данном коде присутствует уязвимость **Open Redirect (CWE-601)** — открытое перенаправление.

**Проблема:** Пользовательский ввод из `$_GET['url']` напрямую используется для HTTP-заголовка `Location` без валидации, что позволяет злоумышленнику перенаправить пользователя на произвольный сайт.

**Пример атаки:**
```php
// Злонамеренный запрос
// /redirect.php?url=http://evil.com/phishing

header("Location: " . $_GET['url']);
// Пользователь будет перенаправлен на evil.com
```

**Безопасное исправление (whitelist разрешённых URL):**
```php
<?php
// Whitelist разрешённых доменов
$allowed_domains = [
    'example.com',
    'trusted-partner.com'
];

function safe_redirect($url) {
    global $allowed_domains;
    
    // Парсинг URL
    $parsed = parse_url($url);
    
    // Проверка схемы
    if (!in_array($parsed['scheme'], ['http', 'https'])) {
        die("Invalid scheme");
    }
    
    // Проверка домена по whitelist
    if (!in_array($parsed['host'], $allowed_domains)) {
        die("Domain not allowed");
    }
    
    header("Location: " . $url);
    exit();
}

// Использование
$url = $_GET['url'] ?? 'https://example.com';
safe_redirect($url);
```

**Альтернативное исправление (использование ID вместо URL):**
```php
<?php
// Маппинг ID на разрешённые URL
$redirect_map = [
    'home' => 'https://example.com/home',
    'login' => 'https://example.com/login',
    'dashboard' => 'https://example.com/dashboard'
];

$redirect_id = $_GET['id'] ?? 'home';

if (!isset($redirect_map[$redirect_id])) {
    die("Invalid redirect ID");
}

header("Location: " . $redirect_map[$redirect_id]);
exit();
```

**Дополнительные меры защиты:**
```php
<?php
function safe_redirect($url, $allowed_domains) {
    $parsed = parse_url($url);
    
    // Валидация
    if (!$parsed || !isset($parsed['host'])) {
        die("Invalid URL");
    }
    
    // Проверка whitelist
    if (!in_array($parsed['host'], $allowed_domains)) {
        die("Domain not allowed");
    }
    
    // Проверка на фишинг (не разрешать похожие домены)
    foreach ($allowed_domains as $domain) {
        if (strpos($parsed['host'], $domain) !== false && 
            $parsed['host'] !== $domain) {
            die("Suspicious domain");
        }
    }
    
    // Использование относительных путей для внутренних редиректов
    if ($parsed['host'] === $_SERVER['HTTP_HOST']) {
        header("Location: " . $parsed['path']);
    } else {
        header("Location: " . $url);
    }
    exit();
}
```

---

### 97. Какой вариант кода уязвим к удалённому выполнению кода (RCE)?

**Ответ:** Уязвимость **RCE (Remote Code Execution, CWE-94)** возникает, когда злоумышленник может выполнить произвольный код на сервере.

**Примеры уязвимого кода:**

**1. Использование eval() с пользовательским вводом:**
```python
# УЯЗВИМО
code = request.args.get('code')
result = eval(code)  # Выполнит любой Python код
# Атака: ?code=__import__('os').system('rm -rf /')
```

**2. Использование exec():**
```python
# УЯЗВИМО
user_input = request.form.get('command')
exec(user_input)  # Выполнит любой код
```

**3. Использование os.system() с пользовательским вводом:**
```python
# УЯЗВИМО
filename = request.args.get('file')
os.system(f"cat {filename}")  # Command injection
# Атака: ?file=/etc/passwd; rm -rf /
```

**4. Десериализация небезопасных данных:**
```python
# УЯЗВИМО
import pickle
data = request.data
obj = pickle.loads(data)  # Может выполнить код при десериализации
```

**5. Использование subprocess с shell=True:**
```python
# УЯЗВИМО
user_input = request.args.get('cmd')
subprocess.run(f"echo {user_input}", shell=True)  # Command injection
```

**6. Использование шаблонизатора с выполнением кода:**
```python
# УЯЗВИМО - если шаблонизатор выполняет код
template = request.args.get('template')
render_template(template)  # Может выполнить код, если template содержит код
```

**7. Использование __import__() с пользовательским вводом:**
```python
# УЯЗВИМО
module_name = request.args.get('module')
module = __import__(module_name)  # Может импортировать любой модуль
```

**8. PHP: использование eval(), exec(), system():**
```php
<?php
// УЯЗВИМО
$code = $_GET['code'];
eval($code);  // Выполнит любой PHP код

// УЯЗВИМО
$cmd = $_GET['cmd'];
exec($cmd);  // Выполнит системную команду

// УЯЗВИМО
$file = $_GET['file'];
include($file);  // Может включить любой файл (LFI/RFI)
?>
```

**Безопасные альтернативы:**

```python
# БЕЗОПАСНО: Никогда не выполняйте пользовательский код
# Вместо eval() используйте безопасные альтернативы

# 1. Параметризованные запросы вместо построения кода
cursor.execute("SELECT * FROM users WHERE id = %s", (user_id,))

# 2. Валидация и whitelist вместо выполнения
ALLOWED_COMMANDS = {'sum', 'multiply'}
if command in ALLOWED_COMMANDS:
    result = safe_execute(command, args)

# 3. Безопасная десериализация
import json
data = json.loads(user_input)  # Безопасно, не выполняет код

# 4. Безопасное выполнение команд
subprocess.run(['ls', filename], shell=False)  # Безопасно

# 5. Sandbox для выполнения кода (если необходимо)
from RestrictedPython import compile_restricted
code = compile_restricted(user_code, '<inline>', 'exec')
exec(code)  # В ограниченном окружении
```

---

### 98. Какой вариант кода уязвим к SQL-инъекции?

**Ответ:** Уязвимость **SQL Injection (CWE-89)** возникает при конкатенации пользовательского ввода в SQL-запросы без экранирования.

**Примеры уязвимого кода:**

**1. Прямая конкатенация в строку:**
```python
# УЯЗВИМО
user_id = request.args.get('id')
query = f"SELECT * FROM users WHERE id = {user_id}"
cursor.execute(query)
```

**2. Конкатенация через + или %:**
```python
# УЯЗВИМО
username = request.form.get('username')
query = "SELECT * FROM users WHERE username = '" + username + "'"
cursor.execute(query)

# УЯЗВИМО
query = "SELECT * FROM users WHERE username = '%s'" % username
cursor.execute(query)
```

**3. Использование .format() с SQL:**
```python
# УЯЗВИМО
table_name = request.args.get('table')
query = "SELECT * FROM {}".format(table_name)
cursor.execute(query)
```

**4. PHP: конкатенация в запрос:**
```php
<?php
// УЯЗВИМО
$user_id = $_GET['id'];
$query = "SELECT * FROM users WHERE id = " . $user_id;
$result = mysqli_query($conn, $query);

// УЯЗВИМО
$username = $_POST['username'];
$query = "SELECT * FROM users WHERE username = '$username'";
$result = mysqli_query($conn, $query);
?>
```

**5. Использование неправильных методов экранирования:**
```python
# УЯЗВИМО - addslashes() недостаточно для SQL
import MySQLdb
username = request.form.get('username')
escaped = MySQLdb.escape_string(username)  # Не всегда достаточно
query = f"SELECT * FROM users WHERE username = '{escaped}'"
```

**6. Динамическое построение WHERE:**
```python
# УЯЗВИМО
filters = []
if request.args.get('name'):
    filters.append(f"name = '{request.args.get('name')}'")
if request.args.get('email'):
    filters.append(f"email = '{request.args.get('email')}'")

query = "SELECT * FROM users WHERE " + " AND ".join(filters)
```

**Безопасные альтернативы:**

**1. Параметризованные запросы (prepared statements):**
```python
# БЕЗОПАСНО
user_id = request.args.get('id')
cursor.execute("SELECT * FROM users WHERE id = %s", (user_id,))

# БЕЗОПАСНО - несколько параметров
cursor.execute(
    "SELECT * FROM users WHERE username = %s AND email = %s",
    (username, email)
)
```

**2. Использование ORM:**
```python
# БЕЗОПАСНО - SQLAlchemy
user = User.query.filter_by(username=username).first()

# БЕЗОПАСНО - Django ORM
User.objects.filter(username=username)
```

**3. Валидация и whitelist для динамических частей:**
```python
# БЕЗОПАСНО - whitelist для имён таблиц
ALLOWED_TABLES = {'users', 'products', 'orders'}
table = request.args.get('table')
if table not in ALLOWED_TABLES:
    raise ValueError("Invalid table")

query = f"SELECT * FROM {table}"  # Безопасно, так как проверено
```

**4. Использование безопасных методов экранирования:**
```python
# БЕЗОПАСНО - использование identifier quoting
from sqlalchemy import text
table_name = 'users'  # Валидировано
query = text(f"SELECT * FROM {table_name}")
```

**Рекомендации:**
- Всегда используйте параметризованные запросы
- Используйте ORM вместо прямых SQL-запросов
- Валидируйте пользовательский ввод
- Используйте whitelist для динамических частей запроса (имена таблиц, колонок)

---

### 99. Как реализуется защита от command injection в Python?

**Ответ:** Защита от **Command Injection (CWE-78)** в Python реализуется следующими способами:

**1. Использование subprocess с списком аргументов (без shell):**
```python
import subprocess

# БЕЗОПАСНО: передача аргументов списком
user_input = request.args.get('filename')
subprocess.run(['ls', '-l', user_input])  # user_input передаётся как отдельный аргумент

# ОПАСНО: использование shell=True
subprocess.run(f"ls -l {user_input}", shell=True)  # Уязвимо к инъекции
```

**2. Валидация и санитизация входных данных:**
```python
import re
import shlex

def validate_filename(filename):
    """Валидация имени файла по allowlist"""
    # Только безопасные символы
    if not re.match(r'^[a-zA-Z0-9._-]+$', filename):
        raise ValueError("Invalid filename")
    
    # Запрет path traversal
    if '..' in filename or '/' in filename:
        raise ValueError("Path traversal detected")
    
    return filename

# Использование
safe_filename = validate_filename(user_input)
subprocess.run(['cat', safe_filename])
```

**3. Использование shlex.quote() для экранирования:**
```python
import shlex

user_input = request.args.get('path')
# Экранирование специальных символов
safe_path = shlex.quote(user_input)
subprocess.run(f"ls {safe_path}", shell=True)  # Безопасно, но лучше избегать shell
```

**4. Ограничение путей выполнения:**
```python
from pathlib import Path

BASE_DIR = Path("/var/www/uploads")

def safe_execute_command(filename):
    # Нормализация пути
    filepath = (BASE_DIR / filename).resolve()
    
    # Проверка, что путь внутри BASE_DIR
    try:
        filepath.relative_to(BASE_DIR.resolve())
    except ValueError:
        raise ValueError("Path outside allowed directory")
    
    # Безопасное выполнение
    subprocess.run(['cat', str(filepath)])
```

**5. Использование whitelist разрешённых команд:**
```python
ALLOWED_COMMANDS = {
    'list': ['ls', '-l'],
    'count': ['wc', '-l'],
    'grep': ['grep']
}

def execute_command(command_name, *args):
    if command_name not in ALLOWED_COMMANDS:
        raise ValueError("Command not allowed")
    
    cmd = ALLOWED_COMMANDS[command_name].copy()
    cmd.extend(args)
    
    subprocess.run(cmd)  # Безопасно
```

**6. Ограничение прав выполнения:**
```python
import subprocess

def restricted_execute(cmd, args):
    # Выполнение с ограниченными правами
    result = subprocess.run(
        cmd + args,
        shell=False,
        timeout=5,  # Таймаут
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        check=False  # Не выбрасывать исключение при ошибке
    )
    return result
```

**7. Использование специализированных библиотек:**
```python
# Использование библиотек вместо прямых команд
import shutil  # Вместо shell команд для файловых операций

# Вместо: subprocess.run(['cp', src, dst])
shutil.copy(src, dst)  # Безопасно

# Вместо: subprocess.run(['rm', '-rf', path])
os.remove(path)  # Безопасно, но нужно валидировать путь
```

**8. Полный пример безопасной реализации:**
```python
import subprocess
import re
from pathlib import Path

class SafeCommandExecutor:
    def __init__(self, base_dir):
        self.base_dir = Path(base_dir).resolve()
    
    def list_files(self, directory):
        """Безопасное выполнение ls"""
        # Валидация директории
        if not re.match(r'^[a-zA-Z0-9._/-]+$', directory):
            raise ValueError("Invalid directory name")
        
        dir_path = (self.base_dir / directory.lstrip('/')).resolve()
        
        # Проверка, что путь внутри base_dir
        try:
            dir_path.relative_to(self.base_dir)
        except ValueError:
            raise ValueError("Path outside allowed directory")
        
        # Безопасное выполнение
        result = subprocess.run(
            ['ls', '-l', str(dir_path)],
            shell=False,
            capture_output=True,
            text=True,
            timeout=5
        )
        
        if result.returncode != 0:
            raise RuntimeError(f"Command failed: {result.stderr}")
        
        return result.stdout

# Использование
executor = SafeCommandExecutor("/var/www/uploads")
files = executor.list_files("documents")
```

**Рекомендации:**
- Никогда не используйте `shell=True` с пользовательским вводом
- Всегда передавайте аргументы списком в `subprocess.run()`
- Валидируйте и санитизируйте входные данные
- Используйте whitelist для команд и путей
- Ограничивайте права выполнения
- Используйте таймауты для команд
- Предпочитайте библиотеки вместо shell команд

---

### 100. Какие методы используются для защиты от XXE-атак?

**Ответ:** **XXE (XML External Entity, CWE-611)** — уязвимость, позволяющая атакующему читать локальные файлы или выполнять удалённые запросы через обработку XML.

**Методы защиты:**

**1. Отключение обработки внешних сущностей:**
```python
from lxml import etree

# БЕЗОПАСНО: отключение внешних сущностей
parser = etree.XMLParser(resolve_entities=False, no_network=True)
tree = etree.parse(xml_file, parser)
```

```java
// Java - отключение внешних сущностей
DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
dbf.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
dbf.setFeature("http://xml.org/sax/features/external-general-entities", false);
dbf.setFeature("http://xml.org/sax/features/external-parameter-entities", false);
dbf.setExpandEntityReferences(false);
```

**2. Валидация и фильтрация XML:**
```python
import re

def sanitize_xml(xml_string):
    """Удаление опасных конструкций из XML"""
    # Удаление DOCTYPE
    xml_string = re.sub(r'<!DOCTYPE[^>]*>', '', xml_string)
    
    # Удаление внешних сущностей
    xml_string = re.sub(r'&[^;]+;', '', xml_string)
    
    return xml_string

# Использование
safe_xml = sanitize_xml(user_xml)
```

**3. Использование безопасных парсеров:**
```python
# Python: использование defusedxml
from defusedxml import ElementTree

# defusedxml автоматически отключает опасные функции
tree = ElementTree.parse(xml_file)  # Безопасно
```

```python
# Python: использование xml.etree.ElementTree с ограничениями
import xml.etree.ElementTree as ET
from xml.etree.ElementTree import XMLParser

class SafeXMLParser(XMLParser):
    def __init__(self):
        super().__init__()
        # Отключение внешних сущностей
        self.parser.UseForeignDTD = False

parser = SafeXMLParser()
tree = ET.parse(xml_file, parser=parser)
```

**4. Whitelist разрешённых элементов:**
```python
ALLOWED_ELEMENTS = {'name', 'email', 'phone'}
ALLOWED_ATTRIBUTES = {'id', 'type'}

def validate_xml_structure(root):
    """Валидация структуры XML по whitelist"""
    for elem in root.iter():
        if elem.tag not in ALLOWED_ELEMENTS:
            raise ValueError(f"Element not allowed: {elem.tag}")
        
        for attr in elem.attrib:
            if attr not in ALLOWED_ATTRIBUTES:
                raise ValueError(f"Attribute not allowed: {attr}")
```

**5. Ограничение размера XML:**
```python
MAX_XML_SIZE = 10 * 1024  # 10 KB

def parse_xml_safely(xml_string):
    """Безопасный парсинг XML с ограничением размера"""
    if len(xml_string) > MAX_XML_SIZE:
        raise ValueError("XML too large")
    
    parser = etree.XMLParser(resolve_entities=False)
    tree = etree.fromstring(xml_string, parser)
    return tree
```

**6. Использование JSON вместо XML:**
```python
# Предпочтительно использовать JSON вместо XML
import json

# JSON не поддерживает внешние сущности
data = json.loads(user_input)  # Безопасно
```

**7. Конфигурация на уровне приложения:**
```python
# Django - отключение XXE
# settings.py
SECURE_XXE_PROCESSING = False

# Flask
app.config['XML_PARSER_SECURE'] = True
```

**8. Использование Content Security Policy:**
```python
# Запрет загрузки внешних ресурсов
response.headers['Content-Security-Policy'] = "default-src 'self'"
```

**9. Полный пример безопасной обработки XML:**
```python
from defusedxml import ElementTree
from lxml import etree
import re

class SafeXMLProcessor:
    def __init__(self):
        self.max_size = 10 * 1024
        self.allowed_elements = {'user', 'name', 'email'}
    
    def process_xml(self, xml_string):
        # 1. Проверка размера
        if len(xml_string) > self.max_size:
            raise ValueError("XML too large")
        
        # 2. Удаление DOCTYPE
        xml_string = re.sub(r'<!DOCTYPE[^>]*>', '', xml_string, flags=re.IGNORECASE)
        
        # 3. Безопасный парсинг
        try:
            # Использование defusedxml
            tree = ElementTree.fromstring(xml_string)
        except Exception as e:
            raise ValueError(f"Invalid XML: {e}")
        
        # 4. Валидация структуры
        for elem in tree.iter():
            if elem.tag not in self.allowed_elements:
                raise ValueError(f"Element not allowed: {elem.tag}")
        
        return tree

# Использование
processor = SafeXMLProcessor()
tree = processor.process_xml(user_xml)
```

**10. Конфигурация веб-сервера:**
```nginx
# Nginx - ограничение размера тела запроса
client_max_body_size 10k;
```

**Рекомендации:**
- Отключите обработку внешних сущностей
- Используйте безопасные парсеры (defusedxml)
- Валидируйте структуру XML по whitelist
- Ограничивайте размер XML
- Предпочитайте JSON вместо XML
- Регулярно обновляйте XML-парсеры
- Используйте статический анализ для поиска уязвимостей XXE

---

## Источники:
- OWASP Top 10 (2021)
- CWE (Common Weakness Enumeration)
- OWASP Testing Guide
- Secure Coding Practices
- Best practices в области безопасного программирования
